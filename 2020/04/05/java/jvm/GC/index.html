<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.fkyang.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="垃圾收集器与内存分配策略现在都是准确性垃圾回收 关注要点：  那些内存需要回收 什么时候开始回收 如何回收   学习垃圾回收原因：虽然垃圾回收已经自动化，但是当垃圾回收成为更高并发量的瓶颈时，需要对其进行监控和调节">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM--垃圾回收">
<meta property="og:url" content="http://blog.fkyang.com/2020/04/05/java/jvm/GC/index.html">
<meta property="og:site_name" content="白苏的GitHub个人主页">
<meta property="og:description" content="垃圾收集器与内存分配策略现在都是准确性垃圾回收 关注要点：  那些内存需要回收 什么时候开始回收 如何回收   学习垃圾回收原因：虽然垃圾回收已经自动化，但是当垃圾回收成为更高并发量的瓶颈时，需要对其进行监控和调节">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/HotSpot%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%A6%82%E8%BF%B0%E5%9B%BE.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/HotSpot%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8-Serial%E6%94%B6%E9%9B%86%E5%99%A8.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/HotSpot%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8-ParNew%E6%94%B6%E9%9B%86%E5%99%A8.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/HotSpot%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8-CMS%E6%94%B6%E9%9B%86%E5%99%A8.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/HotSpot%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8-G1%E6%94%B6%E9%9B%86%E5%99%A8.jpg">
<meta property="article:published_time" content="2020-04-04T16:00:00.000Z">
<meta property="article:modified_time" content="2024-07-05T05:11:45.987Z">
<meta property="article:author" content="fkY">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/HotSpot%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%A6%82%E8%BF%B0%E5%9B%BE.jpg">

<link rel="canonical" href="http://blog.fkyang.com/2020/04/05/java/jvm/GC/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JVM--垃圾回收 | 白苏的GitHub个人主页</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">白苏的GitHub个人主页</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">编程之路</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.fkyang.com/2020/04/05/java/jvm/GC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="fkY">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="白苏的GitHub个人主页">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM--垃圾回收
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-05 00:00:00" itemprop="dateCreated datePublished" datetime="2020-04-05T00:00:00+08:00">2020-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-05 13:11:45" itemprop="dateModified" datetime="2024-07-05T13:11:45+08:00">2024-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/04/05/java/jvm/GC/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/04/05/java/jvm/GC/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h1><p>现在都是准确性垃圾回收</p>
<p>关注要点：</p>
<ol>
<li>那些内存需要回收</li>
<li>什么时候开始回收</li>
<li>如何回收</li>
</ol>
<blockquote>
<p>学习垃圾回收原因：虽然垃圾回收已经自动化，但是当垃圾回收成为更高并发量的瓶颈时，需要对其进行监控和调节</p>
</blockquote>
<span id="more"></span>

<p>程序计数器，虚拟机栈，本地方法栈：随线程的生命周期，栈帧的内存在编译器就确定(不考虑即时编译器的优化)。因此，不需要考虑内存的回收。</p>
<p>Java堆与方法区：不确定，运行时才能确定，垃圾收集器管理这一部分内存。</p>
<h2 id="判定对象已死：垃圾收集器的第一步"><a href="#判定对象已死：垃圾收集器的第一步" class="headerlink" title="判定对象已死：垃圾收集器的第一步"></a>判定对象已死：垃圾收集器的第一步</h2><p>第一步判断对象是否存活。死去：没有途径可以使用此对象。</p>
<h3 id="引用计数算法Reference-Counting"><a href="#引用计数算法Reference-Counting" class="headerlink" title="引用计数算法Reference Counting"></a>引用计数算法Reference Counting</h3><p>原理：每个对象持有一个引用计数器，有人引用，+1；引用失效，-1；若数值为0，则不会再被使用。</p>
<blockquote>
<p>优点：原理简单，判定效率高。</p>
<p>缺点：需要大量的额外处理才能正常工作。</p>
</blockquote>
<h3 id="可达性分析算法-Reachability-Analysis"><a href="#可达性分析算法-Reachability-Analysis" class="headerlink" title="可达性分析算法 Reachability Analysis"></a>可达性分析算法 Reachability Analysis</h3><p>基本思路：通过一系列<strong>GC Root <strong>的</strong>根对象</strong>作为起始节点集，从这些结点开始根据引用关系向下搜索，走过的路径称为“引用链”，如果某个对象到GC Root间没有任何引用链相连，则此对象不可到达。</p>
<p>Java中，可固定作为GC Roots的对象包含：</p>
<ol>
<li>虚拟机栈（栈帧的本地变量表）中的引用对象，方法堆栈用到的参数，局部变量，临时变量</li>
<li>方法区静态属性引用的对象，Java类的引用类型静态变量。</li>
<li>方法区中，常量引用的对象，比如：字符串常量池中的引用对象</li>
<li>JNI（Native方法）引用的对象。</li>
<li>Java虚拟机内部的引用，基本数据类型的Class对象，常驻的异常对象（NullPointException），系统类加载器</li>
<li>被同步锁（synchronized）持有的对象</li>
<li>反应Java虚拟机内部情况的JMXBean，JVMTI中注册的回调，本地代码缓存等。</li>
<li>其他临时性的对象</li>
</ol>
<p>GC回收中，注意内存的对象之间都是可以相互联系的。</p>
<h3 id="java的引用类型"><a href="#java的引用类型" class="headerlink" title="java的引用类型"></a>java的引用类型</h3><table>
<thead>
<tr>
<th>name</th>
<th>content</th>
</tr>
</thead>
<tbody><tr>
<td>强引用Strongly Reference</td>
<td>传统的引用定义，若对象有此引用，垃圾回收器不会回收</td>
</tr>
<tr>
<td>软引用Soft</td>
<td>还有用，非必须的对象，OOM前，把这些对象进行第二次回收</td>
</tr>
<tr>
<td>弱引用Weak</td>
<td>非必须，弱于软引用，生存到下一次垃圾收集器。GC开始工作时，无论当前内存是否足够，都会回收此类引用。</td>
</tr>
<tr>
<td>虚引用Phantom</td>
<td>最弱的引用，目的，在对象被gc回收时，能够收到通知。</td>
</tr>
</tbody></table>
<h3 id="java对象生存期"><a href="#java对象生存期" class="headerlink" title="java对象生存期"></a>java对象生存期</h3><p>两次标记进行回收：</p>
<blockquote>
<p>第一次标记：没有发现与GC Roots相连接的引用链</p>
<p>第二次标记：是否有必要执行finalize()方法，无必要或以及执行过，都当成没必要执行。</p>
<p>​						没必要执行，则进行第二次标记，等待被回收。</p>
<blockquote>
<p>Finalize（）流程：任何一个对象的此方法只会被调用一次。</p>
<ol>
<li>对象把自己放入F-Queue的队列之中。优先级较低的队列，虚拟机创建的队列，去执行finalize方法，不一定肯定执行完。（优先级较低，或者死循环）</li>
<li>稍后将对F-Queue中的对象进行标记，若连上GC Root，则逃脱，否则被回收。</li>
</ol>
<p>try–finally或者其他方法也可以完成此功能，finalize不提供保证一定执行。</p>
</blockquote>
</blockquote>
<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>方法区回收的性价比比较低：堆中，新生代中一次回收可以回收70%-90%的内存区域，而方法去很少</p>
<p>方法区回收的内容：废弃的常量 + 不再使用的类型</p>
<blockquote>
<ol>
<li><p>废弃常量：回收与java堆对象相似。字符串常量，其他类（接口），方法，字段的符号引用也与此类似。</p>
<p>当前系统没有一个引用常量池中的对象，发生内存回收，若有必要，清出常量池。</p>
</li>
<li><p>不再使用的类:以下三个需要全部满足</p>
<ol>
<li>该类实例全部被回收，java堆中不存在该类及其派生子类的实例。</li>
<li>加载该类的类加载器已经被回收，这个条件需要精心设计。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用。</li>
</ol>
<p>若满足这三个条件，可以被回收，不一定被回收，需要虚拟机进行参数设置。</p>
<blockquote>
<p> 在大量使用字节码框架(反射，动态代理)，或自定义类加载器的场景中(动态生成JSP)，java虚拟机需要具备类型卸载的功能，防止方法区过大。</p>
</blockquote>
</li>
</ol>
</blockquote>
<h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h3 id="新生代：标记复制"><a href="#新生代：标记复制" class="headerlink" title="新生代：标记复制"></a>新生代：标记复制</h3><p>不使用整理原因：整理比复制多了对象的拷贝（为了减少内存碎片）</p>
<ol>
<li>复制：从其他地方，移动到 suivi区<ol>
<li>直接将存活对象复制到另一块空闲内存区域中</li>
<li>按顺序分配内存–无内存碎片化问题</li>
</ol>
</li>
<li>整理：进行对象的交换（为了减少内存碎片）</li>
</ol>
<h3 id="老年代：标记-整理"><a href="#老年代：标记-整理" class="headerlink" title="老年代：标记-整理"></a>老年代：标记-整理</h3><p>标记整理算法解决来标记-清除算法的<strong>内存碎片化</strong>的问题，又解决了复制算法的两个Survivor区（<strong>额外内存</strong>）的问题</p>
<p>不用 标记–复制</p>
<ul>
<li>标记复制，在存活对象数量较多时，<ul>
<li>需要很多复制</li>
<li>也需要额外的内存空间</li>
</ul>
</li>
</ul>
<ul>
<li>弱分代：大多数对象是朝生夕灭的</li>
<li>强分代：熬过多次垃圾收集过程的对象就越难以消亡。</li>
<li>跨代引用假说：跨代引用相对于同代引用来说仅占少数。</li>
</ul>
<p>垃圾收集器的原则：把java堆划分不同的区域，把对象依据年龄放到不同的区域存储。</p>
<ul>
<li>新生代：每次垃圾收集有大批对象死去，每次回收后少量存活的对象，逐步晋升到老年代中</li>
<li>老年代：</li>
</ul>
<p>收集分类：</p>
<ul>
<li><p>部分收集Partial GC：不是完整的收集Java堆的垃圾收集</p>
<ul>
<li>Minor GC：新生代</li>
<li>Major GC：老年代</li>
<li>Mixed GC：混合收集</li>
</ul>
</li>
<li><p>整堆收集Full GC：收集整个Java堆和方法区的垃圾收集</p>
</li>
</ul>
<h2 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h2><p>首先<strong>标记</strong>出需要回收的对象，标记完成后，统一回收所有被标记的对象；</p>
<p>或者，标记存活的对象，统一回收未被标记的对象。</p>
<p>缺点：</p>
<ol>
<li>执行效率不稳定：效率随对象的增长而降低</li>
<li>内存空间的碎片化问题：标记清除产生大量不连续的内存碎片，大对象分配引发另一次垃圾回收。</li>
</ol>
<h2 id="标记复制算法：新生代的回收算法"><a href="#标记复制算法：新生代的回收算法" class="headerlink" title="标记复制算法：新生代的回收算法"></a>标记复制算法：新生代的回收算法</h2><p>目的:为了解决标记清除算法的效率低问题</p>
<p><em><strong>半区复制</strong></em>：把内存按容量分为大小相同的两块，每次使用其中的一块，垃圾回收的时候，就把存活的对象复制到另一块上</p>
<p>缺点：可用内存缩小一半。</p>
<p>优点：运行高效，实现简单，适用于大多数对象都是可回收的情形  —-  <em><strong>新生代</strong></em>。</p>
<h3 id="Appel式回收"><a href="#Appel式回收" class="headerlink" title="Appel式回收"></a>Appel式回收</h3><p>Appel式回收:Serial, ParNew等新生代收集器采用此方法设计新生代的内存布局。</p>
<p><em><strong>具体内容</strong></em>：把新生代分为一块<em><strong>较大的Eden</strong></em>空间，两块<em><strong>较小的Suivivor</strong></em>空间。</p>
<p>每次分配内存都只用Eden与一块Suivivor，发生垃圾收集时，将二者存活的对象放入未使用的Suivivor空间，然后直接清理用过的Eden与Suivivor空间。</p>
<p>Hotspot默认的Eden：Suivivor &#x3D; 8 ：1；每次新生代可用内存空间占据90%，只有一个10%的Suivivor会被浪费。</p>
<p>当发生垃圾回收的时候，Suivivor空间不足以容纳一次Minor GC存活的对象，就需要依赖其他区域（大多数时老年代）来进行<em><strong>分配担保</strong></em>。</p>
<h2 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h2><p>标记存活的对象，让存活的对象向一端移动，然后直接清除边界以外的内存。</p>
<blockquote>
<p>标记整理—移动活的对象：移动复杂，需要暂停程序，垃圾回收有<strong>停顿时间</strong></p>
<p>标记清除—不移动活得对象：分配复杂（碎片化），内存分配与访问器-降低吞吐量。垃圾回收无停顿时间</p>
</blockquote>
<ul>
<li>Parallel Scavenge：标记整理算法</li>
<li>CMS：平时标记清除,碎片化严重时标记整理</li>
</ul>
<h1 id="hotspot实现细节"><a href="#hotspot实现细节" class="headerlink" title="hotspot实现细节"></a>hotspot实现细节</h1><h2 id="根节点枚举GC-Roots"><a href="#根节点枚举GC-Roots" class="headerlink" title="根节点枚举GC Roots"></a>根节点枚举GC Roots</h2><p>根节点枚举时需要暂停用户线程</p>
<blockquote>
<p>现在可以与用户线程并发，但根节点枚举时仍然需要在保障一致性的快照中得以进行。</p>
<p>一致性：分析过程中，根节点集合的对象引用关系没有发生变化。</p>
<p>否则，正确性无法保证</p>
</blockquote>
<p>OopMap的数据结构：存放对象引用的地方。记录内存中那些地方有对象引用</p>
<blockquote>
<p>垃圾收集器直接通过这个数据结构的内容知晓对象引用的存储位置，不需要扫描GC Roots来查找</p>
<p>类加载完成后，就可以计算出类那些存有引用</p>
</blockquote>
<h2 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h2><p>安全点：在特定的位置上记录信息，这些位置为安全点</p>
<blockquote>
<p>指令必须到达安全点后才能进行垃圾回收。</p>
<p>安全点的选择：具有让程序长时间执行的特征，指令序列的服用的复用，方法调用，循环跳转，异常跳转等</p>
</blockquote>
<p>垃圾回收时，让所有的线程跑到最近的安全点停顿下来</p>
<ul>
<li>抢占式中断：不需要线程的执行代码主动去配合<ul>
<li>垃圾收集时，系统中断全部线程，若线程不在中断点上，就恢复线程的执行，过一会中断，知道安全点处</li>
</ul>
</li>
<li>主动式中断：垃圾回收时，不对线程进行操作，仅仅设置一个标志位<ul>
<li>线程轮流<strong>主动</strong>询问标志位，若标志位为真，自己就在最近的安全点上挂起，</li>
</ul>
</li>
</ul>
<h2 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h2><p>当程序处于sleep状态，Blocked状态，无法到达安全点</p>
<p>安全区域：在此区域内，引用关系不会发生变化。 ——- 扩展了的安全点</p>
<h2 id="记忆集与卡表（跨界引用问题）"><a href="#记忆集与卡表（跨界引用问题）" class="headerlink" title="记忆集与卡表（跨界引用问题）"></a>记忆集与卡表（跨界引用问题）</h2><p>记忆集：为了解决对象跨代引用的问题而引入的数据结构，避免把整个老年代加入GC Roots的扫描范围。</p>
<blockquote>
<p>记忆集：记录从非收集区域指向收集区域的指针集合的抽象数据结构。</p>
</blockquote>
<p>记录的精度：</p>
<ul>
<li>字长精度：每个记录精确到一个机器字长</li>
<li>对象精度：每个记录精确到一个对象</li>
<li>卡精度：记录精确到一块内存区域———最常见的</li>
</ul>
<p>卡表的一个单位，卡页通常不止一个对象，但只要有对象存在跨代引用，则该卡页标识为1</p>
<h2 id="GCRoot并行的可达性分析"><a href="#GCRoot并行的可达性分析" class="headerlink" title="GCRoot并行的可达性分析"></a>GCRoot并行的可达性分析</h2><p>三色标记算法：</p>
<ul>
<li>黑色：确定对象为非垃圾，并且其成员变量也找完了</li>
<li>灰色：确定对象为非垃圾，但是其成员变量尚未标完</li>
<li>白色：没有遍历的对象，垃圾对象</li>
</ul>
<p>对象消失问题：原本存活的对象，标记为死亡。</p>
<blockquote>
<p> 例子：原本灰色–&gt; 白色  转变为  黑色—&gt;白色  ，但是黑色已经被标记完成了，垃圾回收会把这个黑色相连的白色回收（但白色不是垃圾）</p>
</blockquote>
<p>解决方法：</p>
<ul>
<li>增量更新Incremental Update：黑色对象中新增指向白色对象的引用，把黑色对象变灰色<ul>
<li>写屏障更新</li>
<li>CMS</li>
</ul>
</li>
<li>原始快照Snapshot At The Beginning：灰色对象删除指向白色对象的引用时，记录删除的引用（白色），并发扫描结束后，看这些记录的删除的白色引用是否存在可达的（黑色）引用指向<ul>
<li>G1</li>
</ul>
</li>
</ul>
<h1 id="经典的垃圾回收器"><a href="#经典的垃圾回收器" class="headerlink" title="经典的垃圾回收器"></a>经典的垃圾回收器</h1><p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/HotSpot%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%A6%82%E8%BF%B0%E5%9B%BE.jpg" alt="HotSpot垃圾收集器"></p>
<p>Serial 几十M</p>
<p>Parallel 几个G</p>
<blockquote>
<p> 分代 需要写屏障</p>
</blockquote>
<p>CMS 几十G 开启并发回收</p>
<blockquote>
<p>三色标记 + 写屏障</p>
</blockquote>
<p>G1 上百G内存—–分区回收，逻辑分代，物理上不分</p>
<blockquote>
<p>三色标记 + SATB + 写批屏障</p>
</blockquote>
<p>ZGC,Shenandoah —-4T，逻辑物理不分代</p>
<blockquote>
<p>颜色指针 + 读屏障</p>
</blockquote>
<p>Epsilon 啥也不干，调试用，确认不需要GC参与，就能正常运行</p>
<h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>基于<strong>标记复制</strong>算法 </p>
<p>新生代收集器，<strong>单线程</strong>工作的</p>
<blockquote>
<p>单线程： </p>
<ul>
<li><p>只使用一个处理器</p>
</li>
<li><p>**Stop the World **在进行垃圾回收的时候，必须暂停其他所有工作线程，直到它收集结束</p>
</li>
</ul>
</blockquote>
<p>优点：简单而高效， 额外内存消耗最小，单核处理器的时候，没有线程交互的开销，效率高</p>
<p>大多数适合运行在客户端模式下的虚拟机</p>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/HotSpot%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8-Serial%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="HotSpot垃圾收集器-Serial收集器"></p>
<h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p>serial收集器的<strong>多线程并行</strong>版本，基于<strong>标记复制</strong>算法 ，<strong>STW</strong></p>
<p>能与CMS收集器配合工作，适合于服务端模式下的</p>
<p>在G1收集器出世之后，作为CMS处理新生代的基本组成部分，也是第一款退出的收集器。</p>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/HotSpot%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8-ParNew%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="HotSpot垃圾收集器-ParNew收集器"></p>
<h2 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h2><p>基于<strong>标记复制</strong>算法，并行收集的<strong>多线程</strong>收集器，不能与CMS一起使用</p>
<p>目的：达到一个可控制的吞吐量(Throughput)</p>
<p>吞吐量：处理器用于运行用户代码的时间与处理器总消耗时间的比值。</p>
<blockquote>
<p>吞吐量 &#x3D; 运行用户代码的时间&#x2F;（运行用户代码的时间 + 垃圾收集的时间 ）</p>
</blockquote>
<ul>
<li>停顿时间短:适合需要与用户交互或需要保证服务响应质量的程序</li>
<li>高吞吐量:最高效率的利用处理器资源,尽快完成程序的运算任务,时刻在后台运算不需要太多交互的任务</li>
</ul>
<blockquote>
<p>垃圾收集停顿时间缩短是以牺牲吞吐量为和新生代空间为代价的</p>
</blockquote>
<h2 id="Serial-Old收集器–Old"><a href="#Serial-Old收集器–Old" class="headerlink" title="Serial Old收集器–Old"></a>Serial Old收集器–Old</h2><p>serial收集器的老年代版本，单线程收集器，<strong>标记整理</strong>算法</p>
<p>使用：</p>
<ol>
<li>JDK5之前+Parallel Scavenge收集器搭配使用</li>
<li>作为CMS的失败的后备预案。</li>
</ol>
<h2 id="Parallel-Old收集器-–Old"><a href="#Parallel-Old收集器-–Old" class="headerlink" title="Parallel Old收集器 –Old"></a>Parallel Old收集器 –Old</h2><p>Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于<strong>标记整理</strong></p>
<p>适用于注重吞吐量，处理器资源比较稀缺、</p>
<h1 id="CMS于G1比较"><a href="#CMS于G1比较" class="headerlink" title="CMS于G1比较"></a>CMS于G1比较</h1><ul>
<li><p>并发时，线程继续运行的内存分配。</p>
</li>
<li><p>线程改变引用到错误处理：</p>
<ul>
<li>错标（）：是垃圾的标成了存活</li>
<li>漏标（）：不是垃圾的成了垃圾。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>NAME</th>
<th>并发</th>
<th>错标</th>
<th>漏标</th>
<th>跨界引用</th>
</tr>
</thead>
<tbody><tr>
<td>CMS</td>
<td>预留内存，<br />不够的时候，启动预留方案Serial old收集器</td>
<td>不够的时候，启动预留方案Serial old收集器</td>
<td>增量更新</td>
<td>一个卡表，记录新生代于老年代之间的引用</td>
</tr>
<tr>
<td>G1</td>
<td>region的一部分预留</td>
<td></td>
<td>原始快照</td>
<td>每个region维护一个卡表，记录自己指向其他，与其他指向自己</td>
</tr>
</tbody></table>
<h2 id="CMS收集器-Concurrent-Mark-Sweep-Old"><a href="#CMS收集器-Concurrent-Mark-Sweep-Old" class="headerlink" title="CMS收集器 Concurrent Mark Sweep Old"></a>CMS收集器 Concurrent Mark Sweep Old</h2><p>目标：<em>最短停顿时间</em>，基于<strong>标记清除</strong>，</p>
<p>适用于服务的响应速度要求高，系统的停顿时间短，更好的交互体验。</p>
<blockquote>
<p>耗时最长的2，4并发标记&#x2F;清除都是并发工作的</p>
<p>由于并发：</p>
<ol>
<li>gc线程占用资源</li>
<li>并发清除时间长，并发清除期间产生浮动垃圾</li>
<li>标记整理 碎片化</li>
</ol>
</blockquote>
<p>基于<strong>标记清除</strong>，过程分为四步</p>
<ol>
<li>初始标记 CMS initial mark—- <strong>STW</strong>停止用户线程<ol>
<li>标记<strong>GC Roots能直接关联</strong>的对象</li>
</ol>
</li>
<li>并发标记 CMS concurrent mark<ol>
<li>从GC Roots的直接关联对象开始遍历整个对象图的过程，可以与垃圾收集线程一起并发执行</li>
</ol>
</li>
<li>重新标记 CMS remark—-<strong>STW</strong>停止用户线程<ol>
<li>修正并发标记期间，因用户继续运作而导致标记产生变动的对象的标记记录。（增量更新）</li>
</ol>
</li>
<li>并发清除 CMS concurrent sweep<ol>
<li>清理删除标记阶段判断的已死亡的对象，不需要移动对象，标记清除算法</li>
</ol>
</li>
</ol>
<p>三色标记：</p>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/HotSpot%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8-CMS%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="HotSpot垃圾收集器-CMS收集器"></p>
<p>并发停顿收集器，三个缺点：</p>
<ol>
<li>对处理器资源非常敏感 – 并发占用资源导致应用程序变慢<ol>
<li>增量并发收集器，降低资源的消耗</li>
</ol>
</li>
<li>无法处理浮动垃圾，可能出现Concurrent Mode Failure导致Full GC<ol>
<li>浮动垃圾：CMS运行时产生的垃圾，标记过程以后，清除阶段产生的</li>
<li>Concurrent Mode Failure，<strong>预留的内存</strong>无法满足CMS运行时新分配对象的需要，启动预留方案，<strong>Serial old</strong>收集器运行，冻结用户进程</li>
</ol>
</li>
<li>标记清除，碎片化<ol>
<li>在Full GC前进行碎片整理（随着jdk版本的更新，设置的参数也没了-XX：）</li>
</ol>
</li>
</ol>
<h2 id="Garbage-First收集器-young-old"><a href="#Garbage-First收集器-young-old" class="headerlink" title="Garbage First收集器 young+old"></a>Garbage First收集器 young+old</h2><p><strong>标记复制算法</strong></p>
<p><strong>停顿时间模型</strong>的收集器：在长度M的时间片段中，垃圾回收消耗的时间大概率不超过N的目标</p>
<p>面向<strong>局部收集</strong>的设计思路，基于<strong>Region的内存布局</strong>。全功能的垃圾收集器。面向服务端的垃圾收集器，</p>
<p>局部收集：面向对内存的任何部分来组成<strong>回收集</strong>（Collection set Cset）进行回收，回收的衡量标准是哪块内存中存放的垃圾数量最多，<em>回收收益最大</em>。</p>
<h3 id="Region堆内存模型"><a href="#Region堆内存模型" class="headerlink" title="Region堆内存模型"></a>Region堆内存模型</h3><p>G1遵循分代收集理论，但不再坚持固定大小／数量的内存区域划分；把连续的Ｊａｖａ堆划分为多个大小相同的独立区域Region（-XX：G1HeapRegionSize 设置大小 1-32M 2的n次幂）。每一个Region都可以是Eden，suivive，老年代区域，收集器根据region所属的类型采用不同的垃圾回收策略。</p>
<p>Humongous区域：专门用来存储大对象的区域。基本上当作老年代</p>
<ul>
<li>大对象：大小超过了一个Region容量的一半的对象。</li>
<li>超级大对象（大小超过一个Region）：放在N个连续的Humongous Region区域，</li>
</ul>
<p>新生代与老年代是一系列动态区域的集合，把Region当成回收的最小单元每次回收的内存空间都是Region的整数倍。避免全区域的垃圾收集。</p>
<p>G1跟踪各个Region的价值（回收空间&#x2F;消耗时间）大小，维护一个优先级列表，优先回收价值收益最大的Region区域。</p>
<p>难点：</p>
<ul>
<li>跨引用：每个Region维护自己的记忆集，记录别的Region指向自己的指针，并标记这些指针在哪些卡页之中。<ul>
<li>G1的记忆集，hash表，key，其他region的起始地址，value，一个集合，存储卡表索引号。</li>
<li>双向指向：自身Region卡表谁指向我，其他region，我指向谁。</li>
<li>G1的卡表占用更多的内存消耗来记录信息。</li>
</ul>
</li>
<li>并发标记时：互不干扰：STAB（Snapshot at The Beginning ）原始快照。<ul>
<li>并发回收：为每一个Region设计两个TAMS（Top at Mark Start）指针，把Region的一部分划分出开用于并发回收时新对象的分配，并发回收时新对象地址在这两个指针上，G1默认这个地址上的对象时存活的</li>
<li>如果回收速度比不上内存分配速度，G1收集器被迫冻结用户线程执行。Full GC –STW</li>
</ul>
</li>
<li>可靠的停顿预测：衰减均值理论为基础，垃圾收集的时候，记录信息，衰减平均值。</li>
</ul>
<p>原始快照Snapshot：</p>
<p>G1收集器的步骤：</p>
<ol>
<li>初始标记 Initial Marking：GC Roots能够直接关联到的对象，修改TAMS的指针 <strong>STW</strong></li>
<li>并发标记Concurrent Marking：扫描整个堆的对象图，并发执行，扫描完成后，处理并发时SATB记录的变动对象。</li>
<li>最终标记 Final Marking：<strong>STW</strong>，处理并发标记阶段遗留的SATB记录</li>
<li>筛选回收Live Data Counting and Evacuation：更新Region的信息，排序Region的价值，组成回收集，把要回收的Region区域<strong>复制</strong>到空的Region，清理旧的Region–<strong>STW</strong>，移动对象，多个收集线程并行完成</li>
</ol>
<p>停顿时间-XX:MaxGCPauseMillis –过短，找到的满足条件的Region少，每次垃圾回收的量少，逐渐</p>
<p><em>目标：收集的速度跟得上对象分配的速度</em></p>
<p>G1相对CMS优点：可以指定最大停顿时间，整体标记整理，局部标记复制，垃圾收集能够提供规整的可用内存</p>
<p>总体 标记-整理，region之间，标记-复制，–不会产生内存碎片</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>垃圾回收的内（卡表）存占用大</li>
<li>程序运行的额外执行负载高：写后屏障维护卡表，STAB写前屏障跟踪并发指针变化。类似消息队列的结构，存储写前&#x2F;后屏障，异步处理。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/HotSpot%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8-G1%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="HotSpot垃圾收集器-G1收集器"></p>
<h1 id="低延迟垃圾收集器"><a href="#低延迟垃圾收集器" class="headerlink" title="低延迟垃圾收集器"></a>低延迟垃圾收集器</h1><p>衡量垃圾收集器的指标：内存占用（Footprint），吞吐量（Throughput），延迟（Latency）。</p>
<p>docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;technotes&#x2F;tools&#x2F;unix&#x2F;java.html</p>
<h2 id="Shenandoah收集器"><a href="#Shenandoah收集器" class="headerlink" title="Shenandoah收集器"></a>Shenandoah收集器</h2><h1 id="选择合适的收集器"><a href="#选择合适的收集器" class="headerlink" title="选择合适的收集器"></a>选择合适的收集器</h1><p>阅读和分析虚拟机与垃圾收集器的日志。</p>
<h1 id="调优方法"><a href="#调优方法" class="headerlink" title="调优方法"></a>调优方法</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol>
<li>吞吐量：用户代码时间&#x2F;（用户代码时间+垃圾回收时间）</li>
<li>响应时间：STW越短，响应时间越好</li>
</ol>
<p>换垃圾回收器，</p>
<h2 id="jvm常用命令行参数"><a href="#jvm常用命令行参数" class="headerlink" title="jvm常用命令行参数"></a>jvm常用命令行参数</h2><p>HotSpot参数：</p>
<blockquote>
<ol>
<li>标准：-开头，所有的HotSpot都支持</li>
<li>非标准：-X开头，特点支持</li>
<li>不稳定：-XX开通，下个版本可能没了</li>
</ol>
</blockquote>
<h2 id="CPU跑满"><a href="#CPU跑满" class="headerlink" title="CPU跑满"></a>CPU跑满</h2><h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><ol>
<li>内存泄漏 memory leak</li>
<li>内存溢出 OOM<ol>
<li>jmap看内存映像，找占内存的对象</li>
</ol>
</li>
</ol>
<h3 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h3><p>看线程</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/05/java/jvm/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/" rel="prev" title="JVM--类文件结构">
      <i class="fa fa-chevron-left"></i> JVM--类文件结构
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/05/java/jvm/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" rel="next" title="JVM--内存区域与溢出异常">
      JVM--内存区域与溢出异常 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="nav-number">1.</span> <span class="nav-text">垃圾收集器与内存分配策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E5%AE%9A%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB%EF%BC%9A%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AD%A5"><span class="nav-number">1.1.</span> <span class="nav-text">判定对象已死：垃圾收集器的第一步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95Reference-Counting"><span class="nav-number">1.1.1.</span> <span class="nav-text">引用计数算法Reference Counting</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95-Reachability-Analysis"><span class="nav-number">1.1.2.</span> <span class="nav-text">可达性分析算法 Reachability Analysis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java%E7%9A%84%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.3.</span> <span class="nav-text">java的引用类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%AD%98%E6%9C%9F"><span class="nav-number">1.1.4.</span> <span class="nav-text">java对象生存期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">1.1.5.</span> <span class="nav-text">回收方法区</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">垃圾回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%EF%BC%9A%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6"><span class="nav-number">2.0.1.</span> <span class="nav-text">新生代：标记复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%9A%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86"><span class="nav-number">2.0.2.</span> <span class="nav-text">老年代：标记-整理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="nav-number">2.1.</span> <span class="nav-text">标记清除算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95%EF%BC%9A%E6%96%B0%E7%94%9F%E4%BB%A3%E7%9A%84%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-number">2.2.</span> <span class="nav-text">标记复制算法：新生代的回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Appel%E5%BC%8F%E5%9B%9E%E6%94%B6"><span class="nav-number">2.2.1.</span> <span class="nav-text">Appel式回收</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="nav-number">2.3.</span> <span class="nav-text">标记整理算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hotspot%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="nav-number">3.</span> <span class="nav-text">hotspot实现细节</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B9%E8%8A%82%E7%82%B9%E6%9E%9A%E4%B8%BEGC-Roots"><span class="nav-number">3.1.</span> <span class="nav-text">根节点枚举GC Roots</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9"><span class="nav-number">3.2.</span> <span class="nav-text">安全点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="nav-number">3.3.</span> <span class="nav-text">安全区域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%B0%E5%BF%86%E9%9B%86%E4%B8%8E%E5%8D%A1%E8%A1%A8%EF%BC%88%E8%B7%A8%E7%95%8C%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98%EF%BC%89"><span class="nav-number">3.4.</span> <span class="nav-text">记忆集与卡表（跨界引用问题）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GCRoot%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90"><span class="nav-number">3.5.</span> <span class="nav-text">GCRoot并行的可达性分析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">4.</span> <span class="nav-text">经典的垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Serial%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">4.1.</span> <span class="nav-text">Serial收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ParNew%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">4.2.</span> <span class="nav-text">ParNew收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Parallel-Scavenge%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">4.3.</span> <span class="nav-text">Parallel Scavenge收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Serial-Old%E6%94%B6%E9%9B%86%E5%99%A8%E2%80%93Old"><span class="nav-number">4.4.</span> <span class="nav-text">Serial Old收集器–Old</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Parallel-Old%E6%94%B6%E9%9B%86%E5%99%A8-%E2%80%93Old"><span class="nav-number">4.5.</span> <span class="nav-text">Parallel Old收集器 –Old</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CMS%E4%BA%8EG1%E6%AF%94%E8%BE%83"><span class="nav-number">5.</span> <span class="nav-text">CMS于G1比较</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CMS%E6%94%B6%E9%9B%86%E5%99%A8-Concurrent-Mark-Sweep-Old"><span class="nav-number">5.1.</span> <span class="nav-text">CMS收集器 Concurrent Mark Sweep Old</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Garbage-First%E6%94%B6%E9%9B%86%E5%99%A8-young-old"><span class="nav-number">5.2.</span> <span class="nav-text">Garbage First收集器 young+old</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Region%E5%A0%86%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.2.1.</span> <span class="nav-text">Region堆内存模型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%8E%E5%BB%B6%E8%BF%9F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">6.</span> <span class="nav-text">低延迟垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Shenandoah%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">6.1.</span> <span class="nav-text">Shenandoah收集器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">7.</span> <span class="nav-text">选择合适的收集器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B0%83%E4%BC%98%E6%96%B9%E6%B3%95"><span class="nav-number">8.</span> <span class="nav-text">调优方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">8.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jvm%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="nav-number">8.2.</span> <span class="nav-text">jvm常用命令行参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU%E8%B7%91%E6%BB%A1"><span class="nav-number">8.3.</span> <span class="nav-text">CPU跑满</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Full-GC"><span class="nav-number">8.3.1.</span> <span class="nav-text">Full GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E5%BE%AA%E7%8E%AF"><span class="nav-number">8.3.2.</span> <span class="nav-text">死循环</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fkY"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">fkY</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fkYang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fkYang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fukai.yang@foxmail.com" title="E-Mail → mailto:fukai.yang@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fkY</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">158k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">2:24</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'y975d4MYQCK4R503CH0OprtL',
      appKey     : 'p6FKpeXQK0zqjyjAprd58ShD',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
