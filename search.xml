<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>博客图片无法显示</title>
    <url>/2020/04/30/dailyFun/error/</url>
    <content><![CDATA[<p>登录<a href="https://www.ipaddress.com/">ip查询网址</a>，查找raw.githubusercontent.com，获取对应的ip，修改hosts文件夹C:\Windows\System32\drivers\etc|hosts，尾部追加ip+域名</p>
]]></content>
  </entry>
  <entry>
    <title>私有云搭建流程记录</title>
    <url>/2024/07/05/dailyFun/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BA%91/</url>
    <content><![CDATA[<ol>
<li>设备购买</li>
<li>购买域名</li>
<li>私有云软件选择</li>
<li>安装docker</li>
<li>私有云软件的选择</li>
<li>初始化私有云软件，多端进行同步</li>
<li>搭建本地dns，加快局域网访问</li>
</ol>
<span id="more"></span>

<h1 id="1-设备购买"><a href="#1-设备购买" class="headerlink" title="1. 设备购买"></a>1. 设备购买</h1><p>搭建自己的私有云，肯定是全天24h在线，搜索了一下，大都推荐低功耗小主机，主要有以下优点</p>
<ul>
<li>节能省钱</li>
<li>减少噪音</li>
<li>功耗低，主机运行温度交际，延长硬件使用寿命</li>
<li>体积小</li>
</ul>
<p>目前来看，这个小主机主要是跑私有云服务和一些其他小项目，对CPU，内存等没有太大的要求，硬盘存储可能要高一些。内存和硬盘后续都可以通过更换开扩容，要考虑的主要是CPU与相应的主板（不同CPU插槽不一致，需要的主板不一致）。</p>
<p>市面上流通的小主机主要是3215U以及近乎同性能的j1900这几种CPU。一开始购买了3215U的小主机，结果跑不起来nextcloud云服务，没办法，只能再重新选一款。</p>
<p>我是从这三个网站上及性能CPU性能的比较的，主要是 <a href="https://www.cpubenchmark.net/cpu_list.php">cpu mark分数查询</a> 比较CPU跑分分数和功耗， <a href="https://cpu.bmcx.com/">cpu性能排行</a> 与 <a href="https://ark.intel.com/content/www/cn/zh/ark/search.html?_charset_=UTF-8&q=2650">因特尔芯片查询</a> 辅助查看性能信息。</p>
<img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/windows/20240704_CPU_search_mark.png" alt="image-20240704195240405" style="zoom: 67%;" />

<p>从芯片角度分析，如果说能够买到 因特尔至强系列E3L结尾的低功耗芯片，个人感觉还是很值的，性能足够 + 多核数 + 芯片插槽足够通用（后续有升级空间）。但是搜了一圈没搜货源，最后发现因特尔的这几个芯片很符合预期，综合多方考虑，最后选择了N100芯片的主机（价格较低，货源充足，性能也足够，3215U跑分1200，这个跑分5500）</p>
<img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/windows/20240704_CPU_N100_mark.png" alt="image-20240704200101005" style="zoom:67%;" />

<h1 id="2-购买域名"><a href="#2-购买域名" class="headerlink" title="2. 购买域名"></a>2. 购买域名</h1><p>之前大学期间也购买过阿里云的云服务器和域名，由于首年后续费价格波动较大，因此购买了  cloudflare 的域名，后需续费价格透明，大概每年10u。而且该平台也提供了很多基础能力使用，一站化管理域名相关信息</p>
<h1 id="3-选择私有云软件"><a href="#3-选择私有云软件" class="headerlink" title="3. 选择私有云软件"></a>3. 选择私有云软件</h1><p>网上的私有云平台有很多，流传的最多的有 owncloud 和 nextcloud这两个。这篇<a href="https://intellisoft.io/the-great-cloud-storage-debate-owncloud-vs-nextcloud-which-one-is-right-for-you/#Which_One_Do_You_Choose_Nextcloud_or_ownCloud">文章</a>从多方面比较了二者的不同，最后本人选择了nextcloud，因为这款软件完全开源</p>
<p>nextcloud有多种部署方法，考虑到后续服务上也会部署其他的服务，为了让数据资源更好的隔离，选择的docker方式部署</p>
<img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/windows/20240704_nextcloud_all_in_one.png" alt="image-20240704204122167" style="zoom: 80%;" />



<h1 id="4-下载并安装docker"><a href="#4-下载并安装docker" class="headerlink" title="4. 下载并安装docker"></a>4. 下载并安装docker</h1><blockquote>
<p>设备到手后，刷了ubuntu系统，这里推荐下 <a href="https://www.ventoy.net/cn/">ventoy</a> 软件，一键化支持多系统的安装，免费开源使用</p>
</blockquote>
<p>docker官网下载安装  <a href="https://docs.docker.com/desktop/install/linux-install/">Linux Desktop install</a>,</p>
<p><strong>问题记录</strong>：</p>
<ol>
<li><p>只需要安装docker desktop，不需要再额外安装dockerengine。docker存在context概念，docker desktop 自带了docker engine，不需要再 单独安装 docker engine，否则会安装两个不同context的docker engine</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker context ls 可以查看本机的docker context空间</span><br></pre></td></tr></table></figure></li>
</ol>
<p>Q：在3215u的机器上顺利安装，但是在n100机器安装时，这一步 curl 访问download.docker.com 超时，无法添加docker的apt库</p>
<p>A： 参考了这篇<a href="https://www.cnblogs.com/FFFirer/p/18247403">文章</a>，通过修改docker官方apt库为国内镜像站使得安装能够顺利完成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/linux/debian/gpg  中的debian更换为自己操作系统的名称</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/windows/20240704_docker_add_apt_repository.png" alt="image-20240704203513552"></p>
<h1 id="5-安装nextcloud-aio"><a href="#5-安装nextcloud-aio" class="headerlink" title="5. 安装nextcloud aio"></a>5. 安装nextcloud aio</h1><p><strong>aio安装与compose配置</strong></p>
<p>docker安装 nextcloud 很简单，只需要新建个 compose.yaml文件运行即可，具体可参考这个<a href="https://www.bilibili.com/video/BV1im41117yx/?spm_id_from=333.337.search-card.all.click&vd_source=000a5a2fca1e236b1a93542570b37b99">b站视频</a>，以下是我的compose文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本机访问10000 用于aio环境的初始化，cloudflare代理到10001，用于外网访问</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nextcloud-aio-mastercontainer:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nextcloud/all-in-one:latest</span></span><br><span class="line">    <span class="attr">init:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nextcloud-aio-mastercontainer</span> <span class="comment"># This line is not allowed to be changed as otherwise AIO will not work correctly</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nextcloud_aio_mastercontainer:/mnt/docker-aio-config</span> <span class="comment"># This line is not allowed to be changed as otherwise the built-in backup solution will not work</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock:ro</span> <span class="comment"># May be changed on macOS, Windows or docker rootless. See the applicable documentation. If adjusting, don&#x27;t forget to also set &#x27;WATCHTOWER_DOCKER_SOCKET_PATH&#x27;!</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config:/var/www/html/config</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="comment">#- 80:80 # Can be removed when running behind a web server or reverse proxy (like Apache, Nginx, Cloudflare Tunnel and else). See https://github.com/nextcloud/all-in-one/blob/main/reverse-proxy.md</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10000</span><span class="string">:8080</span> <span class="comment"># 端口映射，用于本机aio初始化，</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">APACHE_PORT=10001</span> <span class="comment"># 映射的https访问路径</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">APACHE_IP_BINDING=0.0.0.0</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NEXTCLOUD_DATADIR=宿主机存储路径</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SKIP_DOMAIN_VALIDATION=true</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">tunnel:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">cloudflare/cloudflared:latest</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">cloudafare_tunnel</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">tunnel</span> <span class="string">run</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TUNNEL_TOKEN=your_token</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span> <span class="comment"># If you want to store the data on a different drive, see https://github.com/nextcloud/all-in-one#how-to-store-the-filesinstallation-on-a-separate-drive</span></span><br><span class="line">  <span class="attr">nextcloud_aio_mastercontainer:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nextcloud_aio_mastercontainer</span> <span class="comment"># This line is not allowed to be changed as otherwise the built-in backup solution will not work</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>cloudflare tunnel配置</strong></p>
<p>这里用到了 cloudflare tunnel，需要在cloudflare上新建个tunnel，token就是tunnel的token。tunnel的新建可以参考官方文档：<a href="https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/get-started/create-remote-tunnel/">clooudflare 新建 tunnel</a>，然后添加域名到ip到代理配置，这里使用http访问，ip为宿主机ip，端口为 <code>APACHE_PORT</code></p>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/mac/20240704_cloudflare_tunnel_config.png" alt="image-20240704233417935"></p>
<p><strong>问题记录</strong>：</p>
<p>Q：docker镜像拉取不下来</p>
<p>A：一般来说，有多种种解决方法，换镜像，搭建本地私有库，cloudflare搭建镜像转发网站。最后是基于cloudflare搭建Docker镜像（只需要注册账号，不需要持有域名）</p>
<ol>
<li><p>搭建本地私有库: 直接基于<a href="https://github.com/docker-archive/docker-registry">官方镜像</a>搭建，但是后续的维护太麻烦了，需要先下载下来然后push到私有仓库上，才能再从私有仓库里下载。搭建完成后，就不用了</p>
</li>
<li><p>cloudflare 搭建镜像转发网站：参考了这篇<a href="https://xjp.in/2024/06/23/%E4%BD%BF%E7%94%A8-Cloudflare-Workers%E8%87%AA%E5%BB%BA%E5%AE%8C%E5%85%A8%E5%85%8D%E8%B4%B9Docker%E9%95%9C%E5%83%8F%E6%9C%8D%E5%8A%A1/">博客</a>搭建的。实际搭建时，这个跑失败了，就直接从copy博主的代码，改了下域名</p>
<ol>
<li><pre><code>docker desktop添加镜像源
&#123;
  &quot;registry-mirrors&quot;: [
     &quot;https://docker-hub.fkyang.com&quot;
     // 最好加上前缀，不然可能会导致docker engine起不来
  ]
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. cloudflare worker代码</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">addEventListener(&quot;fetch&quot;, (event) =&gt; &#123;</span><br><span class="line">  event.passThroughOnException();</span><br><span class="line">  event.respondWith(handleRequest(event.request));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const dockerHub = &quot;https://registry-1.docker.io&quot;;</span><br><span class="line"></span><br><span class="line">const routes = &#123;</span><br><span class="line">  // 这里要改成你用来访问的域名，可以用它拉取容器镜像</span><br><span class="line">  &quot;docker-hub.fkyang.com&quot;: dockerHub,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function routeByHosts(host) &#123;</span><br><span class="line">  if (host in routes) &#123;</span><br><span class="line">    return routes[host];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function handleRequest(request) &#123;</span><br><span class="line">  const url = new URL(request.url);</span><br><span class="line">  const upstream = routeByHosts(url.hostname);</span><br><span class="line">  if (upstream === &quot;&quot;) &#123;</span><br><span class="line">    return new Response(</span><br><span class="line">      JSON.stringify(&#123;</span><br><span class="line">        routes: routes,</span><br><span class="line">      &#125;),</span><br><span class="line">      &#123;</span><br><span class="line">        status: 404,</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  const isDockerHub = upstream == dockerHub;</span><br><span class="line">  const authorization = request.headers.get(&quot;Authorization&quot;);</span><br><span class="line">  if (url.pathname == &quot;/v2/&quot;) &#123;</span><br><span class="line">    const newUrl = new URL(upstream + &quot;/v2/&quot;);</span><br><span class="line">    const headers = new Headers();</span><br><span class="line">    if (authorization) &#123;</span><br><span class="line">      headers.set(&quot;Authorization&quot;, authorization);</span><br><span class="line">    &#125;</span><br><span class="line">    // check if need to authenticate</span><br><span class="line">    const resp = await fetch(newUrl.toString(), &#123;</span><br><span class="line">      method: &quot;GET&quot;,</span><br><span class="line">      headers: headers,</span><br><span class="line">      redirect: &quot;follow&quot;,</span><br><span class="line">    &#125;);</span><br><span class="line">    if (resp.status === 401) &#123;</span><br><span class="line"> </span><br><span class="line">        headers.set(</span><br><span class="line">          &quot;Www-Authenticate&quot;,</span><br><span class="line">          `Bearer realm=&quot;https://$&#123;url.hostname&#125;/v2/auth&quot;,service=&quot;cloudflare-docker-proxy&quot;`</span><br><span class="line">        );</span><br><span class="line">      return new Response(JSON.stringify(&#123; message: &quot;UNAUTHORIZED&quot; &#125;), &#123;</span><br><span class="line">        status: 401,</span><br><span class="line">        headers: headers,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return resp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // get token</span><br><span class="line">  if (url.pathname == &quot;/v2/auth&quot;) &#123;</span><br><span class="line">    const newUrl = new URL(upstream + &quot;/v2/&quot;);</span><br><span class="line">    const resp = await fetch(newUrl.toString(), &#123;</span><br><span class="line">      method: &quot;GET&quot;,</span><br><span class="line">      redirect: &quot;follow&quot;,</span><br><span class="line">    &#125;);</span><br><span class="line">    if (resp.status !== 401) &#123;</span><br><span class="line">      return resp;</span><br><span class="line">    &#125;</span><br><span class="line">    const authenticateStr = resp.headers.get(&quot;WWW-Authenticate&quot;);</span><br><span class="line">    if (authenticateStr === null) &#123;</span><br><span class="line">      return resp;</span><br><span class="line">    &#125;</span><br><span class="line">    const wwwAuthenticate = parseAuthenticate(authenticateStr);</span><br><span class="line">    let scope = url.searchParams.get(&quot;scope&quot;);</span><br><span class="line">    // autocomplete repo part into scope for DockerHub library images</span><br><span class="line">    // Example: repository:busybox:pull =&gt; repository:library/busybox:pull</span><br><span class="line">    if (scope &amp;&amp; isDockerHub) &#123;</span><br><span class="line">      let scopeParts = scope.split(&quot;:&quot;);</span><br><span class="line">      if (scopeParts.length == 3 &amp;&amp; !scopeParts[1].includes(&quot;/&quot;)) &#123;</span><br><span class="line">        scopeParts[1] = &quot;library/&quot; + scopeParts[1];</span><br><span class="line">        scope = scopeParts.join(&quot;:&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return await fetchToken(wwwAuthenticate, scope, authorization);</span><br><span class="line">  &#125;</span><br><span class="line">  // redirect for DockerHub library images</span><br><span class="line">  // Example: /v2/busybox/manifests/latest =&gt; /v2/library/busybox/manifests/latest</span><br><span class="line">  if (isDockerHub) &#123;</span><br><span class="line">    const pathParts = url.pathname.split(&quot;/&quot;);</span><br><span class="line">    if (pathParts.length == 5) &#123;</span><br><span class="line">      pathParts.splice(2, 0, &quot;library&quot;);</span><br><span class="line">      const redirectUrl = new URL(url);</span><br><span class="line">      redirectUrl.pathname = pathParts.join(&quot;/&quot;);</span><br><span class="line">      return Response.redirect(redirectUrl, 301);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // foward requests</span><br><span class="line">  const newUrl = new URL(upstream + url.pathname);</span><br><span class="line">  const newReq = new Request(newUrl, &#123;</span><br><span class="line">    method: request.method,</span><br><span class="line">    headers: request.headers,</span><br><span class="line">    redirect: &quot;follow&quot;,</span><br><span class="line">  &#125;);</span><br><span class="line">  return await fetch(newReq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function parseAuthenticate(authenticateStr) &#123;</span><br><span class="line">  // sample: Bearer realm=&quot;https://auth.ipv6.docker.com/token&quot;,service=&quot;registry.docker.io&quot;</span><br><span class="line">  // match strings after =&quot; and before &quot;</span><br><span class="line">  const re = /(?&lt;=\=&quot;)(?:\\.|[^&quot;\\])*(?=&quot;)/g;</span><br><span class="line">  const matches = authenticateStr.match(re);</span><br><span class="line">  if (matches == null || matches.length &lt; 2) &#123;</span><br><span class="line">    throw new Error(`invalid Www-Authenticate Header: $&#123;authenticateStr&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">  return &#123;</span><br><span class="line">    realm: matches[0],</span><br><span class="line">    service: matches[1],</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function fetchToken(wwwAuthenticate, scope, authorization) &#123;</span><br><span class="line">  const url = new URL(wwwAuthenticate.realm);</span><br><span class="line">  if (wwwAuthenticate.service.length) &#123;</span><br><span class="line">    url.searchParams.set(&quot;service&quot;, wwwAuthenticate.service);</span><br><span class="line">  &#125;</span><br><span class="line">  if (scope) &#123;</span><br><span class="line">    url.searchParams.set(&quot;scope&quot;, scope);</span><br><span class="line">  &#125;</span><br><span class="line">  const headers = new Headers();</span><br><span class="line">  if (authorization) &#123;</span><br><span class="line">    headers.set(&quot;Authorization&quot;, authorization);</span><br><span class="line">  &#125;</span><br><span class="line">  return await fetch(url, &#123; method: &quot;GET&quot;, headers: headers &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
<h1 id="6-初始化nextcloud，并进行多端数据同步"><a href="#6-初始化nextcloud，并进行多端数据同步" class="headerlink" title="6 初始化nextcloud，并进行多端数据同步"></a>6 初始化nextcloud，并进行多端数据同步</h1><p>登录 <code>https://localhost:port</code>后，记下密码，跳转登录，然后选择需要的组件，填入域名 ，确认时区后，就可以开启服务了。需要注意的是，首次启动需要下载所有容器的docker镜像，会有一定的耗时，所有组件都选择的情况下，大概最后会再多启动11个容器。</p>
<p><strong>问题记录</strong>：</p>
<p>Q: 本地访问 <code>localhoist:port</code> 后，页面<strong>没有进入初始密码的登陆页面</strong>，直接跳转到密码输入页面，密码登陆一直校验失败。</p>
<p>A: 下载 aio 代码，查看 登录密码校验接口的校验逻辑，找到密码存储位置，copy出来解决的，只能说幸好密码是明文存储的。密码在docker容器中的存储路径如下：<code>/mnt/docker-aio-config/data/configuration.json</code></p>
<p>Q：服务部署后，web网页，windows，安卓端都可以正常访问，但是mac端使用nextcloud desktop登陆时，提示 <code>There was an error accessing the &#39;token&#39; endpoint: Error transferring https://xx.com/index.php/login/v2 - server replied: Forbidden</code> 报错。</p>
<img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/windows/20240704_nextcloud_mac_desktop_login_err.png" alt="image-20240704214044211" style="zoom: 33%;" />

<p>A： </p>
<p>问题排查</p>
<ol>
<li><p>客户端登录了官方的网站 <code>demos.nextcloud.com</code>试了下，可以正常访问，排除了客户端权限等配置的问题</p>
<img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/mac/20240704_mac_curl_login.png" alt="image-20240704133151231" style="zoom:50%;" /></li>
<li><p>按照<a href="https://docs.nextcloud.com/server/latest/developer_manual/client_apis/LoginFlow/index.html">官方 Login Flow的文档</a>，基于curl 调用了接口，发现可以正常访问</p>
<img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/mac/20240704_mac_curl_loginv2.png" alt="image-20240704142309085" style="zoom:50%;" /></li>
<li><p>排查得出结论，mac客户端访问时，多&#x2F;少携带了某些参数导致无法正常访问</p>
</li>
</ol>
<p>问题解决：最后参考这篇<a href="https://help.nextcloud.com/t/login-flow-errors-and-links-not-opening-macosx-ventura-13-4-and-nextcloud-desktop-v3-8-2/162891">文章</a>，关闭了cloudflare的 Browser Integrity Check 能力后，就可以正常登陆访问了</p>
<img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/mac/20240704_cloudflare_Browser_Integrity_Check.png" alt="image-20240704141908835" style="zoom:33%;" />



<h1 id="7-搭建本地DNS服务器，加快局域网内访问"><a href="#7-搭建本地DNS服务器，加快局域网内访问" class="headerlink" title="7 搭建本地DNS服务器，加快局域网内访问"></a>7 搭建本地DNS服务器，加快局域网内访问</h1><ol>
<li>按照官方文档搭建，docker直接部署 <a href="https://github.com/pi-hole/docker-pi-hole">GitHub PiHole</a>， 访问 <a href="http://localhost:9999/admin">http://localhost:9999/admin</a> 配置，添加一条dns记录</li>
</ol>
<p>compose文件，基本copy的官方文件，做了一些修改</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># More info at https://github.com/pi-hole/docker-pi-hole/ and https://docs.pi-hole.net/</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">pihole:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">pihole</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">pihole/pihole:latest</span></span><br><span class="line">    <span class="comment"># For DHCP it is recommended to remove these ports and instead add: network_mode: &quot;host&quot;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="comment"># 添加了本机ip前缀，防止启动报错</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;192.168.1.22:53:53/tcp&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;192.168.1.22:53:53/udp&quot;</span></span><br><span class="line">      <span class="comment"># - &quot;67:67/udp&quot; # Only required if you are using Pi-hole as your DHCP server</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9999:80/tcp&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">&#x27;Asis/ShangHai&#x27;</span></span><br><span class="line">      <span class="attr">WEBPASSWORD:</span> <span class="string">&#x27;1102&#x27;</span></span><br><span class="line">      <span class="attr">WEB_ROOT:</span> </span><br><span class="line">      <span class="attr">DNS1:</span> <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">      <span class="attr">DNS2:</span> <span class="number">1.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">      <span class="comment"># WEBPASSWORD: &#x27;set a secure password here or it will be random&#x27;</span></span><br><span class="line">    <span class="comment"># Volumes store your data between container upgrades</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;./etc-pihole:/etc/pihole&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;./etc-dnsmasq.d:/etc/dnsmasq.d&#x27;</span></span><br><span class="line">    <span class="comment">#   https://github.com/pi-hole/docker-pi-hole#note-on-capabilities</span></span><br><span class="line">    <span class="comment"># cap_add:</span></span><br><span class="line">    <span class="comment">#   - NET_ADMIN # Required if you are using Pi-hole as your DHCP server, else not needed</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>web访问的情况下，文件上传下载速度较慢（要经过cloudflare的tunnel跨域访问），然后局域网内的其他电脑把 PiHole加入DNS服务器内<ol>
<li><p>未搭建本地DNS，ping平均延时150ms</p>
<img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/mac/20240704_mac_ping_mycloud.png" alt="image-20240704141650700" style="zoom:50%;" />
</li>
<li><p>搭建本地DNS服务器后，ping延时有明显下降</p>
<img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/mac/20240704_mac_ping_local_dns.png" alt="image-20240704142545474" style="zoom:50%;" /></li>
</ol>
</li>
</ol>
<p><strong>问题记录</strong>：</p>
<p>Q: docker容器启动时，无法启动，提示 <code>端口被占用,tcp 0.0.0.0:53 bind : addredd already in use</code>,</p>
<p>A: 参考 <a href="https://github.com/sameersbn/docker-bind/issues/65">这个</a> 解决, compose文件的port配置 需要加上ip前缀，eg <code>ip地址:53:53</code></p>
]]></content>
      <categories>
        <category>personal service</category>
      </categories>
  </entry>
  <entry>
    <title>Concurrent--锁--AQS</title>
    <url>/2020/07/03/java/concurrent/lock/AQS/</url>
    <content><![CDATA[<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>AQS ：<strong>模板方法模式</strong>，子类通过继承的方式，实现它的抽象方法来管理同步状态。</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractOwnableSynchronizer</span><span class="comment">//锁所属的线程操作相关的属性</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">3737899427754241961L</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">AbstractOwnableSynchronizer</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setExclusiveOwnerThread</span><span class="params">(Thread thread)</span> &#123;</span><br><span class="line">        exclusiveOwnerThread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Thread <span class="title function_">getExclusiveOwnerThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> exclusiveOwnerThread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实现类：可重入锁等锁的sync，线程池的worker等</p>
</blockquote>
<p>在基于 AQS 构建的同步器中，进入队列发生阻塞，从而降低上下文切换的开销，提高了吞吐量。</p>
<p>只有阻塞队列的首节点对应的线程处于运行状态，其他线程在短暂的加入队列后，就处于阻塞状态。</p>
<blockquote>
<p>AQS,CLH队列，每个节点通过设置前驱节点的waitstatus为signal后，尝试获取，失败后（此时前驱为signal），进入阻塞。同一时刻，只有头节点对应的线程处于同步状态，但是头节点的thread为null，其他线程进入CLH阻塞队列，设置前驱，获取失败后，进入阻塞状态。</p>
</blockquote>
<h2 id="可重写的方法"><a href="#可重写的方法" class="headerlink" title="可重写的方法"></a>可重写的方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//独占式获取同步状态</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();&#125;</span><br><span class="line"><span class="comment">//独占式释放同步状态。</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();  &#125;</span><br><span class="line"><span class="comment">//共享式获取同步状态，返回值大于等于 0 ，则表示获取成功</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();  &#125;</span><br><span class="line"><span class="comment">//共享式释放同步状态。</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();   &#125;</span><br><span class="line"><span class="comment">//当前同步器是否在独占式模式下被线程占用，一般该方法表示是否被当前线程所独占。</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="同步状态的标识"><a href="#同步状态的标识" class="headerlink" title="同步状态的标识"></a>同步状态的标识</h2><p>volatile修饰，java内存模型的可见性，使得所有线程能够读到修改后的数值</p>
<blockquote>
<p>不从本地内存读取volatile变量，从共享内存&#x2F;主内存读取，保障了可见性</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br></pre></td></tr></table></figure>

<p>仅仅AQS才能对这个变量进行操作，protected final类型的方法，保证了子类能够使用，但无法重写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;  state = newState;&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;   <span class="keyword">return</span> state; &#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">     <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);&#125;</span><br></pre></td></tr></table></figure>

<p>state状态：</p>
<ul>
<li>state &gt; 0 ：<ul>
<li>独占锁：表示该锁已被获得，重入的次数</li>
<li>共享锁：剩余的资源数</li>
</ul>
</li>
<li>state &#x3D;&#x3D;0 ：<ul>
<li>独占：没有线程获得锁</li>
<li>共享：没有可用的资源</li>
</ul>
</li>
</ul>
<h2 id="一些常用的方法"><a href="#一些常用的方法" class="headerlink" title="一些常用的方法"></a>一些常用的方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//独占式</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span><span class="comment">//独占式获取同步状态，成功，返回；失败，进入同步队列等待</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span><span class="comment">//响应中断</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquireNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span><span class="comment">//超时获取同步状态，超时，返回</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> <span class="comment">//独占式释放同步状态，唤醒首节点的下一个节点</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">//共享式，基本同上</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquireSharedNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> </span><br><span class="line"><span class="comment">//获取队列信息	</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedThreads</span><span class="params">()</span> &#123;<span class="keyword">return</span> head != tail;&#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h2 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h2><ul>
<li><p>入：当前线程，获取锁失败后，加入队列，设置前驱节点的waitStatus为signal（表明，后续有节点需要唤醒）。然后再次重复获取锁，失败后，由于前驱节点状态为signal，所以阻塞当前线程。</p>
</li>
<li><p>出：当首节点对应的线程，结束同步状态后，唤醒首节点的下一个节点，尝试获取锁。</p>
</li>
</ul>
<h3 id="Node静态内部类"><a href="#Node静态内部类" class="headerlink" title="Node静态内部类"></a>Node静态内部类</h3><p>一个node代表一个线程（队列存在的第一个首节点 除外，此首节点，thread &#x3D; null ）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// Node nextWaiter;的数值</span></span><br><span class="line">   <span class="comment">//共享</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="comment">//独占</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为超时或者中断，节点会被设置为取消状态：被取消的节点时不会参与到竞争中的，他会一直保持取消状态不会转变为其他状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 后继节点的线程处于等待状态：而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()后，该节点将会从等待队列中转移到同步队列中，加入到同步状态的获取中</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//表示下一次共享式同步状态获取，将会无条件地传播下去：用于共享式锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待状态，上面数值之一，默认 0：初始状态</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//前驱节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">  <span class="comment">//后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//该节点对应的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">	<span class="comment">//该 下一个节点 的类型， SHARED = new Node();EXCLUSIVE = null;</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回前驱节点</span></span><br><span class="line">    <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//默认，用于共享  队列的第一个首节点</span></span><br><span class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="type">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="入队列"><a href="#入队列" class="headerlink" title="入队列"></a>入队列</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="comment">// 快速尝试，添加新节点为尾节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;<span class="comment">//CAS并发安全，利用unsafe类实例</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);<span class="comment">//循环添加</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))<span class="comment">//此首节点，对应持有锁的线程，但是该节点并没有设置thread信息</span></span><br><span class="line">                    tail = head;<span class="comment">//默认第一个首节点，tail = head</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="出队列（首节点出队列）"><a href="#出队列（首节点出队列）" class="headerlink" title="出队列（首节点出队列）"></a>出队列（首节点出队列）</h3><p>首节点，完成同步代码块后，释放锁，唤醒首节点的下一个节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHead</span><span class="params">(Node node)</span> &#123;    head = node;    node.thread = <span class="literal">null</span>;    node.prev = <span class="literal">null</span>;&#125;</span><br><span class="line"><span class="comment">//头节点的线程始终为null，进入等待队列，新建节点的原因</span></span><br></pre></td></tr></table></figure>

<h2 id="独占式"><a href="#独占式" class="headerlink" title="独占式"></a>独占式</h2><p>独占式：<strong>同一时刻，仅有一个线程持有同步状态</strong>。</p>
<p>（根据ReenTrantLock）</p>
<h4 id="独占式获取：acquire"><a href="#独占式获取：acquire" class="headerlink" title="独占式获取：acquire"></a>独占式获取：acquire</h4><ul>
<li>acquire：对<strong>中断不敏感</strong>，后续对该线程进行中断操作时，线程<strong>不会</strong>从 CLH 同步队列中<strong>移除</strong>，仍旧在队列中等待获取锁</li>
</ul>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/java/concurrent/AQS/AQS-acquire%E6%97%B6%E5%BA%8F%E5%9B%BE.jpg" alt="AQS-acquire时序图"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">//通过查询此节点的前驱节点进行尝试获取锁的操作，</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">               <span class="comment">//只有头节点对应的线程处于同步状态，其他线程进入CLH阻塞队列，先设置前驱（回送should返回false，不阻塞）</span></span><br><span class="line">                <span class="comment">//再次尝试获取，获取失败后，shouldpark返回 true，进入阻塞状态。</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;<span class="comment">//设置中断标识</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)<span class="comment">//前驱节点已经为signal，可以进行阻塞</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;<span class="comment">//前驱节点被撤销，需要往前找到未被撤销的节点作为此节点的前驱节点</span></span><br><span class="line">        <span class="comment">//撤销的节点就从队列中移除了</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        <span class="comment">//前驱节点，数值为默认初始值0，设置为signal，此时返回false，不阻塞，需要再进行一次尝试获取以防并发冲突</span></span><br><span class="line">        <span class="comment">//A线程获取锁，B线程进入此方法的开始时，A线程释放锁，A线程不唤醒节点，B线程修改前驱为signal，回到acquireQueued循环再次尝试获取锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);<span class="comment">//将当前线程挂起，进入阻塞等待唤醒</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();<span class="comment">//返回当前线程是否被打断，并清理打断状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>撤销对锁的申请：从队列中移除此节点</p>
<p>由于节点的位置以及signal的设置，需要进行很多的判断与修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cancelAcquire</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// Ignore if node doesn&#x27;t exist</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    node.thread = <span class="literal">null</span>;<span class="comment">//移除该节点的线程</span></span><br><span class="line">    <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;<span class="comment">//循环回溯前驱节点，找到不处于撤销的前驱节点</span></span><br><span class="line">       <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span><br><span class="line">        <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span><br><span class="line">        <span class="comment">// or signal, so no further action is necessary.</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">predNext</span> <span class="operator">=</span> pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">    <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">    <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="literal">null</span>);<span class="comment">//设置尾节点的next为null</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If successor needs signal, try to set pred&#x27;s next-link</span></span><br><span class="line">        <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">        <span class="type">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="literal">null</span>) &#123;<span class="comment">//非首节点，传递后面节点的signal信息</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);<span class="comment">//从队列中，移除被撤销的节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//首节点</span></span><br><span class="line">            unparkSuccessor(node);<span class="comment">//唤醒首节点的后继结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        node.next = node; <span class="comment">// help GC，</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="独占式响应中断：acquireInterruptibly"><a href="#独占式响应中断：acquireInterruptibly" class="headerlink" title="独占式响应中断：acquireInterruptibly"></a>独占式响应中断：acquireInterruptibly</h4><p>acquireInterruptibly：在等待获取同步状态时，如果当前线程被中断了，会<strong>立刻</strong>响应中断，并抛出 InterruptedException 异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);<span class="comment">//自选，获取锁，或者 被中断，返回中断异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;<span class="comment">//抛出 InterruptedException 异常。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);<span class="comment">//构建节点，并加入队列</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();<span class="comment">//不设置中断标识，直接返回异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);<span class="comment">//中断结束，返回异常，撤销申请</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="独占式超时获取"><a href="#独占式超时获取" class="headerlink" title="独占式超时获取"></a>独占式超时获取</h4><p>tryAcquireNanos(int arg, long nanos)：对独占式响应中断的进一步增强，<strong>超时控制</strong>。即如果当前线程没有在指定时间内获取同步状态，则会返回 false ，否则返回 true 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquireNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);<span class="comment">//自选，直到获取锁 或 1. 中断异常 2. 超时</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">doAcquireNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> System.nanoTime() + nanosTimeout;<span class="comment">//// 超时时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);<span class="comment">//构建节点，并加入队列</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();<span class="comment">//获取失败，做超时、中断判断</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//已经超时，返回false</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<span class="comment">//同上，判断是否需要阻塞</span></span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                <span class="comment">//剩余时间大于 spinForTimeoutThreshold ，进入超时的park阻塞。</span></span><br><span class="line">                <span class="comment">//否则，说明距离超时的时间很短，非常短的时间等待无法做到十分精确，无条件的快速自选</span></span><br><span class="line">                LockSupport.parkNanos(<span class="built_in">this</span>, nanosTimeout);<span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())<span class="comment">// // 线程是否已经中断了</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;<span class="comment">//需要自定义同步组件自己实现，该方法必须要保证线程安全的释放同步状态。</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//首节点waitStatus== 0，表明首节点的后继节点对应的线程处于运行状态，不需要唤醒，会进行锁的尝试获取</span></span><br><span class="line">            <span class="comment">//A线程获取锁，B线程第一次进入acquireQueued，A线程释放锁，此时A线程不唤醒节点，B线程修改前驱为signal，回到acquireQueued循环再次尝试获取锁</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">        * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">        * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">       <span class="comment">//当前状态 &lt; 0 则设置为 0，修改首节点为默认状态，</span></span><br><span class="line">       <span class="comment">//？--猜测：由于线程已经释放锁资源，并且后面已经开始唤醒（signal 信息传递了出来），所以该节点对应的线程状态初始化</span></span><br><span class="line">       <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">           compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//若为signal，不初始化为0，若非公平锁，其他线程不进入队列，直接获得锁，导致失败</span></span><br><span class="line"></span><br><span class="line">       <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">       <span class="comment">//后继节点为null或者其状态 &gt; 0 (超时或者被中断了)，从尾部往前找第一个可以被唤醒的</span></span><br><span class="line">       <span class="comment">//从尾部往前找，顺序遍历下去，会导致死循环，cancelAcquire中设置取消的 node.next.next 指向的是 node.next</span></span><br><span class="line">       <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           s = <span class="literal">null</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">               <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                   s = t;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">           LockSupport.unpark(s.thread);<span class="comment">//唤醒阻塞的线程</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="释放锁资源与出队列关系"><a href="#释放锁资源与出队列关系" class="headerlink" title="释放锁资源与出队列关系"></a>释放锁资源与出队列关系</h5><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/java/concurrent/AQS/AQS出队列时序图.jpg" style="zoom:50%;" />

<blockquote>
<p>A线程：release–unparkSuccessor– </p>
<p>​		线程B：parkAndCheckInterrupt，park返回，至acquireQueued，循环获取锁，成功–setHead(node);，首节点出队列</p>
</blockquote>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>获取锁：获取失败后，会把自身线程构建节点，加入队列进行自旋</p>
<ul>
<li>自旋过程：<ul>
<li>判断前驱是否首节点<ul>
<li>是首节点：尝试获取锁</li>
</ul>
</li>
<li>判断是否阻塞<ul>
<li>第一次进入：由于前驱 waitStatus &#x3D; 0，会先设置为signal，返回false，开始第二次的自选</li>
<li>第二次进入： waitStatus&#x3D; signal，返回true，进入阻塞</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>释放锁：唤醒首节点的下一个节点。</p>
<h2 id="共享式"><a href="#共享式" class="headerlink" title="共享式"></a>共享式</h2><p>共享式：可以有<strong>多个</strong>线程获取同步状态。</p>
<h4 id="共享式同步状态获取"><a href="#共享式同步状态获取" class="headerlink" title="共享式同步状态获取"></a>共享式同步状态获取</h4><p>acquireShared(int arg)：享式获取同步状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)<span class="comment">//尝试获取，返回数值&gt;=0，成功</span></span><br><span class="line">        doAcquireShared(arg);<span class="comment">//循环获取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);<span class="comment">//创建共享式节点</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;<span class="comment">//只有在前驱为head的时候，才尝试共享式获取</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);<span class="comment">//获取锁后，设置首节点，并尝试唤醒其他的节点</span></span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);<span class="comment">//设置头节点</span></span><br><span class="line">   <span class="comment">// propagate &gt; 0 代码块，说明同步状态还能被其他线程获取。</span></span><br><span class="line">    <span class="comment">//判断后续是否存在需要唤醒的节点，</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();<span class="comment">//继续向后唤醒节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="共享式获取响应中断"><a href="#共享式获取响应中断" class="headerlink" title="共享式获取响应中断"></a>共享式获取响应中断</h4><p>基本类似独占式，把中断标识设置，改为抛出异常</p>
<h4 id="共享式超时获取"><a href="#共享式超时获取" class="headerlink" title="共享式超时获取"></a>共享式超时获取</h4><p>基本类似独占式，在响应中断的基础上，增加超时检查</p>
<h4 id="释放-1"><a href="#释放-1" class="headerlink" title="释放"></a>释放</h4><p>共享式释放，唤醒后续可以唤醒的所有（共享式，用户重写的子类，可能acquire的数量由用户指定，不是1，每次释放可能可以唤醒多个）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;<span class="comment">//需要自定义同步组件自己实现，该方法必须要保证线程安全的释放同步状态。</span></span><br><span class="line">        doReleaseShared();<span class="comment">//唤醒后继结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;<span class="comment">// 不管是共享还是独占只有结点状态为SIGNAL才尝试唤醒后继结点</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>)) <span class="comment">// 将waitStatus设置为0，表明已经唤醒过了</span></span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="comment">// 如果状态为0则更新状态为PROPAGATE，更新失败则重试</span></span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//h == head 表明，后续没有需要唤醒的了，结束循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>Executor框架--FutureTask</title>
    <url>/2020/07/03/java/concurrent/Executor/FutureTask/</url>
    <content><![CDATA[<h1 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h1><ul>
<li>FutureTask，run方法，调用callable的call方法。</li>
</ul>
<span id="more"></span>

<h3 id="run-方法"><a href="#run-方法" class="headerlink" title="run 方法"></a>run 方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> Callable&lt;V&gt; callable;    <span class="comment">//不存储Runnable变量，存Callable变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Runnable runnable, V result)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">        <span class="built_in">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="built_in">this</span>.callable = callable;</span><br><span class="line">        <span class="built_in">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//FutureTask的run方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">            !UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, runnerOffset,</span><br><span class="line">                                         <span class="literal">null</span>, Thread.currentThread()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">                V result;</span><br><span class="line">                <span class="type">boolean</span> ran;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    result = c.call();</span><br><span class="line">                    ran = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    result = <span class="literal">null</span>;</span><br><span class="line">                    ran = <span class="literal">false</span>;</span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ran)</span><br><span class="line">                    set(result);<span class="comment">//设置FutureTask的outcome属性值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">            <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">            runner = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">            <span class="comment">// leaked interrupts</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(V v)</span> &#123;<span class="comment">//设置call函数的返回值</span></span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;<span class="comment">//设置正在执行任务</span></span><br><span class="line">            outcome = v;</span><br><span class="line">            UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, NORMAL); <span class="comment">// final state，设置执行完毕</span></span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">finishCompletion</span><span class="params">()</span> &#123;<span class="comment">//call函数结束，得到并设置完返回值，调用此函数，唤醒get（）中阻塞的线程</span></span><br><span class="line">        <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">        <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="literal">null</span>;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, waitersOffset, q, <span class="literal">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> q.thread;</span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">                        q.thread = <span class="literal">null</span>;</span><br><span class="line">                        LockSupport.unpark(t);<span class="comment">//唤醒线程</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">WaitNode</span> <span class="variable">next</span> <span class="operator">=</span> q.next;</span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    q.next = <span class="literal">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                    q = next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        done();</span><br><span class="line">        callable = <span class="literal">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>taskFuture的状态量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NEW</span>          <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COMPLETING</span>   <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NORMAL</span>       <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCEPTIONAL</span>  <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span>    <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTING</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTED</span>  <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>函数阻塞：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">awaitDone</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">        <span class="type">WaitNode</span> <span class="variable">q</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//设置等待节点</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">queued</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q != <span class="literal">null</span>)</span><br><span class="line">                    q.thread = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">                Thread.<span class="keyword">yield</span>();<span class="comment">//在最后的设置阶段，很快就设置好了，循环获取，自旋</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="literal">null</span>)</span><br><span class="line">                q = <span class="keyword">new</span> <span class="title class_">WaitNode</span>();<span class="comment">//等待线程，多个同时get，多个线程同时等待</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">                queued = UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, waitersOffset,</span><br><span class="line">                                                     q.next = waiters, q);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    removeWaiter(q);</span><br><span class="line">                    <span class="keyword">return</span> state;</span><br><span class="line">                &#125;</span><br><span class="line">                LockSupport.parkNanos(<span class="built_in">this</span>, nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                LockSupport.park(<span class="built_in">this</span>);<span class="comment">//否则，阻塞当前线程，在构造队列节点之后</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> V <span class="title function_">report</span><span class="params">(<span class="type">int</span> s)</span> <span class="keyword">throws</span> ExecutionException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> outcome;</span><br><span class="line">        <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">            <span class="keyword">return</span> (V)x;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CancellationException</span>();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutionException</span>((Throwable)x);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>Executor框架</title>
    <url>/2020/07/03/java/concurrent/Executor/Exrcutor%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="Executor-框架"><a href="#Executor-框架" class="headerlink" title="Executor 框架"></a>Executor 框架</h1><p>Executor 提供了一种将“任务提交”与“任务执行”分离开来的机制，它仅提供了一个 <code>#execute(Runnable command)</code> 方法，用来执行已经提交的 Runnable 任务。</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Executor</span> &#123;    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/Executor%E6%A1%86%E6%9E%B6%E7%B1%BB%E5%9B%BE.png" alt="Executor框架类图"></p>
<p>executor结构主要包括任务、任务的执行和异步结果的计算。</p>
<ul>
<li><p>任务：包括被执行任务需要实现的接口：<strong>Runnable接口或Callable接口</strong></p>
</li>
<li><p>任务的执行：包括任务执行机制的核心接口<strong>Executor</strong>，以及继承自Executor的ExecutorService接口。L:Executor框架有两个关键类实现了ExecutorService接口（ThreadPoolExecutor和ScheduledThreadPoolExecutor）</p>
</li>
<li><p>异步计算的结果：包括接口<strong>Future和实现Future接口的FutureTask类</strong></p>
</li>
</ul>
<h2 id="1-任务执行框架"><a href="#1-任务执行框架" class="headerlink" title="1 任务执行框架"></a>1 任务执行框架</h2><img src="https://fkyang-blog-cloud-photo.oss-cn-beijing.aliyuncs.com/img/java/Executor/Executor框架.jpg" alt="Executor框架" style="zoom: 67%;" />

<h3 id="1-1-ExcutorService"><a href="#1-1-ExcutorService" class="headerlink" title="1.1 ExcutorService"></a>1.1 ExcutorService</h3><p><code>java.util.concurrent.ExcutorService</code> ，继承 Executor 接口，提供对线程的 生命周期的 管理，解耦任务的提交与执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExecutorService</span> <span class="keyword">extends</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br><span class="line">    List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span>;</span><br><span class="line"></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span>  <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                                  <span class="type">long</span> timeout, TimeUnit unit)</span>  <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span>  <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                    <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h4><p><code>java.util.concurrent.AbstractExecutorService</code> ，抽象类，实现 ExecutorService 接口，为其提供默认实现。</p>
<p><code>#newTaskFor(...)</code> 方法，返回一个 RunnableFuture 对象，封装Runnable任务 作为 Future 任务，它将生成可调用的结果作为其结果，并为底层任务提供取消操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="title function_">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><h3 id="1-2-ScheduledExecutorService"><a href="#1-2-ScheduledExecutorService" class="headerlink" title="1.2 ScheduledExecutorService"></a>1.2 ScheduledExecutorService</h3><p>继承 ExecutorService ，为一个“延迟”和“定期执行”的 ExecutorService </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建并执行在给定延迟后启用的 ScheduledFuture。</span></span><br><span class="line">&lt;V&gt; ScheduledFuture&lt;V&gt; <span class="title function_">schedule</span><span class="params">(Callable&lt;V&gt; callable, <span class="type">long</span> delay, TimeUnit unit)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并执行在给定延迟后启用的一次性操作。</span></span><br><span class="line">ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="type">long</span> delay, TimeUnit unit)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；</span></span><br><span class="line"><span class="comment">//也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。</span></span><br><span class="line">ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="type">long</span> initialDelay, <span class="type">long</span> period, TimeUnit unit)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。</span></span><br><span class="line">ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="type">long</span> initialDelay, <span class="type">long</span> delay, TimeUnit unit)</span><br></pre></td></tr></table></figure>

<h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><p>静态工厂类</p>
<h2 id="2-任务"><a href="#2-任务" class="headerlink" title="2 . 任务"></a>2 . 任务</h2><p><img src="https://fkyang-blog-cloud-photo.oss-cn-beijing.aliyuncs.com/img/java/Executor/Runnable%E6%8E%A5%E5%8F%A3%E6%A1%86%E6%9E%B6.jpg" alt="Runnable接口逻辑"></p>
<h3 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>对任务提供控制</p>
<ul>
<li><p>shutdown：不接受新的任务，等待所有的任务执行完毕</p>
</li>
<li><p>shutdownNow：中断正在执行的任务，返回未执行的任务列表</p>
</li>
</ul>
<p><code>java.util.concurrent.Future</code> ，作为异步计算的顶层接口，Future 对具体的 Runnable 或者 Callable 任务提供了三种操作：</p>
<ul>
<li>执行任务的取消</li>
<li>查询任务是否完成</li>
<li>获取任务的执行结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 试图取消对此任务的执行</span></span><br><span class="line"><span class="comment">     * 如果任务已完成、或已取消，或者由于某些其他原因而无法取消，则此尝试将失败。</span></span><br><span class="line"><span class="comment">     * 当调用 cancel 时，如果调用成功，而此任务尚未启动，则此任务将永不运行。</span></span><br><span class="line"><span class="comment">     * 如果任务已经启动，则 mayInterruptIfRunning 参数确定是否应该以试图停止任务的方式来中断执行此任务的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;<span class="comment">//如果在任务正常完成前将其取消，则返回 true</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;<span class="comment">//如果任务已完成，则返回 true</span></span><br><span class="line"></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;<span class="comment">//如有必要，等待计算完成，然后获取其结果</span></span><br><span class="line"></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span><span class="comment">//如有必要，最多等待为使计算完成所给定的时间之后，获取其结果（如果结果可用）</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RunnableFuture"><a href="#RunnableFuture" class="headerlink" title="RunnableFuture"></a>RunnableFuture</h4><p><code>java.util.concurrent.RunnableFuture</code> ，继承 Future、Runnable 两个接口，为两者的合体，即所谓的 Runnable 的 Future 。提供了一个 <code>#run()</code> 方法，可以完成 Future 并允许访问其结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Runnable</span>, Future&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><p><code>java.util.concurrent.FutureTask</code> ，实现 RunnableFuture 接口，既可以作为 Runnable 被执行，也可以作为 Future 得到 Callable 的返回值。</p>
<h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="tips：submit—-execute-的过程"><a href="#tips：submit—-execute-的过程" class="headerlink" title="tips：submit—&gt;execute 的过程"></a>tips：submit—&gt;execute 的过程</h1><h2 id="1-runnable—-callable"><a href="#1-runnable—-callable" class="headerlink" title="1. runnable—&gt; callable"></a>1. runnable—&gt; callable</h2><p>call 调用run方法,返回设定的数值</p>
<!--more-->

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="title function_">callable</span><span class="params">(Runnable task, T result)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (task == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RunnableAdapter</span>&lt;T&gt;(task, result);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RunnableAdapter</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;T&gt; &#123;</span><br><span class="line">       <span class="keyword">final</span> Runnable task;</span><br><span class="line">       <span class="keyword">final</span> T result;</span><br><span class="line">       RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">           <span class="built_in">this</span>.task = task;</span><br><span class="line">           <span class="built_in">this</span>.result = result;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> T <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">           task.run();<span class="comment">//call调用run方法，返回设定的result</span></span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-submit"><a href="#2-submit" class="headerlink" title="2. submit"></a>2. submit</h2><p>submit，创建RunnableFuture对象，把callable作为字段构造。</p>
<p>再调用execute（RunnableFuture）执行run方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title class_">ExecutorService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);<span class="comment">//利用Callable，Runnable构建RunnableFuture（TaskFuture）</span></span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="title function_">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="title function_">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;T&gt;(runnable, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>Concurrent--锁--Condition</title>
    <url>/2020/07/03/java/concurrent/lock/Condition/</url>
    <content><![CDATA[<h1 id="1-Condition"><a href="#1-Condition" class="headerlink" title="1. Condition"></a>1. Condition</h1><p>Condition是一个接口，一种条件队列，为线程提供了一种更为灵活的<strong>等待 &#x2F; 通知</strong>模式 ，必须要配合 Lock 一起使用，因为对共享状态变量的访问发生在多线程环境下。一个 Condition 的实例必须与一个 Lock 绑定，因此 Condition 一般都是作为 Lock 的内部实现。</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;<span class="comment">// 造成当前线程在接到信号或被中断之前一直处于等待状态。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;			<span class="comment">//同上，不响应中断</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException;<span class="comment">//响应中断，超时等待，返回值标识剩余时间</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;<span class="comment">//同上，但返回值标识</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="comment">//唤醒在条件上等待的线程，必须获得与Condion相关的锁</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span>;<span class="comment">//唤醒一个</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span>;<span class="comment">//唤醒所有</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h1><p>AQS的内部ConditionObject，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>, java.io.Serializable &#123;</span><br></pre></td></tr></table></figure>

<p>每个Conditon对象维护一个队列，该队列的Node就是AQS的队列的Node。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br></pre></td></tr></table></figure>

<p><code>await()</code> ：在当前线程持有锁的基础上释放锁资源，并新建 Condition 节点加入到 Condition 的队列尾部，阻塞当前线程 。</p>
<blockquote>
<p>新建节点，放到Condition的等待队列的尾部。</p>
</blockquote>
<p>signal()：将 Condition 的头节点移动到 AQS 等待节点尾部，让其等待再次获取锁。</p>
<blockquote>
<p>将 Condition 的头节点移动到 AQS 等待节点尾部，让其等待再次获取锁。</p>
</blockquote>
<h2 id="2-1-等待-入队列-await"><a href="#2-1-等待-入队列-await" class="headerlink" title="2.1 等待 入队列 await"></a>2.1 等待 入队列 await</h2><p>await：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();<span class="comment">//当前线程加入等待队列</span></span><br><span class="line">    <span class="comment">////释放锁，由于当前线程持有锁，进入等待队列后，需要释放锁</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;<span class="comment">//此节点的线程是否在同步队列上，</span></span><br><span class="line">        <span class="comment">//不在，则说明该线程还不具备竞争锁的资格，则继续等待</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)<span class="comment">///如果已经中断了，则退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 1.前驱节点为head唤醒后继（此节点）；2. signal-cancell/修改waitStatus失败；3：或者中断</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<span class="comment">//循环获取锁</span></span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="comment">// 清理下条件队列中的不是在等待条件的节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();<span class="comment">//Condition的方法，遍历链表将已经取消等待的节点清除出去</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Condition：</span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> &#123;<span class="comment">//新建节点并加入到Condition的等待队列</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">    <span class="comment">// If lastWaiter is cancelled, clean out.，Node的节点状态如果不为CONDITION，则表示该节点不处于等待状态，需要清除</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();<span class="comment">//清除Condition等待队列的撤销等待的节点</span></span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得尾节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;<span class="comment">//Node为双向链表，但是这里将其当作单链表</span></span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历链表将已经取消等待的节点清除出去</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlinkCancelledWaiters</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">trail</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 用于中间不需要跳过时，记录上一个 Node 节点</span></span><br><span class="line">    <span class="keyword">while</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> t.nextWaiter;</span><br><span class="line">        <span class="comment">// 如果节点的状态不是 Node.CONDITION 的话，这个节点就是被取消的</span></span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            t.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="literal">null</span>)<span class="comment">//第一个节点，首节点被撤销，需要</span></span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trail = t;</span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AQS方法：<span class="comment">//AQS</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullyRelease</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (release(savedState)) &#123;<span class="comment">//调用release，完全释放锁，由于该锁时可重入的</span></span><br><span class="line">                <span class="comment">//release--tryRelease,独占锁，需要验明是否持有当前锁</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> savedState;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();<span class="comment">//没有lock的时候，调用await-&gt;fullrealse</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                node.waitStatus = Node.CANCELLED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isOnSyncQueue</span><span class="params">(Node node)</span> &#123;<span class="comment">//检查该节点是否在AQS的阻塞队列中</span></span><br><span class="line">    <span class="comment">// 状态为 Condition，获取前驱节点为 null ，返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 后继节点不为 null，肯定在 CLH 同步队列中</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-通知-出队列-signal"><a href="#2-2-通知-出队列-signal" class="headerlink" title="2.2  通知 出队列 signal"></a>2.2  通知 出队列 signal</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())<span class="comment">//检查是否持有锁</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">        doSignal(first);<span class="comment">//唤醒</span></span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>)<span class="comment">//修改头节点</span></span><br><span class="line">                    lastWaiter = <span class="literal">null</span>;</span><br><span class="line">                first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;<span class="comment">//将节点移到AQS阻塞队列尾部</span></span><br><span class="line">                     (first = firstWaiter) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用AQS的方法，加入节点进入AQS的队列</span></span><br><span class="line"><span class="comment">//AQS:方法</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If cannot change waitStatus, the node has been cancelled.返回fasle，上层函数继续尝试移动节点从等待到阻塞</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!node.compareAndSetWaitStatus(Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);<span class="comment">//循环加入AQS阻塞队列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">        <span class="comment">//如果结点p的状态为cancel 或者修改waitStatus失败，则直接唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !p.compareAndSetWaitStatus(ws, Node.SIGNAL))</span><br><span class="line">            LockSupport.unpark(node.thread);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>await：</p>
<ul>
<li>新建节点加入到Condition的阻塞队列中</li>
<li>释放锁，由于可重入，FullRelease</li>
<li>循环调用 <code>isOnSyncQueue</code> 方法，检查该节点是否在AQS的CLH同步队列<ul>
<li>在，结束循环</li>
<li>不在，park阻塞</li>
</ul>
</li>
<li>调用 <code>acquireQueued</code> 尝试获取锁，</li>
</ul>
<p>signal：</p>
<ul>
<li>检查当前线程是否获取了锁</li>
<li>调用 <code>doSignal</code> 尝试将Condition等待队列的首届点 放入 AQS 的CLH同步队列 通过调用 AQS的enq（node）。</li>
</ul>
<h2 id="Demo：线程交替打印奇数偶数"><a href="#Demo：线程交替打印奇数偶数" class="headerlink" title="Demo：线程交替打印奇数偶数"></a>Demo：线程交替打印奇数偶数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.yfk.study.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类描述：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yfk</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintOddEven</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span>  <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">odd</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">even</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//012345</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        threadPool.execute(()-&gt;&#123;</span><br><span class="line">            oddRun();</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.execute(()-&gt;&#123;</span><br><span class="line">            evenRun();</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line"><span class="comment">//        Thread odd = new Thread(()-&gt;&#123;</span></span><br><span class="line"><span class="comment">//            oddRun();</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"><span class="comment">//        Thread even = new Thread(()-&gt;&#123;</span></span><br><span class="line"><span class="comment">//            evenRun();</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"><span class="comment">//        odd.start();</span></span><br><span class="line"><span class="comment">//        even.start();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//135,等待 1 3 5 ，需要 odd 换新g</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">oddRun</span><span class="params">()</span>&#123;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (nums == <span class="number">0</span>) &#123;<span class="comment">//0还没有被打印，odd奇数不应该打印</span></span><br><span class="line">               System.out.println(<span class="string">&quot;odd 先打印&quot;</span>);</span><br><span class="line">               odd.await();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">while</span>(nums &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;odd:&quot;</span>+nums);</span><br><span class="line">               nums++;</span><br><span class="line">               even.signal();</span><br><span class="line">               odd.await();;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//99 的时候，调用even打印100，even唤醒该节点101&gt;100，结束循环，</span></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 此时Even还在阻塞 1. 此处调用signal，</span></span><br><span class="line"><span class="comment">           *  2.even调用await之前，判断是否大于100，若大于，break，小于，阻塞</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">           even.signal();</span><br><span class="line">           System.out.println(<span class="string">&quot;odd over&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//246</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">evenRun</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">                System.out.println(nums);</span><br><span class="line">                nums++;</span><br><span class="line">                odd.signal();</span><br><span class="line">                even.await();</span><br><span class="line">            &#125;</span><br><span class="line">            odd.signal();</span><br><span class="line">            System.out.println(<span class="string">&quot;even over&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>Concurrent--锁--ReentrantLock</title>
    <url>/2020/07/03/java/concurrent/lock/reentranLock/</url>
    <content><![CDATA[<h1 id="1-ReentrantLock"><a href="#1-ReentrantLock" class="headerlink" title="1. ReentrantLock"></a>1. ReentrantLock</h1><p>ReentrantLock，可重入锁，互斥锁，等同于 <code>synchronized</code> 的使用， 提供了比 <code>synchronized</code> 更强大、灵活的锁机制，可以减少死锁发生的概率。</p>
<span id="more"></span>

<ul>
<li>缺点：syn具有可见性，这个锁不会对共享变量具有可见性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br></pre></td></tr></table></figure>

<p>使用的锁类型（通过构造函数设置，默认 非公平锁）</p>
<ul>
<li>公平锁：锁获取的是线程尝试获取锁的顺序<ul>
<li>尝试获取锁：检查是否有前驱节点</li>
</ul>
</li>
<li>非公平锁：效率较高</li>
</ul>
<p>ReentrantLock整体结构：</p>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/java/concurrent/reentranLock/reentranLock%E7%BB%93%E6%9E%84.jpg" alt="reentranLock结构"></p>
<h2 id="2-Sync"><a href="#2-Sync" class="headerlink" title="2. Sync"></a>2. Sync</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br></pre></td></tr></table></figure>

<p>Sync：ReentrantLock的一个内部静态抽象类,使用 AQS 的 <code>state</code> 字段，来表示当前锁的持有数量（独占锁），从而实现<strong>可重入</strong>的特性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;<span class="comment">//子类需要实现</span></span><br></pre></td></tr></table></figure>

<p>非公平的获取锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">//锁未被获得</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;<span class="comment">//直接尝试获取锁，不进行阻塞队列的判断</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<span class="comment">//锁被获得，检查当前线程是否持有锁的线程---可重入性</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<span class="comment">//验证当前线程是否持有锁，线程安全</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);<span class="comment">//取消锁 存储的持有锁信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);<span class="comment">//改变状态，真正释放锁</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>产生Condition对象，线程阻塞队列，基于可重入锁，通过锁的这个方法建立两个对象完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> ConditionObject <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-sync的实现类"><a href="#3-sync的实现类" class="headerlink" title="3. sync的实现类"></a>3. sync的实现类</h2><h3 id="3-1-NonfairSync"><a href="#3-1-NonfairSync" class="headerlink" title="3.1 NonfairSync"></a>3.1 NonfairSync</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))<span class="comment">//非公平锁，直接尝试获取锁，快速获取</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);<span class="comment">//获取失败，调用acquire（AQS），尝试获取，循环获取锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;<span class="comment">//直接调用sync的nonfairTryAcquire方法</span></span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-FairSync"><a href="#3-2-FairSync" class="headerlink" title="3.2 FairSync"></a>3.2 FairSync</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        acquire(<span class="number">1</span>);<span class="comment">//直接执行AQS的acquire获取锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;<span class="comment">//AQS的acquire调用此方法，进行尝试获取锁</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                  <span class="comment">//公平锁与非公平锁的区别就在这里，在尝试CAS获取锁的时候，是否进行阻塞队列有无元素的判断</span></span><br><span class="line">           		 <span class="comment">//公平：队列没有元素才获取，无元素-CAS；有元素：直接进入队列</span></span><br><span class="line">                <span class="comment">//非公平：两次CAS尝试获取后加入队列，不进行队列元素的判断，（可重入锁的非公平锁）</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);<span class="comment">//可重入锁，设置当前锁的持有线程（AQS的final方法）</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<span class="comment">//可重入锁的体现</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AQS类的：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;</span><br><span class="line">    Node h, s;</span><br><span class="line">    <span class="keyword">if</span> ((h = head) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//存在首节点</span></span><br><span class="line">        <span class="keyword">if</span> ((s = h.next) == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="literal">null</span>; <span class="comment">// traverse in case of concurrent cancellation</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> tail; p != h &amp;&amp; p != <span class="literal">null</span>; p = p.prev) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//获取队列的第一个等待获取锁的线程，</span></span><br><span class="line">        <span class="keyword">if</span> (s != <span class="literal">null</span> &amp;&amp; s.thread != Thread.currentThread())<span class="comment">//是否是第一个等待获取锁的线程</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//不存在首节点，/ 自己是队列中第一个等待获取锁的线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Lock接口"><a href="#4-Lock接口" class="headerlink" title="4 Lock接口"></a>4 Lock接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取锁</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;<span class="comment">//响应中断</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;<span class="comment">//尝试获取锁，立即返回</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;<span class="comment">//超时尝试获取</span></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//获取Condition对象</span></span><br><span class="line">Condition <span class="title function_">newCondition</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<h2 id="5-ReentrantLock"><a href="#5-ReentrantLock" class="headerlink" title="5. ReentrantLock"></a>5. ReentrantLock</h2><p>ReentrantLock 通过调用 Sync 来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取锁</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>									 &#123;  		sync.lock();&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> </span><br><span class="line">    <span class="keyword">throws</span> InterruptedException						 &#123;    sync.acquireInterruptibly(<span class="number">1</span>);&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> 								&#123;  <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException 				&#123; <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));&#125;</span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> 			&#123;    sync.release(<span class="number">1</span>);&#125;</span><br><span class="line"><span class="comment">//获取Condition对象</span></span><br><span class="line"><span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;  <span class="keyword">return</span> sync.newCondition();	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><p> ReentrantLock 提供了比 <code>synchronized</code> 更加灵活和强大的锁机制。具有相同的功能和内存语义。</p>
<ol>
<li>更加全面的功能，具备更强的扩展性：响应中断</li>
<li>条件Condition，细化线程的  阻塞队列，  阻塞队列—等待队列。—&gt; 唤醒更加具有针对性</li>
<li>轮询请求，尝试获取，进入队列，尝试获取，阻塞等待唤醒</li>
</ol>
<p>tips：ReentrantLock 的锁释放一定要在 <code>finally</code> 中处理。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>Executor框架--ThreadPoolExecutor</title>
    <url>/2020/07/03/java/concurrent/Executor/ThreadPoolExecutor/</url>
    <content><![CDATA[<h1 id="线池"><a href="#线池" class="headerlink" title="线池"></a>线池</h1><p>默认的线程池的核心线程不消亡</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span><span class="comment">//独占锁</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p>worker获得任务之后，上锁执行（runworker）</p>
<h2 id="线程池参数："><a href="#线程池参数：" class="headerlink" title="线程池参数："></a>线程池参数：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,//核心线程池数量</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,//最大线程池数量</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,//空闲的线程存活时间</span></span><br><span class="line"><span class="params">                          TimeUnit unit,//时间单位</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,//任务队列</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,//线程工厂，设置创建线程的工厂</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;<span class="comment">//拒绝策略</span></span><br></pre></td></tr></table></figure>

<h2 id="线程池处理流程"><a href="#线程池处理流程" class="headerlink" title="线程池处理流程"></a>线程池处理流程</h2><ol>
<li><p>运行的线程数量是否少于核心线程池的数量，</p>
<ol>
<li>小于：新建Worker，运行任务</li>
<li>大于：入队列<ol>
<li>队列未满：入队列</li>
<li>队列已满： 线程是否小于 max <ol>
<li>小于：新建Worker，运行任务</li>
<li>大于：拒绝策略</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>执行Execute方法，addWorker，worker类的介绍，AQS原因，shutdown和shutdownNow，获取锁中断和强制中断。</p>
</li>
</ol>
<p>Worker类，thread字段，执行task。，work.thread.run，</p>
<p>worker 实现了runner接口，newThread的时候，把worker作为Runnable传入（属性字段，线程 -的runable为其所属的内容）。worker的run方法，调用外部的runWorker，执行worker的task.run（），task为runable（从传入，或队列中获取）</p>
<h3 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h3><p>execute：无返回值的任务	</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor：</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123; <span class="comment">//运行的线程数量少于核心线程池的数量</span></span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))   <span class="comment">//启动新线程</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//运行线程数量多于核心线程池数量，入队列</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;   <span class="comment">//线程的的状态：RUNNING并且入队列成功，队列未满</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get(); <span class="comment">// 再次检查线程的运行状态，</span></span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))    <span class="comment">//检查线程池状态，不在运行，直接从队列中移除</span></span><br><span class="line">                reject(command);<span class="comment">//拒绝E策略</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)   <span class="comment">//防止了非运行状态下没有活动线程了，但是队列里还有任务没执行这种特殊情况。</span></span><br><span class="line">                addWorker(<span class="literal">null</span>, <span class="literal">false</span>);     <span class="comment">// 添加一个null任务是因为SHUTDOWN状态下，线程池不再接受新任务</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))    <span class="comment">//入队列，最大线程数量</span></span><br><span class="line">            reject(command);<span class="comment">//失败，拒绝策略--线程池数量已经增加到max值了</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h3><p>addWorker：新建worker</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);<span class="comment">//新建worker。wprker构造函数，创建新线程</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                    workers.add(w);<span class="comment">//把创建的Worker线程加入workers队列中，BlockingQueue&lt;Runnable&gt; workQueue;</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();<span class="comment">//运行线程，调用线程的run函数-------------</span></span><br><span class="line">                workerStarted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span><span class="comment">//独占锁</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">        Worker(Runnable firstTask) &#123;</span><br><span class="line">            setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">            <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">            <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);<span class="comment">//当前worker为线程的runnable实现类</span></span><br><span class="line">        &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            runWorker(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="runWorker方法"><a href="#runWorker方法" class="headerlink" title="runWorker方法"></a>runWorker方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    w.firstTask = <span class="literal">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            w.lock();<span class="comment">//上锁执行任务</span></span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();<span class="comment">//运行任务（Runnable）的run方法</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="literal">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="拒绝策略："><a href="#拒绝策略：" class="headerlink" title="拒绝策略："></a>拒绝策略：</h2><h3 id="CallerRunsPolicy：该线程执行-run"><a href="#CallerRunsPolicy：该线程执行-run" class="headerlink" title="CallerRunsPolicy：该线程执行 run()"></a>CallerRunsPolicy：该线程执行 run()</h3><p>使用调用executor.execute()方法的线程，执行任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">CallerRunsPolicy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">               r.run();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="AbortPolicy：抛出异常"><a href="#AbortPolicy：抛出异常" class="headerlink" title="AbortPolicy：抛出异常"></a>AbortPolicy：抛出异常</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AbortPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbortPolicy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(<span class="string">&quot;Task &quot;</span> + r.toString() +</span><br><span class="line">                                             <span class="string">&quot; rejected from &quot;</span> +</span><br><span class="line">                                             e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DiscardPolicy：空方法"><a href="#DiscardPolicy：空方法" class="headerlink" title="DiscardPolicy：空方法"></a>DiscardPolicy：空方法</h3><p>空方法：抛弃当前任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DiscardPolicy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DiscardOldestPolicy：抛弃队列首任务"><a href="#DiscardOldestPolicy：抛弃队列首任务" class="headerlink" title="DiscardOldestPolicy：抛弃队列首任务"></a>DiscardOldestPolicy：抛弃队列首任务</h3><p>抛弃最早的任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DiscardOldestPolicy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            e.getQueue().poll();</span><br><span class="line">            e.execute(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Executors的工厂方法："><a href="#Executors的工厂方法：" class="headerlink" title="Executors的工厂方法："></a>Executors的工厂方法：</h2><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><ul>
<li>FixedThreadPool：核心和最大线程池一致，linked的默认队列最长Integer.MAX_VALUE</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                     <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>SingleThreadExecutor：核心和最大都为1，linked默认队列最长Integer.MAX_VALUE</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>CachedThreadPool：核心为0，最大Integer.MAX_VALUE，阻塞队列为SynchronousQueue，不存储元素，每一个put必须等待take完，put才结束，期间不能添加新的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                     <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ScheduledThreadPool："><a href="#ScheduledThreadPool：" class="headerlink" title="ScheduledThreadPool："></a>ScheduledThreadPool：</h3><p>最大Integer.MAX_VALUE，DelayedWorkQueue，延时队列，无界</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title class_">ThreadPoolExecutor</span> <span class="keyword">implements</span> <span class="title class_">ScheduledExecutorService</span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>linux学习遇到的问题</title>
    <url>/2020/06/18/linux/linuxDaily/</url>
    <content><![CDATA[<h1 id="日常学习遇到的问题"><a href="#日常学习遇到的问题" class="headerlink" title="日常学习遇到的问题"></a>日常学习遇到的问题</h1><span id="more"></span>

<h2 id="1-网络连接设置"><a href="#1-网络连接设置" class="headerlink" title="1. 网络连接设置"></a>1. 网络连接设置</h2><p>question: ifconfig 查看网卡信息，只有lo</p>
<p>ans：关闭网络服务后重启</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一步，先把网络停掉</span><br><span class="line">sudo service network-manager stop</span><br><span class="line"></span><br><span class="line">第二步，清理对应的网络状态文件</span><br><span class="line">sudo rm /var/lib/NetworkManager/NetworkManager.state</span><br><span class="line"></span><br><span class="line">第三步，启动网络即可</span><br><span class="line">sudo service network-manager start</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/zhangjingyangguang/article/details/7932246">原文博文连接</a></p>
<h2 id="2-分辨率设置"><a href="#2-分辨率设置" class="headerlink" title="2. 分辨率设置"></a>2. 分辨率设置</h2><p>q：xrandr，没有想要的分辨率</p>
<ol>
<li>新建想要的分辨率</li>
</ol>
<p>输入：cvt 1920 1080</p>
<p>显示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1920x1080 59.96 Hz (CVT 2.07M9) hsync: 67.16 kHz; pclk: 173.00 MHz</span><br><span class="line">Modeline &quot;1920x1080_60.00&quot;  173.00  1920 2048 2248 2576  1080 1083 1088 1120 -hsync +vsync</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xrandr --newmode &quot;1920x1080_60.00&quot; 173.00 1920 2048 2248 2576 1080 1083 1088 1120 -hsync +vsync</span><br><span class="line">xrandr --addmode VGA1 &quot;1920x1080_60.00&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启用修改后的设置：source &#x2F;etc&#x2F;profile</p>
</li>
</ol>
<p>若是无法开启启动，选择 <code>系统设置</code>，找到 <code>display</code>，修改分辨率</p>
<p><a href="https://blog.csdn.net/killerstranger/article/details/80559914">参考博文连接</a></p>
<h2 id="发送文件到远程主机"><a href="#发送文件到远程主机" class="headerlink" title="发送文件到远程主机"></a>发送文件到远程主机</h2><ol>
<li><p>scp：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp /home/space/music/1.mp3 root@www.runoob.com:/home/root/others/music </span><br></pre></td></tr></table></figure>
</li>
<li><p>ftp：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart vsftpd</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-远程登陆主机："><a href="#3-远程登陆主机：" class="headerlink" title="3. 远程登陆主机："></a>3. 远程登陆主机：</h2><ol>
<li>ssh -v root@ip</li>
</ol>
<p>移动文件夹：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv [-fiv] source destination</span><br></pre></td></tr></table></figure>

<p>https:???</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssl_certificate cert/fkyang.pem;   </span><br><span class="line">ssl_certificate_key cert/fkyang.key;  </span><br><span class="line">ssl_session_timeout 5m;</span><br><span class="line">ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;  #使用此加密套件。</span><br><span class="line">ssl_protocols TLSv1 TLSv1.1 TLSv1.2;   #使用该协议进行配置。</span><br><span class="line">ssl_prefer_server_ciphers on;   </span><br></pre></td></tr></table></figure>





<h2 id="4-环境变量配置"><a href="#4-环境变量配置" class="headerlink" title="4. 环境变量配置"></a>4. 环境变量配置</h2><ul>
<li>&#x2F;etc&#x2F;bash.bashrc 或 ~&#x2F;.bashrc，开启shell读取</li>
<li>&#x2F;etc&#x2F;profile 和 ~&#x2F;.profile ，login读取</li>
</ul>
<p><a href="https://blog.csdn.net/cdnight/article/details/86653006">https://blog.csdn.net/cdnight/article/details/86653006</a></p>
<p>如果是在&#x2F;etc&#x2F;bash.bashrc 和 ~&#x2F;.bashrc文件中添加配置信息，那么打开一个新的shell，就生效了，可以用了（因为打开新的shell会读取这个两个文件）。也可以输入$source &#x2F;etc&#x2F;bash.bashrc或者$.&#x2F;etc&#x2F;bash.bashrc命令（ .和&#x2F;之间还有一个空格）来使得在本shell中，也可以生效使用。     如果是在&#x2F;etc&#x2F;profile 和 ~&#x2F;.profile 文件中添加配置信息。那么就只能重启了。因为这个两个文件只会在login 下才会读取。当然，也是可以使用$source &#x2F;etc&#x2F;profile 命令的。但也只能在使用过这个命令的shell才能使用。</p>
<h2 id="5-进程相关"><a href="#5-进程相关" class="headerlink" title="5. 进程相关"></a>5. 进程相关</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先根据进程名查看进程id</span><br><span class="line">ps aux | grep 进程名(或者ps -ef | grep 进程名)</span><br><span class="line"></span><br><span class="line">通过进程id查看占用的端口</span><br><span class="line">netstat -nap | grep 进程id</span><br><span class="line"></span><br><span class="line">通过端口号查看占用的进程id</span><br><span class="line">netstat -nap | grep 端口号</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>linux软件安装</title>
    <url>/2020/06/18/linux/linuxSoftWare/</url>
    <content><![CDATA[<p><a href="http://download.redis.io/releases/redis-6.0.5.tar.gz">http://download.redis.io/releases/redis-6.0.5.tar.gz</a></p>
<h2 id="1-Redis设置"><a href="#1-Redis设置" class="headerlink" title="1. Redis设置"></a>1. Redis设置</h2><ol>
<li><p>下载 <code>wget http://download.redis.io/releases/redis-6.0.5.tar.gz</code></p>
</li>
<li><p>解压 <code>tar -zxvf redis****</code></p>
</li>
<li><p>安装 <code>make PREFIX=/usr/local/redis install</code></p>
</li>
<li><p>拷贝配置文件，<code>cp redis.conf  /usr/local/redis/bin</code></p>
</li>
<li><p>start</p>
<ol>
<li><pre><code class="undefined">./redis-server 
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 通过配置文件 `./bin/redis-server /path/to/redis.conf `</span><br><span class="line"></span><br><span class="line">   1. 配置配置文件：</span><br><span class="line"></span><br><span class="line">   2. ```</span><br><span class="line">      bind 0.0.0.0</span><br><span class="line">      requirepass *** //设置密码</span><br><span class="line">      port 6379</span><br><span class="line">      daemonize yes</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>访问：<code> ./redis-cli -h 127.0.0.1 -p 6379 -a password</code></p>
</li>
<li><p>查看进程：<code>ps -ef | grep redis</code></p>
</li>
</ol>
</li>
<li><p>关闭</p>
<ol>
<li><p>发送关闭指令</p>
<ol>
<li><pre><code>cd /usr/local/redis
./bin/redis-cli shutdown
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 强行终止 `pkill redis-server`</span><br><span class="line"></span><br><span class="line">```undefined</span><br><span class="line">pkill redis-server</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="2-mysql"><a href="#2-mysql" class="headerlink" title="2. mysql"></a>2. mysql</h2><ol>
<li><p><a href="https://downloads.mysql.com/archives/community/">官网</a></p>
</li>
<li><pre><code>sudo apt update
sudo apt install mysql-server
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. ```</span><br><span class="line">   sudo systemctl status mysql</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>安全设置</p>
<ol>
<li><pre><code>sudo mysql_secure_installation #按提示设置即可
$ sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf #找到 bind-address 修改值为 0.0.0.0(如果需要远程访问)
$ sudo /etc/init.d/mysql restart #重启mysql
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">5. 远程访问：</span><br><span class="line"></span><br><span class="line">   1. ```</span><br><span class="line">      mysql&gt;  UPDATE mysql.user SET host = &#x27;%&#x27; WHERE user = &#x27;root&#x27;; #允许远程访问</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code>mysql&gt; CREATE USER &#39;sammy&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;password&#39;;
mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#39;sammy&#39;@&#39;%&#39; WITH GRANT OPTION;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* sudo mysql_secure_installation</span><br><span class="line"></span><br><span class="line">  * ```</span><br><span class="line">    Press y|Y for Yes, any other key for No: *y*</span><br><span class="line">    Please enter 0 = LOW, 1 = MEDIUM and 2 = STRONG:  *0*</span><br><span class="line">    Do you wish to continue with the password provided?(Press y|Y for Yes, any other key for No) : y</span><br><span class="line">    </span><br><span class="line">    Remove anonymous users? (Press y|Y for Yes, any other key for No) : y</span><br><span class="line">    Success.</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
<ul>
<li>修改等级 <code>set global validate_password_policy=0;</code></li>
</ul>
<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>mysql -u root -p</p>
<h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><ul>
<li>systemctl start mysql</li>
<li>&#x2F;etc&#x2F;init.d&#x2F;mysql  start</li>
</ul>
<h3 id="root-user"><a href="#root-user" class="headerlink" title="root&#x2F;user"></a>root&#x2F;user</h3><p>用户修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select host,User,authentication_string from user; </span><br><span class="line">UPDATE mysql.user SET host = &#x27;%&#x27; WHERE user = &#x27;root&#x27;;</span><br><span class="line"> ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;yfk123456&#x27;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>STL</title>
    <url>/2020/05/13/java/STL/%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><span id="more"></span>

<ul>
<li>数组：<ul>
<li>连续空间，随机访问，下标查找。</li>
<li>扩容：重新分配空间，全部复制 O(N)</li>
<li>插入删除：移动元素，保持连续  O(N)</li>
</ul>
</li>
<li>链表<ul>
<li>不连续空间，顺序访问  </li>
<li>额外的空间存储指针</li>
<li>插入删除：修改前后节点指针，O(1)</li>
</ul>
</li>
</ul>
<p>操作：遍历+访问</p>
<ul>
<li><p>增删改查</p>
</li>
<li><p>遍历：</p>
<ul>
<li><p>线性：for，while</p>
<ul>
<li><pre><code>数组：
for(int i = 0 ; i &lt; n ; i++ )&#123;&#125;

链表：
for(ListNode i = head ; i ！= null ; i = i.next )&#123;&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 非线性：递归</span><br><span class="line"></span><br><span class="line">  * ```</span><br><span class="line">    tree</span><br><span class="line">    	search(TreeNode root)&#123;</span><br><span class="line">    		for( TreeNode child : root.children)</span><br><span class="line">    			search(child);</span><br><span class="line">    	&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>tree</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void traverse( TreeNode root)&#123;</span><br><span class="line">	//前序</span><br><span class="line">	 traverse(root.left);</span><br><span class="line">	 //中序</span><br><span class="line">	  traverse(root.right);</span><br><span class="line">	  //后序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1-常见数据类型"><a href="#1-常见数据类型" class="headerlink" title="1. 常见数据类型"></a>1. 常见数据类型</h1><h2 id="1-1-String"><a href="#1-1-String" class="headerlink" title="1.1 String"></a>1.1 String</h2><p><code>private final byte[] value</code> 存储数据</p>
<p>1.11 AbstractStringBuilder</p>
<p><code>byte[] value;</code>存储</p>
<p>不够，数组扩大 <code>Arrays.copyOf</code></p>
<p>两个实现类：</p>
<ul>
<li>aStringBuilder：线程不安全</li>
<li>StringBuffer：线程安全，方法加锁 synchronized锁</li>
</ul>
<ul>
<li><strong>List(顺序,可重复)：</strong> List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</li>
<li><strong>Set(独一无二的):</strong> 不允许重复的集合。不会有多个元素引用相同的对象。</li>
<li><strong>Map(Key（不重复）-value):</strong> 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</li>
</ul>
<h1 id="1-List"><a href="#1-List" class="headerlink" title="1. List"></a>1. List</h1><p> <strong>list 的遍历方式选择：</strong></p>
<ul>
<li>实现了 <code>RandomAccess</code> 接口的list，优先选择普通 for 循环 ，其次 foreach,</li>
<li>未实现 <code>RandomAccess</code>接口的list，优先选择iterator遍历（foreach遍历底层也是通过iterator实现的），大size的数据，千万不要使用普通for循环</li>
</ul>
<h2 id="1-1-Arrsylist"><a href="#1-1-Arrsylist" class="headerlink" title="1.1 Arrsylist"></a>1.1 Arrsylist</h2><ul>
<li>clone：浅拷贝</li>
<li>grow：增长，min：，prefer：1.5（扩大原数组右移一位的数量）</li>
</ul>
<h4 id="System-arraycopy-和Arrays-copyOf-方法"><a href="#System-arraycopy-和Arrays-copyOf-方法" class="headerlink" title="System.arraycopy()和Arrays.copyOf()方法"></a>System.arraycopy()和Arrays.copyOf()方法</h4><ol>
<li><p>arraycopy()方法实现数组自己复制自己，arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置</p>
<ol>
<li><pre><code class="java">public static native void arraycopy(Object src,  int  srcPos,
                                    Object dest, int destPos,
                                    int length);
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. copyOf：</span><br><span class="line"></span><br><span class="line">   1. ```java</span><br><span class="line">      public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) </span><br><span class="line">              public static &lt;T&gt; T[] copyOf(T[] original, int newLength) </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
<li></li>
<li><p>copyOf()是系统自动在内部新建一个数组，并返回该数组</p>
</li>
<li><p>java 中的<strong>length 属性</strong>是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</p>
</li>
<li><p>java 中的<strong>length()方法</strong>是针对字 符串String说的,如果想看这个字符串的长度则用到 length()这个方法.</p>
</li>
<li><p>.java 中的<strong>size()方法</strong>是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</p>
</li>
</ol>
<h2 id="Arrays-asList-T…"><a href="#Arrays-asList-T…" class="headerlink" title="Arrays.asList(T…)"></a>Arrays.asList(T…)</h2><p>asList()方法传入的参数不能是基本类型的数组，必须包装成包装类型再使用，否则对应生成的列表的大小永远是1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">lists1</span> <span class="operator">=</span> Arrays.asList(arr1);<span class="comment">// List&lt;Integer&gt; lists2 = Arrays.asList(arr2);</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>接受的参数是对象</p>
<p>把基本数据类型的数组，当成了一个数组对象</p>
</blockquote>
<p>hashmap：长度2的幂次方</p>
<p>数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（n代表数组长度）。这也就解释了 HashMap 的长度为什么是2的幂次方。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构--B+树</title>
    <url>/2020/05/10/dataStructure/B+%E6%A0%91/</url>
    <content><![CDATA[<p>B+树</p>
<span id="more"></span>

<p>B+树：多级索引。</p>
<p>每个节点：最多包含n-1个搜索码值，和n个指针</p>
<table>
<thead>
<tr>
<th>P1</th>
<th>K1</th>
<th>P2</th>
<th>K2</th>
<th>….</th>
<th>Pn-1</th>
<th>Kn-1</th>
<th>Pn</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>对于i&#x3D;1，2…，n-1,指针pi指向具有搜索码值Ki的一条文件记录，Pn有特殊的作用。</p>
<p>叶子节点包含的值的个数：<code>[n/2] --  [n-1] </code>.  </p>
<p>B+树的非叶子节点：多级（稀疏）索引。n&#x2F;2 -  n 个指针。n&#x2F;2 -1  到 n-1个搜索码</p>
<p>根节点：可以少于n&#x2F;2个指针，除了树仅有一个节点的情况，根至少应有两个节点。</p>
<p>插入：在叶子节点插入</p>
<ul>
<li>分裂节点：节点值数量多于n-1<ul>
<li>索引更新：父节点多一个搜索码</li>
</ul>
</li>
</ul>
<p>删除：叶子删除</p>
<ul>
<li>更新索引：删除的数据是 非叶子节点索引的数据，  该索引的后继补上</li>
<li>合并节点：删除后，数量少于n&#x2F;2<ul>
<li>如果兄弟节点数量多余n&#x2F;2：从兄弟节点借<ul>
<li>索引更新：搜索码更新</li>
</ul>
</li>
<li>不多于，刚好n&#x2F;2：合并节点<ul>
<li>索引更新：内节点的搜索码删除一个</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>JDBC</title>
    <url>/2020/05/10/java/DB/JDBC/</url>
    <content><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><p>JDBC(Java Database Connectivity)： java和数据库的连接技术，Sun公司推出的套应用程序访问数据库的技术规范。<br>规范：抽象类或接口</p>
<span id="more"></span>

<p>统一的访问数据库的规范与接口，使用不同的数据库，调用不同的JDBC驱动</p>
<p>前提：导入包</p>
<ol>
<li><p>注册驱动</p>
<ol>
<li><pre><code>// 注册 JDBC 驱动
Class.forName(JDBC_DRIVER);
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 获取连接</span><br><span class="line"></span><br><span class="line">   1. ```</span><br><span class="line">      conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
<li><p>sql语句</p>
<ol>
<li><pre><code>String sql = &quot;select * from jobs&quot;;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 查找</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">String sql = &quot;select * from jobs&quot;;</span><br><span class="line">Statement statement = conn.createStatement();</span><br><span class="line">ResultSet set = statement.executeQuery(sql);//查询的结果集</span><br><span class="line">ResultSetMetaData metaData = set.getMetaData();//列属性</span><br><span class="line">while(set.next())&#123;//迭代器类似的模式</span><br><span class="line">    for( int i = 1 ; i &lt;= metaData.getColumnCount() ;i++)&#123;</span><br><span class="line">        System.out.print(metaData.getColumnName(i)+&quot;---&quot;+set.getObject(i)+&quot;  &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//set.toString();</span><br><span class="line">System.out.println(set.toString());</span><br><span class="line">statement.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.执行查询//3-1编写sq1</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span><span class="string">&quot;SELECT COUNT（）FROM admin WHERE username =? AND PASSWORD=？&quot;</span>；</span><br><span class="line"><span class="comment">//3-1获取 Preparedstatement命令对象</span></span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.prepareStatement （sql）；</span><br><span class="line"><span class="comment">//3-2设置占位符的值</span></span><br><span class="line">    statement.setstring（<span class="number">1</span>， username）；</span><br><span class="line">    statement.setstring（<span class="number">2</span>， pwd）；</span><br><span class="line"><span class="comment">//3-3执行Sq1命令</span></span><br><span class="line">    <span class="type">Resultset</span> <span class="variable">set</span> <span class="operator">=</span> statement.executeQuery()；</span><br></pre></td></tr></table></figure>

<p> PreparedStatement：不使用+拼接，模板与参数分离，解决SQL注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.yfk.study.jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类描述</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yfk</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcLink</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// MySQL 8.0 以上版本 - JDBC 驱动名及数据库 URL</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JDBC_DRIVER</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DB_URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/mytest?useSSL=false&amp;serverTimezone=UTC&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据库的用户名与密码，需要根据自己的设置</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASS</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">// 注册 JDBC 驱动</span></span><br><span class="line">                Class.forName(JDBC_DRIVER);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 打开链接</span></span><br><span class="line">                System.out.println(<span class="string">&quot;连接数据库...&quot;</span>);</span><br><span class="line">                conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(conn != <span class="literal">null</span>)</span><br><span class="line">                    System.out.println(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">                <span class="comment">// 处理 JDBC 错误</span></span><br><span class="line">                se.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                <span class="comment">// 处理 Class.forName 错误</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                <span class="comment">// 关闭资源</span></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(stmt!=<span class="literal">null</span>) stmt.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(SQLException se2)&#123;</span><br><span class="line">                &#125;<span class="comment">// 什么都不做</span></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(conn!=<span class="literal">null</span>) conn.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">                    se.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Goodbye!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sql：API</p>
<ul>
<li><p>DriverManager驱动管理类</p>
</li>
<li><p>Connection连接对象接口</p>
<ul>
<li>createStatement ：生成命令对象</li>
<li>prepareStatement（sql）：生成预编译命令对象</li>
</ul>
</li>
<li><p>Statement命令对象接口</p>
<ul>
<li>executeUpdate（sq〕执行增删改语句，返回受影响的行数<ul>
<li>DML:insert,update,delete</li>
<li>DDL:creat,alter,drop</li>
</ul>
</li>
<li></li>
<li>executeQuery（sq：执行查询语句，返回结果集</li>
<li>execute（sq）：执行任意sq语句，返回 boolean</li>
</ul>
</li>
<li><p>PreparedStatement预编译命令对象接口</p>
<ul>
<li><blockquote>
<p>占位符 ？ 只能设置参数，不能设置 表，列名，</p>
<p>为占位符 ? 的两边自动加上引号 ’  ，导致表&#x2F;列名失败</p>
</blockquote>
</li>
</ul>
</li>
<li><p>executeUpdate0：执行增删改语句，返回受影响的行数</p>
<ul>
<li>executeQuery（）：执行查询语句，返回结果集</li>
<li>execute（：执行任意sq语句，返回 boolean</li>
<li>seXX（占位符索引，占位符的值）：设置对应索引的占位符的值，类型为X类型</li>
<li>setobject（占位符索引，占位符的值）：设置对应索引的占位符的值，类型为 Object类型</li>
</ul>
</li>
<li><p>Resultset结果集对象接口</p>
<ul>
<li><p>next（0：下移一行，返回当前行是否有值</p>
</li>
<li><p>previous（）：上移一行，返回当前行是否有值</p>
</li>
<li><p>getXX（参数）返回对应列的值，接收类型为XX </p>
<ul>
<li>xx：数据类型<ul>
<li>int，Object等</li>
</ul>
</li>
<li>参数：<ul>
<li>int：列编号，从1开始</li>
<li>String：列名</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
  </entry>
  <entry>
    <title>并发容器框架</title>
    <url>/2020/05/03/java/concurrent/Executor%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="Java并发容器和框架"><a href="#Java并发容器和框架" class="headerlink" title="Java并发容器和框架"></a>Java并发容器和框架</h1><span id="more"></span>

<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>可变操作（add，set) :  lock  + 数组副本</p>
<blockquote>
<p>创建底层数组的新副本来实现的。当 List 需要被修改的时候，我并不修改原有内容，而是对原有数据进行一次复制，将修改的内容写入副本。</p>
</blockquote>
<h2 id="concurrentHashMap"><a href="#concurrentHashMap" class="headerlink" title="concurrentHashMap"></a>concurrentHashMap</h2><p>数组类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>

<h3 id="put方法："><a href="#put方法：" class="headerlink" title="put方法："></a>put方法：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line">    <span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());  <span class="comment">//rehash</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//是否存在hash冲突的标识</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh; K fk; V fv;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)					<span class="comment">// 1. 数组未被初始化</span></span><br><span class="line">                tab = initTable();      <span class="comment">//初始化数组</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;	<span class="comment">//2. 当前位置没有节点，CAS加入</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value)))<span class="comment">//casTabAt：CAS加入</span></span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)    					<span class="comment">//3.容器是否被其他线程扩容</span></span><br><span class="line">                tab = helpTransfer(tab, f);     </span><br><span class="line">            <span class="comment">//---那么该线程也去帮扩容，不加入容器，保证扩容时，不会往里添加数据</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (onlyIfAbsent <span class="comment">// check first node without acquiring lock</span></span><br><span class="line">                     &amp;&amp; fh == hash</span><br><span class="line">                     &amp;&amp; ((fk = f.key) == key || (fk != <span class="literal">null</span> &amp;&amp; key.equals(fk)))</span><br><span class="line">                     &amp;&amp; (fv = f.val) != <span class="literal">null</span>)				<span class="comment">//4. 当前数组有节点，是否首节点</span></span><br><span class="line">                <span class="keyword">return</span> fv;</span><br><span class="line">            <span class="keyword">else</span> &#123;							</span><br><span class="line">                <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;  		<span class="comment">//5.当前位置有数值，且不是首节点，把首节点对象当初锁</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;	<span class="comment">// 表示该节点是链表</span></span><br><span class="line">                            binCount = <span class="number">1</span>;<span class="comment">//存在hash冲突的标识</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;<span class="comment">//覆盖原来的value</span></span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;<span class="comment">//插入尾部</span></span><br><span class="line">                                    pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;<span class="comment">//红黑树节点</span></span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ReservationNode)</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Recursive update&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)<span class="comment">//是否阈值，链表转红黑树</span></span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);<span class="comment">//更新size，同时判断是否需要扩容</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>检查数组是否已经被初始化了</li>
<li>当前位置没有节点，CAS加入</li>
<li>有节点，看是否其他线程在扩容，若扩容，帮助扩容</li>
<li>看首节点是否目标节点</li>
<li>存在hash冲突，锁首节点，保证同一时刻只有一个线程修改链表</li>
<li>addCount(1L, binCount) 操作，该操作会更新 size 大小，判断是否需要扩容，</li>
</ol>
<h4 id="initTable函数："><a href="#initTable函数：" class="headerlink" title="initTable函数："></a>initTable函数：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.<span class="keyword">yield</span>(); <span class="comment">// lost initialization race; just spin,有其他进程在初始化,</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;<span class="comment">//CAS设置状态-1，表明当前进程在初始化</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get方法：没有显式的锁</p>
<h3 id="transfer-方法："><a href="#transfer-方法：" class="headerlink" title="transfer 方法："></a>transfer 方法：</h3><p>put- addCount-transfer</p>
<p> tryPresize-transfer</p>
<ul>
<li>链表元素阈值8，转红黑树之前，若数组容量少于阈值MIN_TREEIFY_CAPACITY，调用tryPresize</li>
<li>putAll 操作时会先触发 tryPresize 操作。</li>
</ul>
<p>线程安全的队列	</p>
<ol>
<li>阻塞算法：锁实现</li>
<li>非阻塞算法：循环CAS</li>
</ol>
<h2 id="ConcurrentLinkedQueue-CAS"><a href="#ConcurrentLinkedQueue-CAS" class="headerlink" title="ConcurrentLinkedQueue   CAS"></a>ConcurrentLinkedQueue   CAS</h2><h3 id="非阻塞算法：循环CAS"><a href="#非阻塞算法：循环CAS" class="headerlink" title="非阻塞算法：循环CAS"></a>非阻塞算法：循环CAS</h3><h4 id="入队列-CAS"><a href="#入队列-CAS" class="headerlink" title="入队列:CAS"></a>入队列:CAS</h4><p>没有让tail永远作为为尾节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(Objects.requireNonNull(e));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        Node&lt;E&gt; q = p.next;<span class="comment">//尾节点的下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (q == <span class="literal">null</span>) &#123;								<span class="comment">//1.</span></span><br><span class="line">            <span class="keyword">if</span> (NEXT.compareAndSet(p, <span class="literal">null</span>, newNode)) &#123;		<span class="comment">//1.1</span></span><br><span class="line">                <span class="keyword">if</span> (p != t) <span class="comment">// 两个线程						//1.1.1</span></span><br><span class="line">                    TAIL.weakCompareAndSet(<span class="built_in">this</span>, t, newNode);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//入队列成功</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Lost CAS race to another thread; re-read next</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)<span class="comment">//头节点					//2</span></span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//每两跳更新一次尾节点,提高效率			//3</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">        <span class="comment">//先p != t，false，</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/java/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%A1%86%E6%9E%B6/ConcurrentLinkedQueue%E7%9A%84%E5%B9%B6%E5%8F%91%E5%85%A5%E9%98%9F%E5%88%97%E8%BF%87%E7%A8%8B.png" alt="ConcurrentLinkedQueue的并发入队列过程" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">resulr</span> <span class="operator">=</span> (t != (t = tail)) ? t : <span class="number">0</span>;</span><br><span class="line">局部变量表位置		t（<span class="number">1</span>）		tail（<span class="number">2</span>）		操作数栈</span><br><span class="line">t:<span class="number">1</span>	tail:<span class="number">2</span>			<span class="number">5</span>			<span class="number">8</span>			<span class="literal">null</span></span><br><span class="line">iload_1										t=<span class="number">5</span></span><br><span class="line">iload_2										t=<span class="number">5</span>,tail=<span class="number">8</span></span><br><span class="line">dup														复制tail=<span class="number">8</span></span><br><span class="line">istore_1			<span class="number">8</span></span><br><span class="line"><span class="comment">//此时还有 ！= 没有计算</span></span><br><span class="line"><span class="number">9</span> if_icmpeq <span class="number">16</span> (+<span class="number">7</span>)  						<span class="number">5</span>，<span class="number">8</span>不相等，比较失败，进入 iload_1,操作数栈清空。</span><br><span class="line">    <span class="comment">//stack operation  value1, value2 ，5 8</span></span><br><span class="line">    <span class="comment">//if_icmpeq succeeds if and only if value1 = value2</span></span><br><span class="line"><span class="number">12</span> <span class="type">iload_1</span>								<span class="variable">t</span> <span class="operator">=</span> <span class="number">8</span></span><br><span class="line"><span class="number">13</span> goto <span class="number">17</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">16</span> iconst_0</span><br><span class="line"><span class="number">17</span> istore_3								为resulr赋值</span><br></pre></td></tr></table></figure>

<h4 id="出队列"><a href="#出队列" class="headerlink" title="出队列"></a>出队列</h4><p>head有元素，直接弹出，不更新，</p>
<p>删除的元素不是头节点的时候，才会更新head节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    restartFromHead: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;; p = q) &#123;</span><br><span class="line">            <span class="keyword">final</span> E item;</span><br><span class="line">            <span class="keyword">if</span> ((item = p.item) != <span class="literal">null</span> &amp;&amp; p.casItem(item, <span class="literal">null</span>)) &#123;<span class="comment">//head有元素，清空，并返回，不更新head</span></span><br><span class="line">                <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                <span class="comment">// for item to be removed from this queue.</span></span><br><span class="line">                <span class="keyword">if</span> (p != h) <span class="comment">// hop two nodes at a time		//更新头，删除的节点不是头节点</span></span><br><span class="line">                    updateHead(h, ((q = p.next) != <span class="literal">null</span>) ? q : p);	</span><br><span class="line">                		<span class="comment">//若仅剩一个，head为删除的节点，否则，head为删除节点的下一个</span></span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="literal">null</span>) &#123; <span class="comment">//看head.next是否有指向</span></span><br><span class="line">                <span class="comment">//q = p.next为循环的p=q，设置下一个查询到节点      </span></span><br><span class="line">                updateHead(h, p);       <span class="comment">//，无元素，更新头为上一次删除的节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;        <span class="comment">//没有元素</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)    </span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>阻塞队列：BlockingQueue：</p>
<ul>
<li>支持阻塞的插入方法：当队列满时，队列会<strong>阻塞插入元素的线程</strong>，直至队列不满</li>
<li>支持阻塞的移除方法：在队列为空时，获取元素的现场会等待队列变为非空</li>
</ul>
<table>
<thead>
<tr>
<th>方法&#x2F;处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,offer)</td>
</tr>
<tr>
<td>移除</td>
<td>remove(e)</td>
<td>poll()</td>
<td>take</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查</td>
<td>element(e)</td>
<td>peek(e)</td>
<td>null</td>
<td>null</td>
</tr>
</tbody></table>
<ul>
<li>抛出异常：<ul>
<li>队列满时，插入抛出java.lang.IllegalStateException: Queue full</li>
<li>队列空时，从队列获取元素，java.util.NoSuchElementException</li>
</ul>
</li>
<li>返回特殊值：<ul>
<li>插入：无论成功与否，都会返回true</li>
<li>移除：成功：从队列取出一个元素；失败：返回null</li>
</ul>
</li>
<li>一直阻塞：<ul>
<li>put：若队列满，队列会一直阻塞线程，直到队列不满&#x2F;响应中断退出</li>
<li>take：队列空时，队列阻塞线程，直到队列不空</li>
</ul>
</li>
<li>超时退出：阻塞超过一定时间，退出</li>
</ul>
<h3 id="java的阻塞队列"><a href="#java的阻塞队列" class="headerlink" title="java的阻塞队列"></a>java的阻塞队列</h3><h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue:"></a>ArrayBlockingQueue:</h4><p><strong>数组</strong>结构构成的<strong>有界</strong>阻塞队列，FIFO，初始化规定数组大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">        notEmpty = lock.newCondition();</span><br><span class="line">        notFull =  lock.newCondition();</span><br><span class="line">消息通知机制实现，put：没有，condition的await方法（locksupport的park方法）</span><br><span class="line">    数组，循环使用，<span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">            putIndex = <span class="number">0</span>;通过count数值，看是否满</span><br></pre></td></tr></table></figure>

<h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p><strong>链表</strong>实现的<strong>有界</strong>阻塞队列，<strong>默认的最大长度</strong>  Integer.MAX_VALUE。FIFO</p>
<h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p>支持<strong>优先级</strong>的<strong>无界</strong>阻塞队列，默认自然升序。</p>
<ul>
<li>可以自定义CompareTo（）方法：指定元素排序规则</li>
<li>构造函数：指定Comparator来对元素进行排序</li>
</ul>
<h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p><strong>延时获取</strong>元素的<strong>无界</strong>阻塞队列。队列的元素需要实现Delay接口</p>
<p>构造函数的时候，指定多久后才能从队列获取当前元素。</p>
<h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p><strong>不存储元素</strong>的队列，每一个<strong>put必须等待一个take</strong>操作。</p>
<p>适合于传递性场景</p>
<h4 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h4><p>由<strong>链表</strong>组成的<strong>无界</strong>阻塞TransferQueue队列，多了transfer，tryTransfer方法</p>
<p>SynchronousQueue的可存储容量版本。</p>
<ul>
<li>transfer：等待tranfer的元素被取回才返回。<ul>
<li>如果当前有线程使用了take方法取元素，transfer方法直接把元素给这个进程，不入队列</li>
<li>没有线程take取元素，tranfer会把元素放在tail位置，并<strong>等到被take</strong>才返回</li>
</ul>
</li>
<li>tryTransfer：试探传入的元素能否直接传给消费者<ul>
<li>没有消费者：返回false</li>
<li>方法不阻塞，立即返回。</li>
</ul>
</li>
</ul>
<h4 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h4><p><strong>链表</strong>组成的双向阻塞队列，<strong>默认的最大长度</strong>  Integer.MAX_VALUE</p>
<h3 id="阻塞队列的实现原理"><a href="#阻塞队列的实现原理" class="headerlink" title="阻塞队列的实现原理"></a>阻塞队列的实现原理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add利用offer的返回值来抛出异常</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (offer(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(e);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;<span class="comment">//获得锁</span></span><br><span class="line">        lock.lock();<span class="comment">//锁实现多线程的线程安全</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == items.length)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                enqueue(e);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>put：condition的await</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">        lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(fair);</span><br><span class="line">        notEmpty = lock.newCondition();</span><br><span class="line">        notFull =  lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//Inserts the specified element at the tail of this queue, waiting for space to become available if the queue is full.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Objects.requireNonNull(e);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();<span class="comment">//Condition的通知模式</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>take:condition的await</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();<span class="comment">//Condition的通知模式</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork&#x2F;Join框架"></a>Fork&#x2F;Join框架</h2><p>fork：把一个大任务切割成若干子任务并行</p>
<p>join：合并这些子任务的执行结果</p>
<h3 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h3><p>工作窃取：某个线程从其他队列窃取任务来执行。</p>
<p>大任务分成小任务，小任务放在不同的队列中，一个线程执行一个队列。</p>
<p>窃取任务：去其他的线程窃取任务，被窃取任务的线程从双端队列头拿任务执行，窃取任务的线程从双端队列的尾部拿任务来执行。</p>
<h1 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> U.getAndAddInt(<span class="built_in">this</span>, VALUE, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> delta)</span> &#123;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            v = getIntVolatile(o, offset);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta)); <span class="comment">//循环CAS</span></span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>lock</title>
    <url>/2020/05/01/java/concurrent/lockAqs/</url>
    <content><![CDATA[<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>锁：控制多个线程访问共享资源的方式</p>
<span id="more"></span>

<ul>
<li>synchronized：隐式的获取锁</li>
<li>lock接口：显示获取释放锁</li>
</ul>
<p>lock接口的实现是通过聚合了一个同步器（AQS）的子类来完成线程控制的</p>
<h2 id="AQS队列同步器"><a href="#AQS队列同步器" class="headerlink" title="AQS队列同步器"></a>AQS队列同步器</h2><p>AQS(AbstractOwnableSynchronizer)：队列同步器，抽象类，用来构建锁和同步器的框架</p>
<p>定义了若干同步状态的获取和释放的方法来供自定义同步组件使用</p>
<p>使用一个volatile的int成员变量state表示同步状态，通过内置的FIFO队列完成资源获取线程的排队。</p>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/java/%E9%94%81JAVAAQS%E7%B1%BB%E5%9B%BE.png" alt="JAVAAQS类图"></p>
<p>模板方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="type">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="type">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="type">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="type">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>访问和修改同步状态：</p>
<ul>
<li>getstate()</li>
<li>setState( int newState)</li>
<li>compareAndSetState(int expect, int update)</li>
</ul>
<h3 id="同步队列：一个FIFO是双向队列来完成同步状态的管理"><a href="#同步队列：一个FIFO是双向队列来完成同步状态的管理" class="headerlink" title="同步队列：一个FIFO是双向队列来完成同步状态的管理"></a>同步队列：一个FIFO是双向队列来完成同步状态的管理</h3><ul>
<li>当前线程获取失败的时候，同步器把当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列尾部（循环CAS设置），同时阻塞当前线程。</li>
<li>首节点是获取同步状态成功的节点，首节点的线程释放同步状态时，会唤醒后继节点，后继节点在获取同步状态成功时，会把自己设为首节点。</li>
</ul>
</li>
</ul>
<h3 id="独占式同步队列：LockSupport-park"><a href="#独占式同步队列：LockSupport-park" class="headerlink" title="独占式同步队列：LockSupport.park"></a>独占式同步队列：LockSupport.park</h3><ul>
<li><p>阻塞：lock()—acquire(1)—-acquireQueued(addWaiter(Node.EXCLUSIVE), arg))—-interrupted |&#x3D; parkAndCheckInterrupt()—LockSupport.park(this);，阻塞在这个方法中</p>
</li>
<li><p>唤醒：unlock()—-release(1)—unparkSuccessor(h)—–LockSupport.unpark(s.thread); ：唤醒后继节点</p>
<ul>
<li><pre><code class="java">private void unparkSuccessor(Node node) &#123;
 if (s == null || s.waitStatus &gt; 0) &#123;    //若后继线程线程状态被改变
            s = null;
            for (Node p = tail; p != node &amp;&amp; p != null; p = p.prev) 
                //找到后继节点中第一个waitstatus&lt;=0的节点，
                //存在后一个节点状态被改变，不一定是后一个节点
                if (p.waitStatus &lt;= 0)
                    s = p;
        &#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 共享式</span><br><span class="line"></span><br><span class="line">同步资源数，允许共享的线程数量ReentrantReadWriteLock</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>unlock()–releaseShared（）—tryReleaseShared(arg)循环CAS修改，不唤醒</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### Semaphore:**多个线程同时访问某个资源。**</span><br><span class="line"></span><br><span class="line">CAS循环获取，内置AQS的子类，公平，非公平</span><br><span class="line"></span><br><span class="line">### 独占式超时获取：LockSupport.parkNanos</span><br><span class="line"></span><br><span class="line">doAcquireNanos ---LockSupport.parkNanos(this, nanosTimeout);，超时后，自动唤醒，尝试获取锁，仍然没有获取到，获取失败</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public void lock() &#123;</span><br><span class="line">        sync.acquire(1);//设置当前线程持有锁</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        public final void acquire(int arg) &#123;</span><br><span class="line">        if (!tryAcquire(arg) &amp;&amp;//设置</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))//</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    tryAcquire(arg):            setExclusiveOwnerThread(current);//</span><br><span class="line">    //设置当前线程持有锁</span><br><span class="line">     final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">                     for (;;) &#123;</span><br><span class="line">                final Node p = node.predecessor();</span><br><span class="line">                if (p == head &amp;&amp; tryAcquire(arg)) &#123;//首节点在运行时，失败，进入阻塞</span><br><span class="line">                    setHead(node);					//否则， 后继节点在获取同步状态成功时，会把自己设为首节点。</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    return interrupted;				//若不被中断，return false，acquire成功</span><br><span class="line">                &#125;</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node))</span><br><span class="line">                    interrupted |= parkAndCheckInterrupt();//park，阻塞，首节点在release，阻塞结束，运行，直到上面p==head</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="重入锁：看当前线程是否是获取锁的线程"><a href="#重入锁：看当前线程是否是获取锁的线程" class="headerlink" title="重入锁：看当前线程是否是获取锁的线程"></a>重入锁：看当前线程是否是获取锁的线程</h2><ul>
<li><p>公平锁：效率略低，减少饥饿的发生，</p>
<ul>
<li><pre><code class="java"> if (c == 0) &#123; 
if (!hasQueuedPredecessors() &amp;&amp;//公平锁。若同步队列有元素，则不尝试获取锁
                    compareAndSetState(0, acquires))
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 非公平锁：</span><br><span class="line"></span><br><span class="line">  * ```java</span><br><span class="line">     if (c == 0) &#123;    </span><br><span class="line">    if (compareAndSetState(0, acquires))</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>公平与否：看看c&#x3D;&#x3D;0，获得锁的时候，有没有检查队列是否有元素hasQueuedPredecessors() </p>
<ul>
<li>只在未加入队列的时候，不公平，加入队列后，公平（顺序）获得锁</li>
</ul>
</li>
</ul>
<p>重入：若当前锁被线程持有（state&gt;0），检查当前线程是否是持有锁的线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//加锁</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">	<span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line"> 	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">      	setState(nextc);<span class="comment">//锁重入</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">	<span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">		free = <span class="literal">true</span>;</span><br><span class="line">		setExclusiveOwnerThread(<span class="literal">null</span>);<span class="comment">//设置拥有锁的线程为null</span></span><br><span class="line">      &#125;</span><br><span class="line">	setState(c);</span><br></pre></td></tr></table></figure>



<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>同一时刻多个读线程访问，写线程访问的时候，所有的读线程与其他写线程均被阻塞。</p>
<p>一对锁：一个读锁+一个写锁</p>
<p>读写锁：int整型变量切割两部分，高16位读，低16位写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_SHIFT</span>   <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_UNIT</span>    <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_COUNT</span>      <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCLUSIVE_MASK</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sharedCount</span><span class="params">(<span class="type">int</span> c)</span>    &#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125; <span class="comment">//高16位读</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">exclusiveCount</span><span class="params">(<span class="type">int</span> c)</span> &#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125; <span class="comment">// 低16位写</span></span><br></pre></td></tr></table></figure>

<h3 id="写锁：独占锁"><a href="#写锁：独占锁" class="headerlink" title="写锁：独占锁"></a>写锁：独占锁</h3><ul>
<li><p>获取：独占锁的获取，额外增加了是否存在读锁的判定</p>
<ul>
<li><pre><code class="java">if (w == 0 || current != getExclusiveOwnerThread())
//存在读锁或者有其他线程获得了写锁，获取失败，返回上层进入阻塞
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 释放：独占锁的释放</span><br><span class="line"></span><br><span class="line">### 读锁：共享锁</span><br><span class="line"></span><br><span class="line">* 获取：写锁被占用且不是本线程获取失败。否则，CAS获取读锁</span><br><span class="line"></span><br><span class="line">  * ```java</span><br><span class="line">     if (exclusiveCount(c) != 0 &amp;&amp; </span><br><span class="line">            getExclusiveOwnerThread() != current) //写锁被占用且不是本线程</span><br><span class="line">         		//本线程持有写锁的判定，也是读写锁，锁降级的原因</span><br><span class="line">             return -1;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>释放：共享锁的释放，循环CAS</p>
</li>
</ul>
<h3 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h3><p>当前线程拥有写锁，然后获得读锁，之后释放写锁，读锁就降级了写锁</p>
<h2 id="LockSupport工具"><a href="#LockSupport工具" class="headerlink" title="LockSupport工具"></a>LockSupport工具</h2><p>LockSupport：定义了一组以park开头的方法来阻塞当前线程，以及unpark方法来唤醒一个被阻塞的线程。</p>
<ul>
<li><p>park：阻塞当前线程</p>
<ul>
<li>unpark阻塞线程，会返回</li>
<li>线程被中断，会返回</li>
<li>park（time），过了足够的时间，返回</li>
<li>异常发生，且无原因，会返回</li>
</ul>
</li>
<li><p>unpark(Thread）：唤醒阻塞的线程</p>
</li>
</ul>
<p>park（Object）：object对象用来标识当前线程正在等待的对象，主要用于问题排查与系统监控</p>
<h2 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AQS：</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The current owner of exclusive mode synchronization.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;<span class="comment">//存储当前持有锁的线程</span></span><br></pre></td></tr></table></figure>

<p>condition接口提供了类似Object的监视器方法，与Lock配合可以实现等待&#x2F;通知模式。</p>
<p>基于 LockSupport,unpark方法实现等待队列的阻塞</p>
<img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/java/JAVAcondition%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97%E5%9B%BE.jpg" alt="JAVAcondition阻塞与同步队列图" style="zoom:67%;" />

<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/JAVAAQScondition%E9%98%BB%E5%A1%9E%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97%E8%BD%AC%E6%8D%A2.jpg" alt="JAVAAQScondition阻塞等待队列转换"></p>
<ul>
<li><p>等待await：加入尾部，调用await的线程一定持有lock锁，即同步队列的首节点，锁保证同步，</p>
<ul>
<li><pre><code class="java">addConditionWaiter();//加入尾部
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;img src=&quot;https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/JAVAawait%E9%98%BB%E5%A1%9E%E5%88%B0%E7%AD%89%E5%BE%85.jpg&quot; alt=&quot;JAVAawait阻塞到等待&quot; style=&quot;zoom: 67%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">* 通知signal：唤醒等待节点中的等待时间最长的节点（等待队列的首节点）</span><br><span class="line"></span><br><span class="line">![JAVA等待队列到阻塞队列](https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/JAVA%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97%E5%88%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.jpg)</span><br><span class="line"></span><br><span class="line">关于await和signal方法的调用线程必须是持有锁的线程</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">await（）：        </span><br><span class="line"> public final void await() throws InterruptedException &#123;</span><br><span class="line">            if (Thread.interrupted())</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">            int savedState = fullyRelease(node);</span><br><span class="line">            int interruptMode = 0;</span><br><span class="line">            while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                LockSupport.park(this);		//park,阻塞队列</span><br><span class="line">                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            if (node.nextWaiter != null) // clean up if cancelled</span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            if (interruptMode != 0)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">	protected final boolean isHeldExclusively() &#123;</span><br><span class="line">        // While we must in general read state before owner,</span><br><span class="line">        // we don&#x27;t need to do so to check if current thread is owner</span><br><span class="line">        return getExclusiveOwnerThread() == Thread.currentThread();//持有锁的线程是否当前线程</span><br><span class="line">    &#125;   </span><br><span class="line">	protected final void setExclusiveOwnerThread(Thread thread) &#123;</span><br><span class="line">    exclusiveOwnerThread = thread;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  signal</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            hrow <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">     <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">      <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">             doSignal(first);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>)</span><br><span class="line">            lastWaiter = <span class="literal">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;java</span><br><span class="line"></span><br><span class="line">        <span class="title function_">if</span> <span class="params">(!node.compareAndSetWaitStatus(Node.CONDITION, <span class="number">0</span>)</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !p.compareAndSetWaitStatus(ws, Node.SIGNAL))</span><br><span class="line">            LockSupport.unpark(node.thread); <span class="comment">//unpark</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>线程</title>
    <url>/2020/04/30/java/concurrent/thread/</url>
    <content><![CDATA[<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>线程：现代操作系统调度的最小单元。</p>
<p>多线程优势：</p>
<ol>
<li>利用了多处理器</li>
<li>缩短响应时间</li>
<li>更好的编程模型</li>
</ol>
<span id="more"></span>

<h2 id="线程的状态与转换"><a href="#线程的状态与转换" class="headerlink" title="线程的状态与转换"></a>线程的状态与转换</h2><p>注意阻塞与等待状态</p>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/JAVA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%AD%E7%A7%8D%E7%8A%B6%E6%80%81%E5%9F%9F%E8%BD%AC%E6%8D%A2.jpg" alt="JAVA线程的六种状态域转换"></p>
<h3 id="Daemon线程"><a href="#Daemon线程" class="headerlink" title="Daemon线程"></a>Daemon线程</h3><p>守护线程：用作程序中后台调度与支持性工作。</p>
<p>Thread.setDaemon(true)：在start开始前设置</p>
<p>java虚拟机没有非Daemon线程的时候，会直接退出，不会执行Daemon.run方法中的finally块（如果有的话）</p>
<blockquote>
<p>主要是守护线程占有的资源的释放</p>
</blockquote>
<h2 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h2><p>构造线程的两种方法</p>
<ol>
<li>继续<em>Thread</em>类，重写该类的run方法。</li>
<li>实现接口<ol>
<li><em>Runnable</em>， 实现该接口的run()方法</li>
<li><em>Callable</em>，实现call()方法</li>
</ol>
</li>
</ol>
<p>不被推荐使用的suspend()，resume(),stop() 方法，对资源并没有保证释放。</p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h3 id="volatile-synchronized"><a href="#volatile-synchronized" class="headerlink" title="volatile synchronized"></a>volatile synchronized</h3><ul>
<li>volatile：从主内存读，写刷新回主内存</li>
<li>synchronized：确保同一时刻只有一个进程处于方法。代码块中</li>
</ul>
<h3 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待&#x2F;通知机制"></a>等待&#x2F;通知机制</h3><p>Object对象的wait，notify，notifyAll方法，lock的condition</p>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/JAVAwaitnotify%E6%9C%BA%E5%88%B6.png" alt="JAVAwaitnotify机制"></p>
<p>消费者生产者的例子：</p>
<ul>
<li>等待方（消费者）：<ol>
<li>获取对象的锁<ol>
<li>获得锁：看条件是否满足<ol>
<li>满足：执行代码</li>
<li>不满足：wait()等待</li>
</ol>
</li>
<li>没获得锁：阻塞队列</li>
</ol>
</li>
</ol>
</li>
<li>通知方（生产者）：<ol>
<li>获得对象的锁<ol>
<li>改变条件</li>
<li>通知等待在该对象的线程</li>
</ol>
</li>
</ol>
</li>
</ul>
<h3 id="管道IO流，NIO"><a href="#管道IO流，NIO" class="headerlink" title="管道IO流，NIO"></a>管道IO流，NIO</h3><h3 id="Thread-join"><a href="#Thread-join" class="headerlink" title="Thread.join()"></a>Thread.join()</h3><p>A.join():当前线程等待thread A终止之后才从join（）的调用中返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">     join(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> millis)</span></span><br><span class="line"> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">     <span class="keyword">if</span> (millis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (isAlive()) &#123;</span><br><span class="line">             <span class="keyword">final</span> <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">             <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis;</span><br><span class="line">             <span class="keyword">do</span> &#123;</span><br><span class="line">                 wait(delay);<span class="comment">//A.join(),线程A是否存活</span></span><br><span class="line">             &#125; <span class="keyword">while</span> (isAlive() &amp;&amp; (delay = millis -</span><br><span class="line">                     TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime)) &gt; <span class="number">0</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">while</span> (isAlive()) &#123;<span class="comment">//A.join(),线程A是否存活</span></span><br><span class="line">             wait(<span class="number">0</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h3><p>ThreadLocal：线程变量，一个以ThreadLocal对象为键，任意对象为值的存储结构</p>
<p>作用：提供线程内的局部变量，多线程下访问时，保证各个线程的变量相对独立于其他的线程内的变量</p>
<p>Threadlocal应用于高并发时：</p>
<ul>
<li><p>synchronized：一份资源，以时间换空间</p>
</li>
<li><p>Threadlocal：每一个线程都有一份自己的资源，空间换时间</p>
</li>
</ul>
<p>threadmap解决hash冲突的方法：线性探查法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">一个thread对应一个 ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	ThreadLocalMap存储的元素时 Entry(ThreadLocal&lt;?&gt; k, Object v)</span><br><span class="line">		Entry <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; </span><br><span class="line">        ThreadLocal中，key，threadlocal是弱引用，object value是强引用</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>singleton</title>
    <url>/2020/04/30/java/singleton/</url>
    <content><![CDATA[<p>单例模式</p>
<span id="more"></span>

<h2 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">   <span class="comment">//volatile，内存屏障，可见性，防止重排序，使得未初始化的类对象被使用.</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">   <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//第一个判断，防止过多阻塞</span></span><br><span class="line">      <span class="keyword">if</span>( instance == <span class="literal">null</span> ) &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="comment">//第二个判断，防止在阻塞期间，其他进程完成初始化</span></span><br><span class="line">            <span class="keyword">if</span>( instance == <span class="literal">null</span> )</span><br><span class="line">               instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   //单例</span></span><br><span class="line"><span class="comment">   //thread 1  11行进去了， thread 2 </span></span><br><span class="line"><span class="comment">   //new了，内存分配已经完成，但是还未开始init（父），</span></span><br><span class="line"><span class="comment">   发生指令重排，先建立了指向关系，此时instance不为空，处于半初始化状态</span></span><br><span class="line"><span class="comment">   //此时，thread2 10行判定不为空，认为已经初始化完成（实际上由于指令重排，半初始化）</span></span><br><span class="line"><span class="comment">   </span></span><br></pre></td></tr></table></figure>

<p>不使用volatile变量，会使得 instance &#x3D; new Singleton();对象的过程能够被重排序，变成分配空间，赋值，然后初始化的顺序。这个过程其他线程能够看到赋值。但是看到的赋值并没有完成初始化。</p>
<p>解决方法：</p>
<ul>
<li><p>禁止重排序：双重检查，volatile</p>
</li>
<li><p>让重排序其他线程不可见：静态内部类方式</p>
</li>
</ul>
<h2 id="静态内部类方式"><a href="#静态内部类方式" class="headerlink" title="静态内部类方式"></a>静态内部类方式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticSingleton</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造方法，禁止在其他类中创建实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">StaticSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StaticSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StaticSingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一个私有的静态内部类，用于初始化一个静态final实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticSingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">StaticSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticSingleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构--位图</title>
    <url>/2020/04/30/dataStructure/bit/</url>
    <content><![CDATA[<h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><p>位图法就是bitmap的缩写。所谓bitmap，就是用每一位来存放某种状态，适用于大规模数据，但数据状态又不是很多的情况。通常是用来判断某个数据存不存在的</p>
<ul>
<li><p>char bit[16 * 1024];  bit 存放的字节位置和位位置（字节 0<del>16*1024 ，位 0</del>16 ）  </p>
</li>
<li><p>字节位置： int nBytePos &#x3D;1234&#x2F;16 &#x3D; 154; </p>
</li>
<li><p>位位置：  int nBitPos &#x3D; 1234 &amp; 15 &#x3D; 2;</p>
</li>
</ul>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p><strong>当一个元素加入布隆过滤器中的时候，会进行如下操作：</strong></p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
<p><strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：</strong></p>
<ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构--graph</title>
    <url>/2020/04/30/dataStructure/graph/</url>
    <content><![CDATA[<h1 id="1-图的基本概念"><a href="#1-图的基本概念" class="headerlink" title="1. 图的基本概念"></a>1. 图的基本概念</h1><h2 id="1-1-图的基本术语"><a href="#1-1-图的基本术语" class="headerlink" title="1.1 图的基本术语"></a>1.1 图的基本术语</h2><span id="more"></span>

<p>定义：<strong>图</strong> <strong>G</strong> <strong>是由两个集合顶点集</strong> <strong>V(G)</strong> <strong>和边集</strong> <strong>E(G)</strong> 组成的，记作G&#x3D;( V(G)，E(G) )，简称G&#x3D;(V，E)。</p>
<p>​			V:顶点的有穷非空集合			E：边的有穷集合两个顶点之间的关系，即边的有穷集合</p>
<ul>
<li><p>邻接：顶点与顶点之间的关系。</p>
<ul>
<li>有向图邻接：有向图 G&#x3D;(V, E) ，如果弧 &lt;v, v’&gt; ∈ E，则称顶点 v 邻接到顶点 v’，顶点 v’ 邻接到顶点 v 。 </li>
<li>无向图邻接：无向图 G&#x3D;(V, E)，如果边 (v, v’) ∈ E，则称顶点 v 和 v’ 互为邻接点，即 v 和 v’ 相邻接。</li>
</ul>
</li>
<li><p>关联：边与两个顶点的关系。</p>
<ul>
<li>有向图关联：弧 &lt;v, v’&gt; 和顶点 v, v’ 相关联。v-&gt;v’</li>
<li>无向图关联：边 (v, v’) 依附于顶点 v 和 v’ ，或者说 (v, v’) 与顶点 v 和 v’ 相关联。</li>
</ul>
</li>
</ul>
<p><strong>顶点的度</strong>：</p>
<ul>
<li>无向图：顶点 v 的度是和 v 相关联的边的数目，记做TD(v)。 </li>
<li>有向图：顶点 v 的度 TD(V) 分为两部分——出度、入度。 <ul>
<li>顶点 v 的度为 TD(v) &#x3D; ID(v) + OD(v)。</li>
<li>以顶点 v 为头的弧的数目称为 v 的入度，记为ID(v) ；</li>
<li>以顶点 v 为尾的弧的数目称为 v 的出度，记为OD(v)；</li>
</ul>
</li>
</ul>
<p>对于一个图(无向图、有向图)，如果顶点 vi 的度为TD(vi)，那么具有 n 个顶点、e 条边或弧的图，必满足如下关系</p>
<p>​							$ e &#x3D; \frac{1}{2}\sum^{n}_{i&#x3D;1}TD(v_i)$  无向图、有向图的边或弧均计算两遍。</p>
<p>权：对图的边与弧赋予相关的数值，其数值叫做权</p>
<h2 id="1-2-图分类"><a href="#1-2-图分类" class="headerlink" title="1.2 图分类"></a>1.2 图分类</h2><ul>
<li>有向图：边为有向边，边是顶点的有序对</li>
<li>无向图：无向边，边是顶点的无序对</li>
<li>混合图：无向边+有向边</li>
</ul>
<p>用 n 表示图中顶点数目，用 e 表示边或弧的数目，若在图中不存在顶点到自身的边或弧，则</p>
<p>​					对于无向图，$0 ≤ e ≤ \frac{1}{2}n(n-1)$</p>
<p>​					对于有向图，$$0 ≤ e ≤ n(n-1)$$</p>
<p><strong>完全图</strong>：$\frac{1}{2}n(n-1)$边的无向图</p>
<p><strong>有向完全图</strong>：n(n-1)条弧的有向图	</p>
<p><strong>子图</strong>：假设有两个图 G&#x3D;(V, E) 和 G’&#x3D;(V’, E’) ，如果 $V’ \subseteq  V，且 E’ \subseteq  E$，则称 G’ 为 G 的子图。 </p>
<p><em><strong>路径</strong></em>：一系列的<strong>顶点</strong>按照<strong>邻接的关系</strong>构成的序列</p>
<p>​	路径的长度：路径上边的数目。</p>
<p>​	简单路径：除起点终点外，不包含重复节点的路径</p>
<p><em><strong>环路</strong></em>：路径的起点与终点一样</p>
<ul>
<li>无环图：不带环路的图。</li>
<li>有向无环图：不包含任何环路的有向图图。</li>
</ul>
<p>欧拉环路：覆盖所有边</p>
<p>哈密尔顿环路：存在所有的点经过一次的路径</p>
<p><strong>连通性</strong>：</p>
<ul>
<li><p>无向图：</p>
</li>
<li><p>连通（点）：无向图G，如果从顶点 v 到顶点 v’ 有路径，则称 v 和 v’ 是连通的。</p>
<ul>
<li><p>连通图（图）：如果对于无向图 G 中任意两个顶点 vi , vj ∈V,  vi 和 vj 都是连通的，则称 G 是连通图。 </p>
</li>
<li><p>连通分量（子图）：指的是无向图中的最大连通子图。</p>
</li>
</ul>
</li>
<li><p>有向图</p>
<ul>
<li>连通（点）：如果从顶点 v 到顶点 v’ 有路径 **或 **从顶点 v’ 到顶点 v 有路径，则称 v 和 v’ 是连通的。 </li>
<li>强连通图（图）：如果对于每一对 vi, vj ∈V，vi≠vj ，从 vi 到 vj  和 从 vj 到 vi <strong>都</strong>存在路径，则称 G 是强连通图。 </li>
<li>强连通分量（子图）：有向图中的最大强连通子图</li>
</ul>
</li>
</ul>
<p><strong>生成树</strong>：一个连通图 G 的一个包含所有顶点的极小连通子图 T 。</p>
<ul>
<li>T 包含 G 的所有顶点 n 个</li>
<li>T 为连通子图</li>
<li>T 包含的边数最少</li>
</ul>
<p>则T 是一棵有 n 个顶点，n-1 条边的生成树。</p>
<p>性质：</p>
<ul>
<li>一个有n个顶点的连通图的生成树有且仅有n-1条边。</li>
<li>一个连通图的生成树并不唯一</li>
</ul>
<h1 id="2-图的存储结构"><a href="#2-图的存储结构" class="headerlink" title="2. 图的存储结构"></a>2. 图的存储结构</h1><h2 id="2-1-顺序存储"><a href="#2-1-顺序存储" class="headerlink" title="2.1 顺序存储"></a>2.1 顺序存储</h2><h3 id="2-1-1-邻接矩阵"><a href="#2-1-1-邻接矩阵" class="headerlink" title="2.1.1 邻接矩阵"></a>2.1.1 邻接矩阵</h3><p>邻接矩阵存放 n 个顶点信息和 n2 条边或弧信息。</p>
<p>优点：</p>
<ol>
<li>容易判断任意两个顶点之间是否有边或弧。</li>
<li>容易求取各个顶点的度。<ol>
<li>无向图，顶点 vi 的度是邻接矩阵中<strong>第 i 行或第 i 列</strong>的元素之和。<ol>
<li>无向图的邻接矩阵都是对称矩阵。</li>
</ol>
</li>
<li>有向图，顶点 vi 的<strong>出度</strong>是邻接矩阵中<strong>第 i 行</strong>的元素之和。<br>顶点 vi 的<strong>入度</strong>是邻接矩阵中<strong>第 i 列</strong>的元素之和。</li>
</ol>
</li>
</ol>
<h2 id="2-2-链式存储"><a href="#2-2-链式存储" class="headerlink" title="2.2 链式存储"></a>2.2 链式存储</h2><h3 id="2-2-1-邻接表"><a href="#2-2-1-邻接表" class="headerlink" title="2.2.1 邻接表"></a>2.2.1 邻接表</h3><p>邻接表(adjacency list)表示法是一种链式存储结构，由一个<strong>顺序存储的顶点表</strong>和<strong>n个链接存储的边表</strong>组成。</p>
<table>
<thead>
<tr>
<th>顶点表信息</th>
<th>-</th>
<th>边表信息</th>
</tr>
</thead>
<tbody><tr>
<td>顶点+边表指针</td>
<td></td>
<td>邻接的顶点+边信息+下一个边表信息</td>
</tr>
</tbody></table>
<p><strong>顶点的度</strong>:顶点 vi 的度为第 i 条链表中的结点数。</p>
<p>存储空间：n+e（n个顶点，e条边）（有向图）</p>
<h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><h1 id="3-图的遍历"><a href="#3-图的遍历" class="headerlink" title="3. 图的遍历"></a>3. 图的遍历</h1><h2 id="3-1-深度优先DFS"><a href="#3-1-深度优先DFS" class="headerlink" title="3.1 深度优先DFS"></a>3.1 深度优先DFS</h2><ol>
<li>访问一个顶点V，然后访问该顶点邻接到的未被访问过的顶点V’，</li>
<li>再从V’出发递归地按照深度优先的方式周游，</li>
<li>当遇到一个所有邻接于它的顶点都被访问过了的顶点U时，则回到已访问顶点序列中最后一个拥有未被访问的邻顶点的顶点W，</li>
<li>再从W出发递归地按照深度优先的方式周游，</li>
<li>最后，当任何已被访问过的顶点都没有未被访问的相邻顶点时，则周游结束。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">DFS</span><span class="params">(Graph&amp; G, <span class="type">int</span> v)</span>  &#123;       	<span class="comment">// 深度优先搜索的递规实现</span></span><br><span class="line">    	G.Mark[v] = VISITED;         	<span class="comment">// 将标记位设置为VISITED</span></span><br><span class="line">    	Visit(G,v);				<span class="comment">// 访问顶点v</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">Edge</span> <span class="variable">e</span> <span class="operator">=</span> G.FirstEdge(v); G.IsEdge(e); e = G.NextEdge(e))</span><br><span class="line">        <span class="keyword">if</span> (G.Mark[G.ToVertex(e)] == UNVISITED)</span><br><span class="line">	        DFS(G, G.ToVertex(e));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-2-广度优先-BFS"><a href="#3-2-广度优先-BFS" class="headerlink" title="3.2 广度优先 BFS"></a>3.2 广度优先 BFS</h2><ol>
<li>访问顶点V0，</li>
<li>然后访问V0邻接到的所有未被访问过的顶点V01，V02，…V0i，</li>
<li>再依次访问V01，V02，…V0i邻接到的所有未被访问的顶点，</li>
<li>如此进行下去，直到访问遍所有的顶点。</li>
</ol>
<h1 id="4-最小生成树"><a href="#4-最小生成树" class="headerlink" title="4. 最小生成树"></a>4. 最小生成树</h1><p>生成树的代价:为树上各边的权之总和</p>
<p>最小生成树(minimum-cost spanning tree，简称MST)：所有的生成树中，代价最小的生成树</p>
<h2 id="4-1-构造算法-Prim算法"><a href="#4-1-构造算法-Prim算法" class="headerlink" title="4.1 构造算法-Prim算法"></a>4.1 构造算法-Prim算法</h2><p>N &#x3D; ( V , E ) 是具有 n 个顶点的连通图，设 U 是最小生成树中顶点的集合，设 TE 是最小生成树中边的集合； </p>
<ol>
<li>初始，U &#x3D; { u1 } ，TE &#x3D; { } </li>
<li>重复执行:	<ol>
<li>在所有 u∈<strong>U</strong>，v∈<strong>V-U</strong> 的边 ( u , v ) 中寻找**代价最小的边( u’ , v’ ) **，并纳入集合 TE 中；</li>
<li>同时将 v’ 纳入集合 U 中；</li>
</ol>
</li>
<li>直至 U &#x3D; V 为止。集合 TE 中必有 n-1 条边。</li>
</ol>
<h2 id="4-2-构造算法-Kruskal"><a href="#4-2-构造算法-Kruskal" class="headerlink" title="4.2 构造算法-Kruskal"></a>4.2 构造算法-Kruskal</h2><p>使用的贪心准则，从剩下的边中选择具有最小权值且不会产生环路的边加入到生成树的边集中。</p>
<ol>
<li>先将G中的n个顶点看成是独立的n个连通分量，这时的状态是有n个顶点而无边的森林，可以记为T &#x3D; &lt;V，{}&gt;。</li>
<li>然后在E中选择代价最小的边，如果该边依附于两个不同的连通分支，那么将这条边加入到T中，否则舍去这条边而选择下一条代价最小的边。</li>
<li>依此类推，直到T中所有顶点都在同一个连通分量中为止，此时就得到图G的一棵最小生成树</li>
</ol>
<p>基本操作：<br>（1）确定权值最小的边————-优先队列<br>（2）判定一条边所关联的两个顶点是否在一个连通分量中；—-等价类<br>（3）如果不是则合并两个顶点所属的连通分量。——————-等价类</p>
<h3 id="4-2-1-等价类"><a href="#4-2-1-等价类" class="headerlink" title="4.2.1 等价类"></a>4.2.1 等价类</h3><p>等价类：等价元素集合</p>
<p>两种基本操作：整个操作以“UNION&#x2F;FIND算法”（也可以翻译为“并查算法”）命名</p>
<ol>
<li>判断两个结点是否在同一个集合中，查找一个给定结点的根结点的过程称为FIND </li>
<li>归并两个集合，这个归并过程常常被称为UNION</li>
</ol>
<p><strong>实现方式</strong>：静态循环链表思想</p>
<p>root[]标识顶点集合的顶点索引</p>
<p>next[]指示链表中的下一个顶点</p>
<p>length[]指示链表中的顶点数目</p>
<h2 id="4-3-算法比较"><a href="#4-3-算法比较" class="headerlink" title="4.3 算法比较"></a>4.3 算法比较</h2><table>
<thead>
<tr>
<th>name</th>
<th>复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>Prim</td>
<td>$n^2$                n：顶点个数</td>
</tr>
<tr>
<td>Kruskal</td>
<td>$e\log{e}$           e：边的个数</td>
</tr>
</tbody></table>
<h1 id="5-最短路径"><a href="#5-最短路径" class="headerlink" title="5 最短路径"></a>5 最短路径</h1><h2 id="5-1-单源最短路径"><a href="#5-1-单源最短路径" class="headerlink" title="5.1 单源最短路径"></a>5.1 单源最短路径</h2><h2 id="5-1-1-Dijkstra算法"><a href="#5-1-1-Dijkstra算法" class="headerlink" title="5.1.1 Dijkstra算法"></a>5.1.1 Dijkstra算法</h2><p>Dijkstra算法：是由E.W.Dijkstra提出的一种按路径长度递增的次序产生到各顶点最短路径的贪心算法。</p>
<ol>
<li><table>
<thead>
<tr>
<th>集合S</th>
<th>V-S</th>
</tr>
</thead>
<tbody><tr>
<td>最短距离已经确定的顶点集</td>
<td>其余的顶点</td>
</tr>
</tbody></table>
<p>数组D来记录当前所找到的从源点s到每个顶点的最短特殊路径长度</p>
</li>
<li><p>从尚未确定最短路径长度的集合V-S中取出一个最短特殊路径长度最小的顶点u，将u加入集合S，同时修改数组D中由s可达的最短路径长度</p>
</li>
</ol>
<h2 id="5-2-顶点对之间的最短路径"><a href="#5-2-顶点对之间的最短路径" class="headerlink" title="5.2 顶点对之间的最短路径"></a>5.2 顶点对之间的最短路径</h2><h1 id="6-拓扑排序"><a href="#6-拓扑排序" class="headerlink" title="6. 拓扑排序"></a>6. 拓扑排序</h1>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构--位图</title>
    <url>/2020/04/30/dataStructure/bitmap/</url>
    <content><![CDATA[<h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p><strong>当一个元素加入布隆过滤器中的时候，会进行如下操作：</strong></p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
<p><strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：</strong></p>
<ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构--AVL和红黑树</title>
    <url>/2020/04/30/dataStructure/AVLand%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<p>树的删除：</p>
<ol>
<li>叶子节点：直接删除</li>
<li>有一个子节点：子节点代替删除节点的位子</li>
<li>有两个子节点：<ol>
<li>合并删除：删除节点的一个子节点代替要删除节点的位子，另一个子节点放在合适的位置</li>
<li>复制删除：找到左边最大&#x2F;右边最小，复制到删除的节点，并删原来的节点</li>
</ol>
</li>
</ol>
<span id="more"></span>

<table>
<thead>
<tr>
<th></th>
<th>AVL</th>
<th>红黑</th>
</tr>
</thead>
<tbody><tr>
<td>查找</td>
<td>$O(\log_2 n)$</td>
<td>$O(\log_2 n)$</td>
</tr>
<tr>
<td>插入</td>
<td>2次旋转</td>
<td>2次旋转+$O(\log_2 n)$次变色</td>
</tr>
<tr>
<td>删除</td>
<td>$O(\log_2 n)$</td>
<td>三次旋转+$O(\log_2 n)$次变色</td>
</tr>
</tbody></table>
<p>查找系数AVL &lt; 红黑树</p>
<p>除了删除外，AVL优于红黑树</p>
<h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><h3 id="四种旋转-："><a href="#四种旋转-：" class="headerlink" title="四种旋转 ："></a>四种旋转 ：</h3><p>每次插入最多旋转一次</p>
<ol>
<li><p>左单旋转，RR，+2</p>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/AVL%E7%9A%84%E5%B7%A6%E5%8D%95%E6%97%8B%E8%BD%AC.png" alt="AVL的左单旋转"></p>
</li>
<li><p>右单旋转，LL，-2</p>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/AVL%E7%9A%84%E5%8F%B3%E5%8D%95%E6%97%8B%E8%BD%AC.png" alt="AVL的右单旋转"></p>
</li>
<li><p>先左后右旋转,LR，-2</p>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/AVL%E7%9A%84%E5%85%88%E5%B7%A6%E5%90%8E%E5%8F%B3.png" alt="AVL的先左后右"></p>
</li>
<li><p>先右后左旋转,RL，+2</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/AVL%E7%9A%84%E5%85%88%E5%8F%B3%E5%86%8D%E5%B7%A6.png" alt="AVL的先右再左"></p>
<p><strong>旋转性质</strong>：</p>
<ul>
<li>新子树高度h+2，保持插入前子树的高度不变；</li>
<li>原来二叉树在a节点上面的其余部分总是保持平衡。</li>
</ul>
<h3 id="AVL的删除："><a href="#AVL的删除：" class="headerlink" title="AVL的删除："></a>AVL的删除：</h3><p>以在左子树进行删除为例</p>
<ol>
<li><p>结点平衡度原为 0(h,h-1)。删除后：h - ( h - 1 ) &#x3D; 1。调整结束，<strong>高度不变仍为h+1</strong>。结束</p>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/AVL%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E5%B9%B3%E8%A1%A1%E5%BA%A60.png" alt="AVL删除节点平衡度0"></p>
</li>
<li><p>结点平衡度原为 -1 （ h , h - 1)。 删除后：h-1 - ( h - 1 ) &#x3D; 0。调整后<strong>高度少1，由h变为h-1</strong>，<strong>继续调整</strong>.</p>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/AVL%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E5%B9%B3%E8%A1%A1%E5%BA%A6-1.png" alt="AVL删除节点平衡度-1"></p>
</li>
<li><p>结点平衡度原为＋1(  h - 1 , h )。删除后： h - ( h - 2) &#x3D; 2 有三种情况 :</p>
<ol>
<li><p>右兄弟平衡因子为 0  ( h-1,h-1)  。<strong>左旋</strong>,  高度不变，结束</p>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/AVL%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E5%B9%B3%E8%A1%A1%E5%BA%A6%2B1%E5%8F%B3%E5%AD%900.png" alt="AVL删除节点平衡度+1右子0"></p>
</li>
<li><p>右兄弟平衡因子为＋1 (h-2,h-1)，<strong>左旋</strong> , <strong>高度少一，h+1变为h，继续</strong></p>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/AVL%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E5%B9%B3%E8%A1%A1%E5%BA%A6%2B1%E5%8F%B3%E5%AD%90%2B1.png" alt="AVL删除节点平衡度+1右子+1"></p>
</li>
<li><p>右兄弟平衡因子为－1 (h - 1 , h - 2)，RL。<strong>高度少一，h+1变为h，继续</strong></p>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/AVL%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E5%B9%B3%E8%A1%A1%E5%BA%A6%2B1%E5%8F%B3%E5%AD%90-1.png" alt="AVL删除节点平衡度+1右子-1"></p>
</li>
</ol>
</li>
</ol>
<p><strong>AVL的高度</strong>：具有n个结点的AVL树的高度一定是O(log n)</p>
<p>检索、插入和删除效率都是  $$O(1og_2n)$$</p>
<p>在插入&#x2F;删除一个新结点后，需要从插入&#x2F;删除位置沿通向根的路径回溯，检查各结点的平衡因子(左、右子树的高度差)。如果在某一结点发现高度不平衡，停止回溯。此过程最坏到达根节点， $$O(1og_2n)$$</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h3 id="红黑树性质："><a href="#红黑树性质：" class="headerlink" title="红黑树性质："></a>红黑树性质：</h3><ol>
<li>每个结点或是红色的,或是黑色的。</li>
<li>根结点是黑色的。</li>
<li>每个叶结点(NIL)是黑色的</li>
<li>如果一个结点是红色的,则它的两个子结点都是黑色的（两个红色的节点不相接）</li>
<li>对每个结点,从该结点到其所有后代叶结点的简单路径上,均包含相同数目的黑色结点</li>
</ol>
<h3 id="插入："><a href="#插入：" class="headerlink" title="插入："></a>插入：</h3><p>插入点应设为红色（插入节点：N，父节点：P，叔叔节点：U，父节点的父节点：G</p>
<ol>
<li>该树为空树：直接插入根节点，此时违反性质2，将节点改为黑色即可。</li>
<li>插入点N的父节点P为黑色，不违反任何性质）：结束。</li>
<li>父节点P为红色，违反性质4<ol>
<li>叔U为红：变色，P、U变为黑，G变为红。对G向上搜索</li>
<li>U为黑，<ol>
<li>直线型NP：LL&#x2F;RR（N为P的左孩子，P为G的左孩子（或者N为P的右孩子，P为G的右孩子，即同向））：PG交换颜色并右&#x2F;左旋</li>
<li>三角形NP：LR&#x2F;RL（N为P的右孩子，P为G的左孩子（或者N为P的左孩子，P为G的右孩子，即反向））：PG：左&#x2F;右旋，变成直线型 ，进入上方操作</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p> 子节点（含数值&#x2F;关键字），非叶子节点（空节点）</p>
</blockquote>
<h3 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h3><ol>
<li><p>删除节点的子节点数量：</p>
<ol>
<li>有两个子节点—-无叶子节点：复制替换（x节点）（颜色也换），删除节点，变成下面的情况</li>
<li>存在叶子节点：另一个节点（x节点）替换要删除的节点</li>
</ol>
</li>
<li><p>若删除的节点颜色黑色：维护红黑树</p>
<ol>
<li><p>x节点：替换节点的叶子节点的另外一个子节点（可能叶子），w：x的兄弟节点</p>
</li>
<li><p>while( x !&#x3D; root &amp;&amp; x.clor &#x3D; black ){</p>
<ol>
<li><p>w红色：  p红，w黑，左旋，进入下面的2，3，4</p>
</li>
<li><p>w黑色，且w两个子节点也是黑色：  w红，x 指向x的父，<strong>继续</strong></p>
</li>
<li><p>w黑，w左子红，右子黑：  w红，右旋，进入4</p>
</li>
<li><p>w黑，w右红：  w变为x的父颜色，p和w右变为黑，左旋，结束while</p>
<p>}</p>
</li>
</ol>
</li>
<li><p>最后x设黑色</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RB-TRANSPLANT(T,u,v)<span class="comment">//把u的父亲指向u的指向，指向v</span></span><br><span class="line"><span class="keyword">if</span> u.p == T.nil <span class="comment">//u为根节点</span></span><br><span class="line">	T.root = v</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> u == u.p.left</span><br><span class="line">	u.p.left = v</span><br><span class="line"><span class="keyword">else</span> u.p.right = v</span><br><span class="line">v.p = u.p</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RB-DELETE(T,z)<span class="comment">//删除z节点</span></span><br><span class="line">y = z</span><br><span class="line">y-original-color = y.color</span><br><span class="line"><span class="keyword">if</span> z.left == T.<span class="type">nil</span></span><br><span class="line">	<span class="variable">x</span> <span class="operator">=</span> z.right			<span class="comment">//记录x，替代删除的节点</span></span><br><span class="line">	RB-TRANSPLANT(T,z,z.right)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> z.right == T.nil		<span class="comment">//z的左右存在叶子节点</span></span><br><span class="line">	x = z.left</span><br><span class="line">	RB-TRANSPLANT(T,z,z.left)</span><br><span class="line"><span class="keyword">else</span> y = TREE-MINMUM(z.right)	<span class="comment">//z的两个子节点都不是叶子节点，找到替换的节点</span></span><br><span class="line">	y-original-color = y.color	<span class="comment">//复制节点删除，颜色也对换</span></span><br><span class="line">	x = y.right				</span><br><span class="line">	<span class="keyword">if</span> y.p == z		<span class="comment">//y是z的右子节点</span></span><br><span class="line">		x.p = y		</span><br><span class="line">     <span class="keyword">else</span> RB-TRANSPLANT(T,y,y.right)	<span class="comment">//指向y的变为指向y.right</span></span><br><span class="line">         y.right = z.right		<span class="comment">//y代替z的位置，z右的双向设置</span></span><br><span class="line">         y.right.p = y		</span><br><span class="line">     RB-TRANSPLANT(T,z,y)</span><br><span class="line">     y.left = z.left</span><br><span class="line">     y.left.p = y</span><br><span class="line">     y.color = z.color</span><br><span class="line"><span class="keyword">if</span> y-original-color == BLACK</span><br><span class="line">    RB-DELETE-FIXUP(T,x) <span class="comment">//维护红黑树	</span></span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> RB-DELETE-FIXUP(T,x) <span class="comment">//维护红黑树	</span></span><br><span class="line"> <span class="keyword">while</span> x != T.root ans x.color == BLACK</span><br><span class="line"> 	<span class="keyword">if</span> x == x.p.<span class="type">left</span></span><br><span class="line"> 		<span class="variable">w</span> <span class="operator">=</span> x.p.right</span><br><span class="line"> 		<span class="keyword">if</span> w.color == RED											<span class="comment">//CASE 1</span></span><br><span class="line"> 			w.color = BLACK</span><br><span class="line"> 			x.p.color = RED</span><br><span class="line">            LEFT-ROTATE(T,x,p)</span><br><span class="line">            w = x.p.right</span><br><span class="line">        <span class="keyword">if</span> w.left.color == BLACK and w.right.color ==BLACK				<span class="comment">//case 2</span></span><br><span class="line">            w.color = <span class="type">RED</span></span><br><span class="line">            <span class="variable">x</span> <span class="operator">=</span> x.p</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> w.right.color == BLACK								<span class="comment">//case 3</span></span><br><span class="line">            w.left.color = BLACK</span><br><span class="line">            w.color = RED</span><br><span class="line">            RIGHT-ROTATE(T,w)</span><br><span class="line">            w = x.p.right</span><br><span class="line">            <span class="comment">//进入case4</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> w.right.color == RED 									<span class="comment">//case 4</span></span><br><span class="line">            w.color = x.p.color</span><br><span class="line">            x.p.color = BLACK</span><br><span class="line">            w.right.color = BLACK</span><br><span class="line">            LEFT-ROTATE(T,x,p)</span><br><span class="line">            x = T.root</span><br><span class="line">   <span class="keyword">else</span>  x == x.p.right</span><br><span class="line">       ...</span><br><span class="line">x.color = BLACK</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>concurrent--内存模型</title>
    <url>/2020/04/30/java/concurrent/lock/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h1><h2 id="1-并发编程的两个问题"><a href="#1-并发编程的两个问题" class="headerlink" title="1. 并发编程的两个问题"></a>1. 并发编程的两个问题</h2><ul>
<li>线程之间如何通信</li>
<li>线程之间如何同步</li>
</ul>
<span id="more"></span>

<p>通信的两种方式：</p>
<ul>
<li>共享内存：</li>
<li>消息传递：</li>
</ul>
<p>java采用共享内存模型，通信隐式进行。</p>
<h3 id="CPU的架构导致的问题"><a href="#CPU的架构导致的问题" class="headerlink" title="CPU的架构导致的问题"></a>CPU的架构导致的问题</h3><ol>
<li>更好的性能–	指令重排序     —- 有序性<ul>
<li>为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是<strong>处理器优化</strong>。</li>
<li>Java虚拟机的即时编译器（JIT）也会做<strong>指令重排</strong> —- 乱序执行。</li>
</ul>
</li>
<li>多级缓存–    CPU缓存不一致 —– 可见性<ul>
<li>CPU和主存之间增加缓存，在多线程场景下就可能存在<strong>缓存一致性问题</strong></li>
</ul>
</li>
</ol>
<h2 id="2-java内存模型的抽象结构"><a href="#2-java内存模型的抽象结构" class="headerlink" title="2. java内存模型的抽象结构"></a>2. java内存模型的抽象结构</h2><p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E4%B8%BB%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E5%85%B3%E7%B3%BB.jpg" alt="jvm内存模型-主工作内存关系"></p>
<p><a href="https://github.com/CyC2018">图片来源:CyC2018</a></p>
<p>Java内存模型规定了所有的变量都存储在<em>主内存</em>中，每条线程还有自己的<em>工作内存</em>，线程的工作内存中保存了该线程中是用到的变量的<em>主内存副本拷贝</em>，<em>线程对变量的所有操作都必须在工作内存</em>中进行，而<strong>不能直接读写主内存</strong>。不同的线程之间也无法直接访问对方工作内存中的变量，<strong>线程间变量的传递</strong>均需要自己的<strong>工作内存和主存</strong>之间进行数据<strong>同步</strong>进行。</p>
<p>Java程序是需要运行在Java虚拟机上面的，<strong>Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</strong></p>
<p>JMM作用于工作内存和主存之间数据同步过程。他规定了  <em>如何做数据同步以及什么时候做数据同步</em>  。目的是解决由于多线程通过共享内存进行通信时，存在的 1-<em>本地内存数据不一致</em>，2-<em>编译器</em>会对代码<strong>指令重排序</strong>，3-处理器<em>会对代码*<em>乱序执行</em></em>  等带来的问题。目的是<strong>保证并发编程场景中的原子性、可见性和有序性</strong>。</p>
<blockquote>
<p><strong>Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。</strong></p>
<p>JMM的实现：JUC等volatile<code>、</code>synchronized<code>、</code>final<code>、</code>concurrent</p>
</blockquote>
<ul>
<li>编译器：javac.exe：java文件—-&gt; class文件</li>
<li>处理器&#x2F;解释器：java.exe： class —-&gt; 平台的机器码</li>
<li>JVM：一种能够运行Java字节码（Java bytecode）的虚拟机。</li>
</ul>
<h3 id="2-1-内存间交互，原子操作类型"><a href="#2-1-内存间交互，原子操作类型" class="headerlink" title="2.1 内存间交互，原子操作类型"></a>2.1 内存间交互，原子操作类型</h3><p>保证以下的操作都是原子的，不可再分的。</p>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E5%86%85%E5%AD%98%E9%97%B4%E4%BA%A4%E4%BA%92.jpg" alt="jvm内存模型-内存间交互"></p>
<p><a href="https://github.com/CyC2018">图片来源:CyC2018</a></p>
<p>简记为：read，write，lock，unlock。</p>
<h3 id="2-2-重排序"><a href="#2-2-重排序" class="headerlink" title="2.2 重排序"></a>2.2 重排序</h3><ul>
<li>编译器重排序：编译器的重排序规则<ul>
<li>编译器优化重排序</li>
</ul>
</li>
<li>处理器重排序：内存屏障来避免<ul>
<li>指令级并行重排序：并行执行</li>
</ul>
</li>
<li>内存系统重排序：读写缓冲区(可见性)</li>
</ul>
<h2 id="3-JMM的三个特性"><a href="#3-JMM的三个特性" class="headerlink" title="3. JMM的三个特性"></a>3. JMM的三个特性</h2><p>内存一致性：多线程程序访问内存时可以读到什么值，并发编程中的原子性、有序性和可见性</p>
<p>缓存一致性：并发编程中的可见性</p>
<p>缓存不一致：</p>
<ul>
<li>通过在总线加<code>LOCK#</code>锁的方式。</li>
<li>通过缓存一致性协议（Cache Coherence Protocol）：共享变量，写的时候，将其他cpu的缓存置null<ul>
<li>MESI的核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</li>
</ul>
</li>
</ul>
<ol>
<li><p>原子性：保证原子性变量操作：read、load、assign、use、store和write这六个，基本数据类型的访问读写是具备原子性。</p>
<ol>
<li>更大范围的原子性保证：lock和unlock操作，提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作两个字节码指令反映到Java代码中就是同步快-synchronized关键字，因此synchronized块之间的操作也具备原子性。—– 锁实现，单线程运行</li>
</ol>
</li>
<li><p>可见性</p>
<ul>
<li>volatile：字节码加入lock<ul>
<li>读：从主内存读</li>
<li>写：写入主内存</li>
<li>缓存保证：缓存一致性协议</li>
<li>总线：总线加锁</li>
</ul>
</li>
<li>synchronized：对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store和write操作）<ul>
<li>monitorenter和monitorexit——lock和unlock操作</li>
<li>线程在加锁时，先清空工作内存→在主内存中拷贝最新变量的副本到工作内存→执行完代码→将更改后的共享变量的值刷新到主内存中→释放互斥锁。</li>
</ul>
</li>
<li>final：不可变对象<ul>
<li>被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把this的引用传递出去（this引用逃逸，其他线程有可能通过这个引用访问到初始化了一半的对象），那么在其他线程中就能看见final字段的值。</li>
</ul>
</li>
</ul>
</li>
<li><p>有序性：处理器重排序，解释器乱序执行</p>
<ul>
<li><p>syn：串行执行，同一时刻只允许一条线程操作，由于无论重排序还是乱序执行，都不改变单线程的结果</p>
</li>
<li><p>处理器–重排序：</p>
<ul>
<li>volatile：禁止重排序<ul>
<li>单例模式，双重检查—– this 引用逃逸</li>
</ul>
</li>
</ul>
</li>
<li><p>解释器（CPU）乱序执行：内存屏障</p>
<ul>
<li>volatile具有内存屏障的语义</li>
<li>final也具有内存屏障的语义</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="3-1-JMM提供的实现"><a href="#3-1-JMM提供的实现" class="headerlink" title="3. 1 JMM提供的实现"></a>3. 1 JMM提供的实现</h3><h4 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h4><ul>
<li>特性<ul>
<li>可见性：读的时候，能够看见其他线程对这个volatile变量最后的写入</li>
<li>原子性：对变量的读写具有原子性</li>
</ul>
</li>
</ul>
<p>volitile的内存屏障：</p>
<ul>
<li><p>volatile写操作：写一个volatile变量的时候，JMM把该线程对应的本地内存的共享变量值<strong>刷新到主内存</strong></p>
<ul>
<li>StoreStoreBarrier：保证写之前，前面的写了且可见；</li>
<li>volatile写操作</li>
<li>StoreLoadBarrier	：保证下面的读之前，volatile写了且可见；</li>
</ul>
</li>
<li><p>volatile读操作：JMM把线程的本地内存置为无效，从主内存读取最新的数值</p>
<ul>
<li>LoadLoadBarrier：保证下面读之前，前面读完了；</li>
<li>volatile读操作</li>
<li>LoadStoreBarrier：保证后面写之前，volatile读取完了；</li>
</ul>
</li>
</ul>
<p>字节码无变化，变量多个volitile的标识，看汇编码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">volatile</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//锁的指令，空指令，给地址数+0---锁总线</span></span><br><span class="line"><span class="number">0x00000215ca711760</span>:   lock add dword ptr [rsp+0ffffffffffffffc0h],0h</span><br><span class="line">                                                            ;*putstatic i &#123;reexecute=<span class="number">0</span> rethrow=<span class="number">0</span> return_oop=<span class="number">0</span>&#125;</span><br><span class="line">                                                            ; - Demo.JITDemo::n@<span class="number">1</span> (line <span class="number">19</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><p>java的CAS操作，unsafe.compareAndSetState()方法，原子实现操作，具有volatile读写的内存语义</p>
<p>实现底层：lock锁，锁总线</p>
<p>CAS与volatile是基本的同步方式。</p>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>synchronized：对执行unlock操作之前，必须先同步回主内存中（执行store和write操作）</p>
<p>对一个变量解锁之前，必须先把此变量同步回主存中。这样解锁后，后续线程就可以访问到被修改后的值。synchronized关键字锁住的对象，其值是具有可见性的</p>
<ul>
<li>monitorenter和monitorexit——lock和unlock操作</li>
<li>线程在加锁时，先清空工作内存→在主内存中拷贝最新变量的副本到工作内存→执行完代码→将更改后的共享变量的值刷新到主内存中→释放互斥锁。</li>
</ul>
<h4 id="final的内存语义"><a href="#final的内存语义" class="headerlink" title="final的内存语义"></a>final的内存语义</h4><p>写的重排序：在构造函数中，禁止把写final 重排序到构造函数之外，</p>
<p>内存屏障：</p>
<ul>
<li>新建对象过程中，构造体中对final域的初始化写入(StoreStore屏障)和这个对象赋值给其他引用变量，这两个操作不能重排序；</li>
<li>初次读包含final域的对象引用和读取这个final域（LoadLoad屏障），这两个操作不能重排序；（意思就是先赋值引用，再调用final值）</li>
</ul>
<p>在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经正确初始化过了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">写<span class="keyword">final</span></span><br><span class="line">StoreStore<span class="comment">//写回主存</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">loadload<span class="comment">//从主存读</span></span><br><span class="line">读<span class="keyword">final</span></span><br></pre></td></tr></table></figure>

<p>增加final的写，读重排序规则，只要对象正确构造（被构造对象的引用没有在构造函数中溢出），不需要同步就可以保证任意线程看到的final域正确初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> nums ;</span><br><span class="line">构造&#123;</span><br><span class="line">nums = <span class="number">1</span>；</span><br><span class="line">obj = <span class="built_in">this</span><span class="comment">//此处溢出，</span></span><br><span class="line">    <span class="comment">//若重排序，先obj = this，后 执行 i = 1，其他程序获取obj.nums，可能读取未正确初始化的数值0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-内存屏障："><a href="#4-内存屏障：" class="headerlink" title="4. 内存屏障："></a>4. 内存屏障：</h2><ol>
<li><strong>有序性</strong>：阻止屏障两侧的指令重排序&#x2F;乱序执行；</li>
<li><strong>可见性</strong>：强制把高速缓存中的数据更新或者写入到主存中<ul>
<li>Load Barrier负责更新高速缓存</li>
<li>Store Barrier负责将高速缓冲区的内容写回主存</li>
</ul>
</li>
</ol>
<p>内存屏障是硬件层的概念，不同的硬件平台实现内存屏障的手段并不是一样，java通过屏蔽这些差异，统一由jvm来生成内存屏障的指令</p>
<p>JSR内存屏障—JVM级别的内存屏障，</p>
<ul>
<li>LoadLoad屏障：load1 ，LoadLoad，Load2，<ul>
<li>在load2及其后续读取操作要读取的数据被访问前，保证load1要读取的数据被读取完毕</li>
<li>禁止处理器把上面的 <code>volatile</code>读，与下面的普通读<strong>重排序</strong>。</li>
</ul>
</li>
<li>StoreStore屏障：Store1 ，StoreStore，Store2，<ul>
<li>在Store2及其后续写入操作执行前，保证Store1的写入操作对其他处理器可见</li>
<li>前面的写，刷新回主内存</li>
</ul>
</li>
<li>LoadStore屏障：load1 ，LoadStore，Store2.<ul>
<li>在Store2及其后续写入操作被刷出前，保证load1要读取的数据被读取完毕</li>
<li>禁止处理器把上面的 <code>volatile</code>读，与下面的普通写<strong>重排序</strong>。</li>
</ul>
</li>
<li>StoreLoad屏障：Store1 ，StoreLoad，Load2，<ul>
<li>在load2及其后续读取操作执行前，保证store1的写入对其他处理器可见</li>
<li>避免 <code>volatile</code> 写，与后面可能有的 <code>volatile</code> 读 &#x2F; 写操作<strong>重排序</strong>。</li>
</ul>
</li>
</ul>
<p><strong>单例模式：</strong></p>
<ol>
<li><p>分配空间</p>
</li>
<li><p>初始化</p>
</li>
<li><p>赋值</p>
</li>
<li><p>volatile：（实例）不允许初始化阶段步骤 2、3 发生重排序。</p>
</li>
<li><p>类初始化：（类静态）允许初始化阶段步骤 2、3 发生重排序，但是不允许其他线程“看到”这个重排序。</p>
</li>
</ol>
<p><strong>lock前缀指令相当于一个内存屏障</strong></p>
<ol>
<li>确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li>
<li><strong>强制将对缓存的修改操作立即写入主存</strong>，利用缓存一致性机制，并且缓存一致性机制会阻止同时修改由两个以上CPU缓存的内存区域数据；</li>
<li>如果是写操作，它会导致其他CPU中对应的缓存行无效。</li>
</ol>
<ul>
<li>数据依赖性：若多个操作同时访问一个变量，且这两个操作有一个为写操作，则操作之间存在数据依赖性</li>
<li>as-is-serial ：无论如何重排序，查询执行结果不能变</li>
</ul>
<p>重排序对多线程的影响</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread A</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;  	--<span class="type">a1</span></span><br><span class="line"><span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;	--a2</span><br><span class="line"><span class="comment">//a1,a2可重排序</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread B</span><br><span class="line"><span class="title function_">if</span><span class="params">( flag )</span>			--b1</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a*a;	 --b2</span><br></pre></td></tr></table></figure>

<p>若a重排序，先a2,后a1。</p>
<p>执行顺序可能：a2  —&gt; b1   –&gt;  b2(a的数值不对)  – &gt;  a1; 此时a的数值可能不是1。</p>
<p>程序运行错误</p>
<ul>
<li>顺序一致性：如果程序是正确同步的，程序的执行将具有顺序一致性，程序执行的结果可以确定<ol>
<li>一个线程中的所有操作必须按照程序的顺序来执行</li>
<li>不管线程是否同步，所有线程都只能看到一个单一的操作执行顺序，每个操作都原子执行且立刻对所有线程可见。</li>
</ol>
</li>
</ul>
<p>JMM:所有线程看到的执行顺序可能不一致，写操作缓存到本地内存中时，仅对本线程可见，刷新到主内存时，才对其他线程可见。</p>
<ul>
<li>happens-before：正确同步的多线程执行结果不会改变。<ul>
<li>会改变重新执行结果的重排序（单线程）：禁止</li>
<li>不会改变（单线程）：不做要求，即可以</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0000020068e17f01:   lock cmpxchg qword ptr [rdi],rbx</span><br><span class="line">0x0000020068e17f06:   je      20068e17f1fh</span><br><span class="line">0x0000020068e17f0c:   sub     rax,rsp</span><br><span class="line">0x0000020068e17f0f:   and     rax,0fffffffffffff007h</span><br><span class="line">0x0000020068e17f16:   mov     qword ptr [rbx],rax</span><br><span class="line">0x0000020068e17f19:   jne     20068e1818bh                ;*monitorenter &#123;reexecute=0 rethrow=0 return_oop=0&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  0x0000020068e17f6d:   lock cmpxchg qword ptr [rdi],r9</span><br><span class="line">0x0000020068e17f72:   jne     20068e1819eh                ;*monitorexit &#123;reexecute=0 rethrow=0 return_oop=0&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ff3e5:   lock add dword ptr [rsp+0ffffffffffffffc0h],0h</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>并发</title>
    <url>/2020/04/30/java/concurrent/concurrent/</url>
    <content><![CDATA[<h1 id="并发编程的挑战"><a href="#并发编程的挑战" class="headerlink" title="并发编程的挑战"></a>并发编程的挑战</h1><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>解决方法</p>
<ul>
<li>无锁并发编程</li>
<li>CAS算法</li>
<li>使用最小线程</li>
<li>协程</li>
</ul>
<span id="more"></span>

<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>避免的方法：</p>
<ul>
<li>避免一个线程多个锁，多个资源</li>
</ul>
<h2 id="资源限制的挑战"><a href="#资源限制的挑战" class="headerlink" title="资源限制的挑战"></a>资源限制的挑战</h2><h1 id="java并发底层原理"><a href="#java并发底层原理" class="headerlink" title="java并发底层原理"></a>java并发底层原理</h1><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile底层原理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 对volatile类型变量的读写</span><br><span class="line"> volatile i = 1; 锁的指令，空指令，给地址数+0---锁总线</span><br><span class="line">0x00000215ca711760:   lock add dword ptr [rsp+0ffffffffffffffc0h],0h</span><br><span class="line">                                                            ;*putstatic i &#123;reexecute=0 rethrow=0 return_oop=0&#125;</span><br><span class="line">                                                            ; - Demo.JITDemo::n@1 (line 19)</span><br></pre></td></tr></table></figure>

<p>cpu的汇编指令 lock：将本处理器的缓存写入内存，同时引起其他处理器的无效化其缓存。</p>
<h3 id="volatile的使用优化"><a href="#volatile的使用优化" class="headerlink" title="volatile的使用优化"></a>volatile的使用优化</h3><p>追加字节优化性能：高速缓存行固定，eg：64字节，2个32的volatile填充到同一缓存行。读取其中一个32的时候，锁两个，另一个的读取会等待直到能够读取。</p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>锁静态方法：锁是类的class对象</p>
<p>锁普通方法：实例对象</p>
<p>同步方法块：括号里的对象</p>
<p>对象头</p>
<p>锁升级与对比</p>
<h2 id="原子操作的实现原理"><a href="#原子操作的实现原理" class="headerlink" title="原子操作的实现原理"></a>原子操作的实现原理</h2><p>处理器：</p>
<ul>
<li>总线锁</li>
<li>缓存锁</li>
</ul>
<p>java：</p>
<ul>
<li>锁</li>
<li>循环CAS：<ul>
<li>ABA问题，AtomicStampedReference<V>类增加标志</li>
<li>循环占cpu</li>
<li>只能保证一个原子的共享操作</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>synchonized锁升级</title>
    <url>/2020/04/30/java/concurrent/synchonized%E9%94%81/</url>
    <content><![CDATA[<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>对象头：包含两类信息。</p>
<span id="more"></span>

<blockquote>
<ol>
<li>Mark Word –对象自身的运行时数据：哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳。</li>
</ol>
<p>与对象自身定义的数据无关的额外存储成本，动态的数据结构。</p>
<ol start="2">
<li>类型指针：对象指向它的类型元数据的指针。 —– 不一定由<br> 类型指针表明该对象是哪个类的实例。 查对象元数据不一定经过该对象，<br> 数组对象，记录数组长度的数据—–如果数组长度确定<br>      数组长度不定—无法通过元数据信息推断数组大小。</li>
</ol>
</blockquote>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/MarkWord64%E4%BD%8D%E5%AF%B9%E8%B1%A1%E5%A4%B4.png" alt="MarkWord64位对象头"></p>
<p><a href="https://blog.csdn.net/liudun_cool/article/details/86286872">图片来源</a></p>
<h2 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h2><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><ul>
<li><p>获取</p>
<ul>
<li>测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。<ul>
<li>如果测试成功，表示线程已经获得了锁。</li>
<li>如果测试失败，则需要再测试一下Mark Word中偏向锁的标志是否设置成1，<ul>
<li>如果没有设置，使用CAS竞争锁，轻量级锁&#x2F;重量级锁</li>
<li>如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>撤销：<strong>等到竞争出现才释放锁</strong>的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。</p>
<ul>
<li>在全局安全点，暂停拥有偏向锁的线程。检查该线程是否存活<ul>
<li>存活：mark word的epoch值，<ul>
<li>若足够大，升级<strong>轻量级锁</strong>；</li>
<li>不够大，该线程是否还竞争锁</li>
<li>竞争：<strong>轻量级锁</strong></li>
<li>不竞争：线程二<strong>获得偏向锁</strong></li>
</ul>
</li>
<li>不存活：对象头设置为<strong>无锁状态</strong></li>
</ul>
</li>
<li>撤销结果：重新偏向，无锁，轻量级锁。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/java%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E8%8E%B7%E5%BE%97%E5%92%8C%E6%92%A4%E9%94%80.png" alt="java偏向锁的获得和撤销"></p>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/java%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E6%92%A4%E9%94%80.png" alt="java偏向锁的撤销"></p>
</li>
</ul>
<p>图片来源:<a href="https://blog.csdn.net/zhao_miao/article/details/84500771">csdn_zhao_miao</a></p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><ul>
<li><p>加锁：同步对象未被锁定，Mark Word锁标志位01</p>
<ul>
<li><p>虚拟机在当前栈帧建立一个锁记录Lock Record空间，用于存储对象目前的Mark Word拷贝。</p>
</li>
<li><p>CAS，把对象的Mark Word更新为指向Lock Record的指针</p>
<ul>
<li><p>更新成功：当前线程拥有锁，并把对象Mark Word锁标志位设置为00，处于轻量级锁定状态。</p>
</li>
<li><p>更新失败：说明当前有竞争，检查Mark Word是否指向当前线程的栈帧，</p>
<ul>
<li>指向当前线程的栈帧：拥有对象锁，执行代码。</li>
<li>不指向：这个锁对象已经被其他线程抢占了。自旋CAS获取锁</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>解锁：CAS操作完成。</p>
<ul>
<li>若对象的Mark Word扔指向线程的锁记录，用CAS把对象当前的Mark Word和线程中锁记录存储的数据替换，<ul>
<li>替换成功，ok</li>
<li>失败：有其他线程在尝试获取，释放锁的时候，唤醒被挂起的线程。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如果多个线程（&gt;2）竞争同一个轻量级锁，锁膨胀为重量级锁。</p>
<p>轻量级：(内存存储，小端存储，低位在前)</p>
<p>开始：101,开启偏向锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000</span>-<span class="number">101</span>- <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">5</span>)		</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">94</span> <span class="number">20</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">10010100</span> <span class="number">00100000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">8340</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> <span class="type">bytes</span> <span class="variable">external</span> <span class="operator">=</span> <span class="number">4</span> bytes total</span><br></pre></td></tr></table></figure>



<p>三个线程：010,膨胀为重量锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hellojava.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">82</span> <span class="number">50</span> d8 7a (<span class="number">10000010</span> <span class="number">01010000</span> <span class="number">11011000</span> <span class="number">01111010</span>) (<span class="number">2060996738</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           a4 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">10100100</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">420</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">94</span> <span class="number">20</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">10010100</span> <span class="number">00100000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">8340</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> <span class="type">bytes</span> <span class="variable">external</span> <span class="operator">=</span> <span class="number">4</span> bytes total</span><br></pre></td></tr></table></figure>

<p>两个线程：010,轻量级锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ellojava.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">02</span> <span class="number">56</span> <span class="number">70</span> f7 (<span class="number">00000010</span> <span class="number">01010110</span> <span class="number">01110000</span> <span class="number">11110111</span>) (-<span class="number">143632894</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">93</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">10010011</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">403</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">94</span> <span class="number">20</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">10010100</span> <span class="number">00100000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">8340</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> <span class="type">bytes</span> <span class="variable">external</span> <span class="operator">=</span> <span class="number">4</span> bytes total</span><br></pre></td></tr></table></figure>

<p>一个线程：101,开启偏向锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hellojava.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">05</span> f0 <span class="number">00</span> <span class="number">60</span> (<span class="number">00000101</span> <span class="number">11110000</span> <span class="number">00000000</span> <span class="number">01100000</span>) (<span class="number">1610674181</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">6f</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">01101111</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">367</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">94</span> <span class="number">20</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">10010100</span> <span class="number">00100000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">8340</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> <span class="type">bytes</span> <span class="variable">external</span> <span class="operator">=</span> <span class="number">4</span> bytes total</span><br></pre></td></tr></table></figure>

<p>不开启偏向锁：001</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ava.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">94</span> <span class="number">20</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">10010100</span> <span class="number">00100000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">8340</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> <span class="type">bytes</span> <span class="variable">external</span> <span class="operator">=</span> <span class="number">4</span> bytes total</span><br></pre></td></tr></table></figure>

<h3 id="重量级锁-：monitor对象"><a href="#重量级锁-：monitor对象" class="headerlink" title="重量级锁 ：monitor对象"></a>重量级锁 ：monitor对象</h3><p>底层原理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字节码</span></span><br><span class="line">monitorenter<span class="comment">//同步代码块开始处，尝试获取该monitor对象，即尝试获取锁</span></span><br><span class="line">monitorexit<span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p>一个monitor被持有后，处于锁定状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">synchronized   锁的CAS操作</span><br><span class="line">  0x00000215ca711314:   lock cmpxchg qword ptr [rdi],rsi</span><br><span class="line">  0x00000215ca711319:   jne     215ca71135dh                ;*return &#123;reexecute=0 rethrow=0 return_oop=0&#125;</span><br><span class="line">                                                            ; - Demo.JITDemo::m@0 (line 17)     </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0000020068e17f01:   lock cmpxchg qword ptr [rdi],rbx</span><br><span class="line">0x0000020068e17f06:   je      20068e17f1fh</span><br><span class="line">0x0000020068e17f0c:   sub     rax,rsp</span><br><span class="line">0x0000020068e17f0f:   and     rax,0fffffffffffff007h</span><br><span class="line">0x0000020068e17f16:   mov     qword ptr [rbx],rax</span><br><span class="line">0x0000020068e17f19:   jne     20068e1818bh                ;*monitorenter &#123;reexecute=0 rethrow=0 return_oop=0&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  0x0000020068e17f6d:   lock cmpxchg qword ptr [rdi],r9</span><br><span class="line">0x0000020068e17f72:   jne     20068e1819eh                ;*monitorexit &#123;reexecute=0 rethrow=0 return_oop=0&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>nio</title>
    <url>/2020/04/23/java/NIO/</url>
    <content><![CDATA[<h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><span id="more"></span>

<p>NIO: 通道+缓冲区。</p>
<ul>
<li>通道：打开到IO设备的连接（文件，套接字）</li>
<li>缓冲区：用于容纳数据的缓冲区</li>
</ul>
<p>通道连接，利用缓冲区进行数据的交换</p>
<h1 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h1><h2 id="accept：轮询"><a href="#accept：轮询" class="headerlink" title="accept：轮询"></a>accept：轮询</h2><p>accept阻塞：</p>
<p>ServerSocket.accept  —&gt; 	 implAccept(s);		–&gt;	customImplAccept(si);	–&gt;	implAccept(si);	–&gt;	accept(si); (java.net.AbstractPlainSocketImpl#accept)	–&gt;		socketAccept(s);(java.net.PlainSocketImpl#socketAccept)	–&gt;	</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java.net.PlainSocketImpl#socketAccept</span></span><br><span class="line">	<span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) &#123;  <span class="comment">//是否设置延时，来避免阻塞</span></span><br><span class="line">        newfd = accept0(nativefd, isaa); <span class="comment">// 阻塞在这里</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//timeout值大于0的话，则程序会在等到我们设置的时间后返回</span></span><br><span class="line">        configureBlocking(nativefd, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            waitForNewConnection(nativefd, timeout);<span class="comment">//设置超时信息</span></span><br><span class="line">            newfd = accept0(nativefd, isaa);  <span class="comment">//超时返回，</span></span><br><span class="line">            <span class="keyword">if</span> (newfd != -<span class="number">1</span>) &#123;</span><br><span class="line">                configureBlocking(newfd, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            configureBlocking(nativefd, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    accept0: <span class="keyword">native</span>方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>accept0： 与操作系统交互来实现监听指定端口上是否有客户端接入，在没有客户端接入的时候会一直处于阻塞状态，所以造成了我们程序级别的accept方法阻塞。</p>
<blockquote>
<p> accept0的阻塞无法避免，accept的阻塞可以避免，</p>
</blockquote>
<p> serverSocket.setSoTimeout(1000);设置timeout时间，这样的话调用accept方法的时候每隔1s他就会被唤醒一次，而不再是一直阻塞到，等待有客户端接入。</p>
<p>timeout：serversocket的 socketimpl 变量 的  属性</p>
<p>超时accept  ：SocketTimeoutException异常，在异常的处理中就可以执行其他操作了</p>
<h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line"> getInputStream():创建了一个SocketInputStream对象，会将当前AbstractPlainSocketImpl对象传进去</span><br></pre></td></tr></table></figure>

<p>read	–&gt;	socketRead(fd, b, off, length, timeout);	–&gt;	socketRead0(fd, b, off, len, timeout);</p>
<p>timeout：是我们socket 的 socketimpl 变量 的  属性</p>
<p>serverSocket.setSoTimeout(1000)	</p>
<p>每隔1s会去唤醒我们的read操作，没有读到数据的话就会抛出异常，在异常的处理中，就可以执行其他操作</p>
<p>改善accept和read方法带来的阻塞现象，所以引入了<code>Channel</code>和<code>Buffer</code>的概念</p>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java.net.ServerSocket，new的时候，传port，执行bind</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(SocketAddress endpoint, <span class="type">int</span> backlog)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (isClosed())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SocketException</span>(<span class="string">&quot;Socket is closed&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!oldImpl &amp;&amp; isBound())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SocketException</span>(<span class="string">&quot;Already bound&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (endpoint == <span class="literal">null</span>)</span><br><span class="line">            endpoint = <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!(endpoint <span class="keyword">instanceof</span> InetSocketAddress))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unsupported address type&quot;</span>);</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">epoint</span> <span class="operator">=</span> (InetSocketAddress) endpoint;</span><br><span class="line">        <span class="keyword">if</span> (epoint.isUnresolved())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SocketException</span>(<span class="string">&quot;Unresolved address&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (backlog &lt; <span class="number">1</span>)</span><br><span class="line">          backlog = <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SecurityManager</span> <span class="variable">security</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">            <span class="keyword">if</span> (security != <span class="literal">null</span>)</span><br><span class="line">                security.checkListen(epoint.getPort());</span><br><span class="line">            getImpl().bind(epoint.getAddress(), epoint.getPort()); <span class="comment">//重点！！</span></span><br><span class="line">            getImpl().listen(backlog);</span><br><span class="line">            bound = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(SecurityException e) &#123;</span><br><span class="line">            bound = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            bound = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//java.net.ServerSocket#getImpl</span></span><br><span class="line">SocketImpl <span class="title function_">getImpl</span><span class="params">()</span> <span class="keyword">throws</span> SocketException &#123;</span><br><span class="line">    <span class="keyword">if</span> (!created)</span><br><span class="line">        createImpl();</span><br><span class="line">    <span class="keyword">return</span> impl;</span><br><span class="line">&#125;</span><br><span class="line"> createImpl();`--&gt;	setImpl();,    impl.create(<span class="literal">true</span>)(java.net.AbstractPlainSocketImpl#create);	--&gt;	socketCreate</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java.net.AbstractPlainSocketImpl#socketCreate</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">socketCreate</span><span class="params">(<span class="type">boolean</span> stream)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SocketException</span>(<span class="string">&quot;Socket closed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">newfd</span> <span class="operator">=</span> socket0(stream);<span class="comment">//返回文件描述符，socket被创建</span></span><br><span class="line"></span><br><span class="line">    fdAccess.set(fd, newfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="1-缓冲区"><a href="#1-缓冲区" class="headerlink" title="1 缓冲区"></a>1 缓冲区</h1><p>不同的数据类型有不同的缓冲区</p>
<p>获取缓冲区：</p>
<ul>
<li><p>allocate（）方法：内存开销是在JVM</p>
</li>
<li><p>allocateDirect（）方法：分配方式产生的开销在JVM之外，也就是系统级的内存分配。</p>
</li>
<li><p>put：存数据到缓冲区</p>
</li>
<li><p>get：获取缓冲区数据</p>
</li>
</ul>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>核心数据（4）：</p>
<ul>
<li>capacity：缓冲区最大存储容量，一旦设定无法改变</li>
<li>limit：界限，缓冲区中可操作数据大小</li>
<li>position：位置，缓冲区正在操作数据的位置<ul>
<li>position &lt; limit &lt; capacity</li>
</ul>
</li>
<li>mark：记录当前position的位置，reset（）可以恢复到mark的位置</li>
</ul>
<h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h3><p>flip:切换模式，读&#x2F;写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Buffer <span class="title function_">flip</span><span class="params">()</span> &#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>rewind：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Buffer <span class="title function_">rewind</span><span class="params">()</span> &#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>clear:指针初始化，内容不变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Buffer <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mark and reset</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Buffer <span class="title function_">mark</span><span class="params">()</span> &#123;</span><br><span class="line">        mark = position;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Buffer <span class="title function_">reset</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> mark;</span><br><span class="line">        <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidMarkException</span>();</span><br><span class="line">        position = m;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="直接-非直接-缓冲区"><a href="#直接-非直接-缓冲区" class="headerlink" title="直接&#x2F;非直接 缓冲区"></a>直接&#x2F;非直接 缓冲区</h2><ul>
<li>非直接缓冲区：allocate()方法分配缓冲区，缓冲区在JVM的内存中<ul>
<li>java程序运行在JVM中，用户态</li>
<li><strong>需要</strong>经过一个：copy的阶段的(从内核空间copy到用户空间)</li>
</ul>
</li>
<li>直接缓冲区：allocateDirect() 方法分配缓冲区，缓冲区建立在物理内存中<ul>
<li>物理内存中申请了一块空间，这块空间映射到内核地址空间和用户地址空间</li>
<li><strong>不需要</strong>经过copy阶段，内核与用户空间都可以访问</li>
<li>创建方式：<ol>
<li>allocateDirect() 方法分配直接缓冲区</li>
<li>FileChannel上调用<code>map()</code>方法，将文件直接映射到内存中创建</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>内存映射文件</strong>（Memory-mapped file），或称“文件映射”、“映射文件”，是一段虚内存逐字节对应于一个文件或类文件的资源，使得应用程序处理映射部分如同访问主内存。</p>
<h1 id="2-通道"><a href="#2-通道" class="headerlink" title="2. 通道"></a>2. 通道</h1><p>java,nio.channels.Channel 接口</p>
<ul>
<li>FileChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
<li>DatagramChannel</li>
</ul>
<p>获取通道：</p>
<ul>
<li>getChannel（）方法<ul>
<li>本地IO<ul>
<li>FileInputStream，FileOutputStream</li>
<li>RandomAccessFile</li>
</ul>
</li>
<li>网络IO<ul>
<li>Socket，serverSocket，DatagramSocket</li>
</ul>
</li>
</ul>
</li>
<li>NIO.0对各个通道提供静态open（）</li>
<li>File工具类的newByteChannel（）</li>
</ul>
<h3 id="基本的通道使用"><a href="#基本的通道使用" class="headerlink" title="基本的通道使用"></a>基本的通道使用</h3><h4 id="流-通道"><a href="#流-通道" class="headerlink" title="流+通道"></a>流+通道</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通道，非直接缓冲区，文件复制</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">		<span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path+<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">		<span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(path+<span class="string">&quot;2.txt&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//1.get channel</span></span><br><span class="line">		<span class="type">FileChannel</span> <span class="variable">finChannel</span> <span class="operator">=</span> in.getChannel();</span><br><span class="line">		<span class="type">FileChannel</span> <span class="variable">foutChannel</span> <span class="operator">=</span> out.getChannel();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.分配指定大小的缓冲区,默认初始化，写模式</span></span><br><span class="line">		<span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//3.将通道的数据存入通道，</span></span><br><span class="line">		<span class="keyword">while</span>( finChannel.read(byteBuffer) != -<span class="number">1</span> ) &#123;<span class="comment">//读数据到bytebuffer（内存中）</span></span><br><span class="line">			byteBuffer.flip();<span class="comment">//切换读数据模式</span></span><br><span class="line">			foutChannel.write(byteBuffer);<span class="comment">//4.缓冲区数据写入通道</span></span><br><span class="line">			byteBuffer.clear();</span><br><span class="line">		&#125;</span><br><span class="line">		finChannel.close();</span><br><span class="line">		foutChannel.close();</span><br><span class="line">		in.close();</span><br><span class="line">		out.close();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="直接缓冲区："><a href="#直接缓冲区：" class="headerlink" title="直接缓冲区："></a>直接缓冲区：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接缓冲区，直接操作缓冲区</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFileDirect</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">		<span class="type">FileChannel</span> <span class="variable">fin</span> <span class="operator">=</span> FileChannel.open(Paths.get(path+<span class="string">&quot;1.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">		<span class="type">FileChannel</span> <span class="variable">fout</span> <span class="operator">=</span> FileChannel.open(Paths.get(path+<span class="string">&quot;3.txt&quot;</span>), StandardOpenOption.WRITE,StandardOpenOption.READ,StandardOpenOption.CREATE);</span><br><span class="line">		<span class="comment">//内存映射文件</span></span><br><span class="line">		<span class="type">MappedByteBuffer</span> <span class="variable">inmapBuffer</span> <span class="operator">=</span> fin.map(MapMode.READ_ONLY, <span class="number">0</span>, fin.size());</span><br><span class="line">		<span class="type">MappedByteBuffer</span> <span class="variable">outmapBuffer</span> <span class="operator">=</span> fout.map(MapMode.READ_WRITE, <span class="number">0</span>, fin.size());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//直接对缓冲区对数据进行读写</span></span><br><span class="line">		<span class="type">byte</span>[] dst = <span class="keyword">new</span> <span class="title class_">byte</span>[inmapBuffer.limit()];</span><br><span class="line">		inmapBuffer.get(dst);	</span><br><span class="line">		outmapBuffer.put(dst);</span><br><span class="line">        </span><br><span class="line">		</span><br><span class="line">		fin.close();</span><br><span class="line">		fout.close();				</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="直接缓冲区-transfer"><a href="#直接缓冲区-transfer" class="headerlink" title="直接缓冲区+transfer"></a>直接缓冲区+transfer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFileTransfer</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">	<span class="type">FileChannel</span> <span class="variable">fin</span> <span class="operator">=</span> FileChannel.open(Paths.get(path+<span class="string">&quot;1.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">	<span class="type">FileChannel</span> <span class="variable">fout</span> <span class="operator">=</span> FileChannel.open(Paths.get(path+<span class="string">&quot;3.txt&quot;</span>), StandardOpenOption.WRITE,StandardOpenOption.READ,StandardOpenOption.CREATE);</span><br><span class="line">	</span><br><span class="line"><span class="comment">//	fin.transferTo(0, fin.size(), fout);</span></span><br><span class="line">	fout.transferFrom(fin, <span class="number">0</span>,fin.size());</span><br><span class="line">	</span><br><span class="line">	fin.close();</span><br><span class="line">	fout.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分散（Scatter）与聚集（Gather）"><a href="#分散（Scatter）与聚集（Gather）" class="headerlink" title="分散（Scatter）与聚集（Gather）"></a>分散（Scatter）与聚集（Gather）</h2><ul>
<li>分散读取：Scattering reads：将通道中的数据分散到多个缓冲区中</li>
<li>聚集写入 Gathering writing ：将多个buffer的数据聚集到Channel</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	<span class="type">RandomAccessFile</span> <span class="variable">ran</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(path+<span class="string">&quot;1.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.获取通道</span></span><br><span class="line">	<span class="type">FileChannel</span> <span class="variable">channel1</span> <span class="operator">=</span> ran.getChannel();</span><br><span class="line">	<span class="comment">//2.分配缓冲区</span></span><br><span class="line">	<span class="type">ByteBuffer</span> <span class="variable">buf1</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">	<span class="type">ByteBuffer</span> <span class="variable">buf2</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">200</span>);</span><br><span class="line">	<span class="comment">//3.分散读取</span></span><br><span class="line">	ByteBuffer [] bufs = &#123;buf1,buf2&#125;;</span><br><span class="line">	channel1.read(bufs);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>( ByteBuffer byteBuffer : bufs) &#123;</span><br><span class="line">		byteBuffer.flip();</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bufs[<span class="number">0</span>].array()));</span><br><span class="line">	System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line">	System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bufs[<span class="number">1</span>].array()));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//聚集写入</span></span><br><span class="line">	<span class="type">RandomAccessFile</span> <span class="variable">ran2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(path+<span class="string">&quot;2.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">	<span class="type">FileChannel</span> <span class="variable">channel2</span> <span class="operator">=</span> ran2.getChannel();</span><br><span class="line">	channel2.write(bufs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="字符集-Charset"><a href="#字符集-Charset" class="headerlink" title="字符集 Charset"></a>字符集 Charset</h2><ul>
<li>编码：字符串—字节数组</li>
<li>解码：字节数组—字符串</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">CharsetDE</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">	<span class="type">Charset</span> <span class="variable">cs</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">	<span class="comment">//获得编码器</span></span><br><span class="line">	<span class="type">CharsetEncoder</span> <span class="variable">en</span> <span class="operator">=</span> cs.newEncoder();</span><br><span class="line">	<span class="comment">//decoder</span></span><br><span class="line">	<span class="type">CharsetDecoder</span> <span class="variable">de</span> <span class="operator">=</span> cs.newDecoder();</span><br><span class="line">	</span><br><span class="line">	<span class="type">CharBuffer</span> <span class="variable">cbuffer</span> <span class="operator">=</span> CharBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">	</span><br><span class="line">	cbuffer.put(<span class="string">&quot;hello zifuji&quot;</span>);</span><br><span class="line">	cbuffer.flip();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//编码</span></span><br><span class="line">	<span class="type">ByteBuffer</span> <span class="variable">bBuffer</span> <span class="operator">=</span> en.encode(cbuffer);</span><br><span class="line">	<span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; bBuffer.limit();i++) &#123;</span><br><span class="line">		System.out.println(bBuffer.get());</span><br><span class="line">	&#125;</span><br><span class="line">	bBuffer.flip();</span><br><span class="line">	<span class="comment">//jiema</span></span><br><span class="line">	<span class="type">CharBuffer</span> <span class="variable">cBuffer2</span> <span class="operator">=</span> de.decode(bBuffer);</span><br><span class="line">	System.out.println(cBuffer2.toString());</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<h1 id="3-IO模型理解"><a href="#3-IO模型理解" class="headerlink" title="3 IO模型理解"></a>3 IO模型理解</h1><ul>
<li><strong>阻塞I&#x2F;O</strong>：recvfrom：<strong>一直等待</strong> ，其系统调用直到数据包到达且<strong>被复制到应用进程的缓冲区中或者发生错误时才返回</strong>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/java/nio/unix%E9%98%BB%E5%A1%9E%E5%BC%8FIO.png" alt="unix阻塞式IO"></p>
<ul>
<li><strong>非阻塞I&#x2F;O</strong>：<code>recvfrom</code>：<strong>轮询</strong>。从应用层到内核的时候，如果没有数据就<strong>直接返回</strong>一个EWOULDBLOCK错误，一般都对非阻塞I&#x2F;O模型<strong>进行轮询检查这个状态</strong>，看内核是不是有数据到来。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/java/nio/unix%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8FIO.png" alt="unix非阻塞式IO"></p>
<ul>
<li><strong>I&#x2F;O多路复用</strong>：<strong>文件描述符</strong>，调用<code>select/poll/epoll/pselect</code>其中一个函数，<strong>传入多个文件描述符</strong>，如果有一个文件描述符<strong>就绪，则返回</strong>，否则阻塞直到超时。<ul>
<li><strong>能处理更多的连接</strong></li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/java/nio/IO%E5%A4%8D%E7%94%A8.png" alt="IO复用"></p>
<ul>
<li>信号驱动I&#x2F;O</li>
</ul>
<p><img src="D:%5C31577%5C%E6%A1%8C%E9%9D%A2%5C%E7%85%A7%E7%89%87%5CNIO%5CUnixIO%5Cunix%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8%E5%BC%8FIO.png" alt="unix信号驱动式IO"></p>
<ul>
<li>异步I&#x2F;O</li>
</ul>
<p><img src="D:%5C31577%5C%E6%A1%8C%E9%9D%A2%5C%E7%85%A7%E7%89%87%5CNIO%5CUnixIO%5Cunix%E5%BC%82%E6%AD%A5IO.png" alt="unix异步IO"></p>
<p>比较：</p>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/java/nio/UnixIO%E6%AF%94%E8%BE%83.png" alt="UnixIO比较"></p>
<h2 id="非阻塞时通信"><a href="#非阻塞时通信" class="headerlink" title="非阻塞时通信"></a>非阻塞时通信</h2><p>selector：SelectableChannel的多路复用器，用于监控SelectableChannel的IO情况</p>
<h1 id="2-NIO"><a href="#2-NIO" class="headerlink" title="2 NIO"></a>2 NIO</h1><p>nio的<strong>核心要素</strong>有：</p>
<ul>
<li>Buffer缓冲区：</li>
<li>Channel通道：</li>
<li>Selector选择器：管理状态，是否在等待任务，是否在接收信息，是否在输出信息<ul>
<li>SelectionKey：状态标签</li>
</ul>
</li>
</ul>
<h2 id="2-1-Channel"><a href="#2-1-Channel" class="headerlink" title="2.1 Channel"></a>2.1 Channel</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Channel</span> <span class="keyword">extends</span> <span class="title class_">Closeable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOpen</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个线程IO时</p>
<ul>
<li>另一个线程可以调用该Channel的close方法。导致进行IO操作的那个阻塞线程会收到一个<code>AsynchronousCloseException</code>异常。</li>
<li>另一个线程可能会调用被阻塞线程的<code>interrupt</code>（<code>Thread#interrupt()</code>），从而导致Channel关闭，那么这个阻塞的线程应该要收到<code>ClosedByInterruptException</code>异常，同时将中断状态设定到该阻塞线程之上。</li>
</ul>
<h3 id="2-1-1-注册-register"><a href="#2-1-1-注册-register" class="headerlink" title="2.1.1 注册 register"></a>2.1.1 注册 register</h3><p>channel：register() 方法 ，用来注册到selector，将channel和<code>selector</code>绑定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.spi.AbstractSelectableChannel#register</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title function_">register</span><span class="params">(Selector sel, <span class="type">int</span> ops, Object att)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">k</span> <span class="operator">=</span> findKey(sel);</span><br><span class="line">                <span class="keyword">if</span> (k != <span class="literal">null</span>) &#123;<span class="comment">//多次注册，仅有一个key</span></span><br><span class="line">                    k.attach(att);</span><br><span class="line">                    k.interestOps(ops);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// New registration</span></span><br><span class="line">                    k = ((AbstractSelector)sel).register(<span class="built_in">this</span>, ops, att);<span class="comment">//注册到selector中</span></span><br><span class="line"> <span class="comment">//每个keys中存储了channel，selector信息</span></span><br><span class="line">                    addKey(k);<span class="comment">//在自身的keys列表中增加</span></span><br><span class="line">                &#125;</span><br><span class="line">    ...</span><br><span class="line"> <span class="comment">//java.nio.channels.spi.AbstractSelectableChannel#addKey</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addKey</span><span class="params">(SelectionKey k)</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> Thread.holdsLock(keyLock);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ((keys != <span class="literal">null</span>) &amp;&amp; (keyCount &lt; keys.length)) &#123;</span><br><span class="line">            <span class="comment">// Find empty element of key array</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; keys.length; i++)</span><br><span class="line">                <span class="keyword">if</span> (keys[i] == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (keys == <span class="literal">null</span>) &#123;</span><br><span class="line">            keys = <span class="keyword">new</span> <span class="title class_">SelectionKey</span>[<span class="number">2</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Grow key array</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> keys.length * <span class="number">2</span>;</span><br><span class="line">            SelectionKey[] ks =  <span class="keyword">new</span> <span class="title class_">SelectionKey</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; keys.length; i++)</span><br><span class="line">                ks[i] = keys[i];</span><br><span class="line">            keys = ks;</span><br><span class="line">            i = keyCount;</span><br><span class="line">        &#125;</span><br><span class="line">        keys[i] = k;<span class="comment">//把key加入列表</span></span><br><span class="line">        keyCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>一旦注册到<code>Selector</code>上，Channel将一直保持注册直到其<strong>被解除注册</strong>。</p>
<h3 id="2-1-2-cancel：channel没有提供解除注册方法"><a href="#2-1-2-cancel：channel没有提供解除注册方法" class="headerlink" title="2.1.2 cancel：channel没有提供解除注册方法"></a>2.1.2 cancel：channel没有提供解除注册方法</h3><p><code>SelectionKey.cancel()</code>方法来显式的取消key。然后在<code>Selector</code>下一次选择操作期间进行对Channel的取消注册。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractSelectionKey:    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                ((AbstractSelector)selector()).cancel(<span class="built_in">this</span>);<span class="comment">//还是调用Selector的cancel方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.channels.spi.AbstractSelector#cancel</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">(SelectionKey k)</span> &#123;                       </span><br><span class="line">        <span class="keyword">synchronized</span> (cancelledKeys) &#123;</span><br><span class="line">            cancelledKeys.add(k);<span class="comment">//将要删除的key加入到删除队列中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.SelectorImpl#select(long)，select的时候，检查是否存在需要删除的key</span></span><br><span class="line"> select	--&gt;		lockAndDoSelect	--&gt;		doSelect(action, timeout);</span><br><span class="line"></span><br><span class="line"><span class="comment">//sun.nio.ch.WindowsSelectorImpl#doSelect</span></span><br><span class="line"> doSelect	--&gt;	processDeregisterQueue();</span><br><span class="line"><span class="comment">//sun.nio.ch.SelectorImpl#processDeregisterQueue</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">processDeregisterQueue</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;<span class="comment">//执行删除队列。</span></span><br><span class="line">        <span class="keyword">assert</span> Thread.holdsLock(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">assert</span> Thread.holdsLock(publicSelectedKeys);</span><br><span class="line"></span><br><span class="line">        Set&lt;SelectionKey&gt; cks = cancelledKeys();</span><br><span class="line">        <span class="keyword">synchronized</span> (cks) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cks.isEmpty()) &#123;</span><br><span class="line">                Iterator&lt;SelectionKey&gt; i = cks.iterator();</span><br><span class="line">                <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKeyImpl</span> <span class="variable">ski</span> <span class="operator">=</span> (SelectionKeyImpl)i.next();</span><br><span class="line">                    i.remove();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// remove the key from the selector</span></span><br><span class="line">                    implDereg(ski);</span><br><span class="line"></span><br><span class="line">                    selectedKeys.remove(ski);</span><br><span class="line">                    keys.remove(ski);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// remove from channel&#x27;s key set</span></span><br><span class="line">                    deregister(ski);<span class="comment">//移除，从channel的列表中</span></span><br><span class="line"></span><br><span class="line">                    <span class="type">SelectableChannel</span> <span class="variable">ch</span> <span class="operator">=</span> ski.channel();</span><br><span class="line">                    <span class="keyword">if</span> (!ch.isOpen() &amp;&amp; !ch.isRegistered())</span><br><span class="line">                        ((SelChImpl)ch).kill();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-3-channel关闭："><a href="#2-1-3-channel关闭：" class="headerlink" title="2.1.3 channel关闭："></a>2.1.3 channel关闭：</h3><p>channe关闭的时候，隐式的取消关于这个Channel的所有的keys，通过调用k.cancel()函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.spi.AbstractInterruptibleChannel#close</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (closeLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (closed)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            closed = <span class="literal">true</span>;</span><br><span class="line">            implCloseChannel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//java.nio.channels.spi.AbstractSelectableChannel#implCloseChannel</span></span><br><span class="line">     <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">implCloseChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        implCloseSelectableChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clone keys to avoid calling cancel when holding keyLock</span></span><br><span class="line">        SelectionKey[] copyOfKeys = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (keyLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (keys != <span class="literal">null</span>) &#123;</span><br><span class="line">                copyOfKeys = keys.clone();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copyOfKeys != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (SelectionKey k : copyOfKeys) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k != <span class="literal">null</span>) &#123;</span><br><span class="line">                    k.cancel();   <span class="comment">// invalidate and adds key to cancelledKey set</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-1-4-selector-关闭："><a href="#2-1-4-selector-关闭：" class="headerlink" title="2.1.4 selector 关闭："></a>2.1.4 selector 关闭：</h3><p>如果<code>Selector</code>自身关闭掉，那么Channel也会被解除注册，同时代表Channel注册的key也将变得无效：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.spi.AbstractSelector#close</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">open</span> <span class="operator">=</span> selectorOpen.getAndSet(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (!open)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        implCloseSelector();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.SelectorImpl#implCloseSelector</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">implCloseSelector</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    wakeup();</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        implClose();</span><br><span class="line">        <span class="keyword">synchronized</span> (publicSelectedKeys) &#123;</span><br><span class="line">            <span class="comment">// Deregister channels</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; i = keys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKeyImpl</span> <span class="variable">ski</span> <span class="operator">=</span> (SelectionKeyImpl)i.next();</span><br><span class="line">                deregister(ski);<span class="comment">//解除注册，channel中移除key</span></span><br><span class="line">                <span class="type">SelectableChannel</span> <span class="variable">selch</span> <span class="operator">=</span> ski.channel();</span><br><span class="line">                <span class="keyword">if</span> (!selch.isOpen() &amp;&amp; !selch.isRegistered())</span><br><span class="line">                    ((SelChImpl)selch).kill();</span><br><span class="line">                selectedKeys.remove(ski);<span class="comment">//从selector的keys集合中移除</span></span><br><span class="line">                i.remove();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">assert</span> selectedKeys.isEmpty() &amp;&amp; keys.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><ul>
<li><p>继承了SelectableChannel类：channel就可以安全的由多个并发线程来使用</p>
</li>
<li><p>继承了<code>AbstractSelectableChannel</code>类：新创建的channel始终处于<strong>阻塞</strong>模式，</p>
</li>
</ul>
<p>与<code>Selector</code>的多路复用有关的操作需要基于<strong>非阻塞</strong>模式，在注册到<code>Selector</code>之前，须将<code>channel</code>置于非阻塞模式。</p>
<ul>
<li><p>阻塞模式下：在<code>Channel</code>上调用的每个I&#x2F;O操作都将阻塞，直到完成为止。 </p>
</li>
<li><p>在非阻塞模式下：I&#x2F;O操作永远不会阻塞，并且可以传输比请求的字节更少的字节，或者根本不传输任何字节。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">		<span class="comment">//1.获取通道</span></span><br><span class="line">		<span class="type">ServerSocketChannel</span> <span class="variable">ssChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//2.切换模式</span></span><br><span class="line">		ssChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">		<span class="comment">// 3. 绑定端口</span></span><br><span class="line">		ssChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9898</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">///4. 获取选择器</span></span><br><span class="line">		<span class="type">Selector</span> <span class="variable">sel</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"><span class="comment">//		System.out.println(sel.getClass().getName());</span></span><br><span class="line">		<span class="comment">//5.将通道注册到选择器,并指定位监听接收事件</span></span><br><span class="line">		ssChannel.register(sel, SelectionKey.OP_ACCEPT);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//6.轮询获取选择器上已经准备就绪的事件</span></span><br><span class="line">		<span class="keyword">while</span>( sel.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//7.获取当前选择器上所有注册的选择键，已就绪的监听事件</span></span><br><span class="line">			Iterator&lt;SelectionKey&gt; it = sel.selectedKeys().iterator();</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">while</span>( it.hasNext()) &#123;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//8. 获取准备就绪的事件</span></span><br><span class="line">				<span class="type">SelectionKey</span> <span class="variable">sk</span> <span class="operator">=</span> it.next();</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//9.判断是什么事件就绪</span></span><br><span class="line">				<span class="keyword">if</span>( sk.isAcceptable()) &#123;</span><br><span class="line">					</span><br><span class="line">				&#125;<span class="keyword">else</span> <span class="keyword">if</span>(sk.isReadable()) &#123;</span><br><span class="line">				&#125;</span><br><span class="line">				it.remove();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-1-5-支持socket"><a href="#2-1-5-支持socket" class="headerlink" title="2.1.5 支持socket"></a>2.1.5 支持socket</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NetworkChannel</span> <span class="keyword">extends</span> <span class="title class_">Channel</span>&#123;</span><br><span class="line">    NetworkChannel <span class="title function_">bind</span><span class="params">(SocketAddress local)</span> <span class="keyword">throws</span> IOException;<span class="comment">//将socket绑定到本地 SocketAddress上</span></span><br><span class="line"></span><br><span class="line">    SocketAddress <span class="title function_">getLocalAddress</span><span class="params">()</span> <span class="keyword">throws</span> IOException;<span class="comment">//返回socket绑定的地址</span></span><br><span class="line"></span><br><span class="line">    &lt;T&gt; NetworkChannel <span class="title function_">setOption</span><span class="params">(SocketOption&lt;T&gt; name, T value)</span> <span class="keyword">throws</span> IOException;<span class="comment">//设置socket支持的配置选项。</span></span><br><span class="line"></span><br><span class="line">    &lt;T&gt; T <span class="title function_">getOption</span><span class="params">(SocketOption&lt;T&gt; name)</span> <span class="keyword">throws</span> IOException;<span class="comment">//查询socket支持的配置选项。</span></span><br><span class="line"></span><br><span class="line">    Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="open：创建serversocket"><a href="#open：创建serversocket" class="headerlink" title="open：创建serversocket"></a>open：创建serversocket</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.ServerSocketChannel#open</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ServerSocketChannel <span class="title function_">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> SelectorProvider.provider().openServerSocketChannel();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.SelectorProviderImpl#openServerSocketChannel</span></span><br><span class="line"><span class="keyword">public</span> ServerSocketChannel <span class="title function_">openServerSocketChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServerSocketChannelImpl</span>(<span class="built_in">this</span>); </span><br><span class="line">    <span class="comment">//new了一个ServerSocketChannelImpl对象，有socket了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.ServerSocketChannelImpl#ServerSocketChannelImpl(SelectorProvider)</span></span><br><span class="line">ServerSocketChannelImpl(SelectorProvider sp) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="built_in">super</span>(sp);</span><br><span class="line">    <span class="built_in">this</span>.fd =  Net.serverSocket(<span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">this</span>.fdVal = IOUtil.fdVal(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.Net#serverSocket</span></span><br><span class="line"><span class="keyword">static</span> FileDescriptor <span class="title function_">serverSocket</span><span class="params">(<span class="type">boolean</span> stream)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> IOUtil.newFD(socket0(isIPv6Available(), stream, <span class="literal">true</span>, fastLoopback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-5-1-bind"><a href="#2-1-5-1-bind" class="headerlink" title="2.1.5.1 bind"></a>2.1.5.1 bind</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.ServerSocketChannelImpl#bind</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">//backlog:服务端，syn_receive队列的大小</span></span><br><span class="line"><span class="keyword">public</span> ServerSocketChannel <span class="title function_">bind</span><span class="params">(SocketAddress local, <span class="type">int</span> backlog)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (stateLock) &#123;</span><br><span class="line">        ensureOpen();<span class="comment">// ClosedChannelException if channel is closed</span></span><br><span class="line">        <span class="comment">//通过localAddress判断是否已经调用过bind</span></span><br><span class="line">        <span class="keyword">if</span> (localAddress != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AlreadyBoundException</span>();</span><br><span class="line">        <span class="comment">//InetSocketAddress(0)表示绑定到本机的所有地址，由操作系统选择合适的端口</span></span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">isa</span> <span class="operator">=</span> (local == <span class="literal">null</span>)</span><br><span class="line">                                ? <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">0</span>)</span><br><span class="line">                                : Net.checkAddress(local);</span><br><span class="line">        <span class="comment">//检查地址的是否正确或合法</span></span><br><span class="line">        <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="literal">null</span>)</span><br><span class="line">            sm.checkListen(isa.getPort());</span><br><span class="line">        NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());</span><br><span class="line">        Net.bind(fd, isa.getAddress(), isa.getPort());</span><br><span class="line">        <span class="comment">//开启监听，如果参数backlog小于1，默认接受50个连接 </span></span><br><span class="line">        Net.listen(fd, backlog &lt; <span class="number">1</span> ? <span class="number">50</span> : backlog);</span><br><span class="line">        localAddress = Net.localAddress(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-1-5-1-1-Net：bind"><a href="#2-1-5-1-1-Net：bind" class="headerlink" title="2.1.5.1.1 Net：bind"></a>2.1.5.1.1 Net：bind</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.Net#bind(java.io.FileDescriptor, java.net.InetAddress, int)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(FileDescriptor fd, InetAddress addr, <span class="type">int</span> port)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    bind(UNSPEC, fd, addr, port);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(ProtocolFamily family, FileDescriptor fd,</span></span><br><span class="line"><span class="params">                 InetAddress addr, <span class="type">int</span> port)</span> <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">preferIPv6</span> <span class="operator">=</span> isIPv6Available() &amp;&amp;</span><br><span class="line">        (family != StandardProtocolFamily.INET);</span><br><span class="line">    <span class="keyword">if</span> (addr.isLinkLocalAddress()) &#123;</span><br><span class="line">        addr = IPAddressUtil.toScopedAddress(addr);</span><br><span class="line">    &#125;</span><br><span class="line">    bind0(fd, preferIPv6, exclusiveBind, addr, port);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">bind0</span><span class="params">(FileDescriptor fd, <span class="type">boolean</span> preferIPv6,</span></span><br><span class="line"><span class="params">                                 <span class="type">boolean</span> useExclBind, InetAddress addr,</span></span><br><span class="line"><span class="params">                                 <span class="type">int</span> port)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>socket是用户程序与内核交互信息的枢纽，它自身没有网络协议地址和端口号等信息,在进行网络通信的时候，必须把一个socket与一个地址相关联。 </p>
<h5 id="Net-listen"><a href="#Net-listen" class="headerlink" title="Net.listen"></a>Net.listen</h5><p>Net.listen(fd, backlog &lt; 1 ? 50 : backlog); </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.Net#listen</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">(FileDescriptor fd, <span class="type">int</span> backlog)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<h5 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.ServerSocketChannelImpl#accept()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SocketChannel <span class="title function_">accept</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">FileDescriptor</span> <span class="variable">newfd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileDescriptor</span>();</span><br><span class="line">        InetSocketAddress[] isaa = <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        acceptLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">blocking</span> <span class="operator">=</span> isBlocking();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                begin(blocking);</span><br><span class="line">                n = Net.accept(<span class="built_in">this</span>.fd, newfd, isaa);</span><br><span class="line">                <span class="keyword">if</span> (blocking) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) &#123;</span><br><span class="line">                        park(Net.POLLIN);</span><br><span class="line">                        n = Net.accept(<span class="built_in">this</span>.fd, newfd, isaa);<span class="comment">//本地方法</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                end(blocking, n &gt; <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">assert</span> IOStatus.check(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            acceptLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> finishAccept(newfd, isaa[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果fd监听socket的队列中没有等待的连接，socket也没有被标记为Non-blocking，accept()会阻塞直到连接出现；</p>
</li>
<li><p>如果socket被标记为Non-blocking，队列中也没有等待的连接，accept()返回错误</p>
</li>
</ul>
<h4 id="2-1-5-2-supportedOptions"><a href="#2-1-5-2-supportedOptions" class="headerlink" title="2.1.5.2 supportedOptions"></a>2.1.5.2 supportedOptions</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.ServerSocketChannelImpl#supportedOptions</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() &#123;</span><br><span class="line">    <span class="keyword">return</span> DefaultOptionsHolder.defaultOptions;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.ServerSocketChannelImpl.DefaultOptionsHolder</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultOptionsHolder</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions = defaultOptions();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions() &#123;</span><br><span class="line">            HashSet&lt;SocketOption&lt;?&gt;&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">            set.add(StandardSocketOptions.SO_RCVBUF);<span class="comment">//socket接受缓存大小  </span></span><br><span class="line">            set.add(StandardSocketOptions.SO_REUSEADDR);<span class="comment">//是否可重用地址  </span></span><br><span class="line">            <span class="keyword">if</span> (Net.isReusePortAvailable()) &#123;</span><br><span class="line">                set.add(StandardSocketOptions.SO_REUSEPORT);<span class="comment">//是否可重用port</span></span><br><span class="line">            &#125;</span><br><span class="line">            set.addAll(ExtendedSocketOptions.serverSocketOptions());</span><br><span class="line">            <span class="keyword">return</span> Collections.unmodifiableSet(set);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FileDescriptor"><a href="#FileDescriptor" class="headerlink" title="FileDescriptor"></a>FileDescriptor</h4><h3 id="NIO包下SocketChannel解读"><a href="#NIO包下SocketChannel解读" class="headerlink" title="NIO包下SocketChannel解读"></a>NIO包下SocketChannel解读</h3><p>参考链接：<a href="https://juejin.im/post/5c2e23156fb9a049ff4e4009">https://juejin.im/post/5c2e23156fb9a049ff4e4009</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>network-TCP,UDP</title>
    <url>/2020/04/23/internet/chapterThree%E8%BF%90%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<h1 id="3-运输层"><a href="#3-运输层" class="headerlink" title="3 运输层"></a>3 运输层</h1><p>网络层：两个端系统之间的交付服务</p>
<p>运输层：两个端系统之间的应用程序间的交付任务</p>
<!--mroe-->

<h2 id="3-1-概述和运输层服务"><a href="#3-1-概述和运输层服务" class="headerlink" title="3.1 概述和运输层服务"></a>3.1 概述和运输层服务</h2><p>运输层在端系统中实现。</p>
<ul>
<li>发送端：应用程序报文转换为传输层分组（报文段）<ul>
<li>把报文段传递给网络层生成数据报，向目的地发送</li>
</ul>
</li>
<li>接收端：处理报文段，把数据交付应用程序<ul>
<li>网络层从数据报提取报文段，把报文段递交运输层</li>
</ul>
</li>
</ul>
<h3 id="3-1-2-因特网运输层概述"><a href="#3-1-2-因特网运输层概述" class="headerlink" title="3.1.2 因特网运输层概述"></a>3.1.2 因特网运输层概述</h3><p>运输层的服务：进程间的数据交付+差错检测</p>
<p>TCP的拥塞控制：</p>
<ul>
<li>拥塞控制：防止任何一条TCP连接用过多的流量淹没主机间的链路和交换设备，希望每条连接平等共享带宽</li>
</ul>
<h2 id="3-2-多路复用和多路分解"><a href="#3-2-多路复用和多路分解" class="headerlink" title="3.2 多路复用和多路分解"></a>3.2 多路复用和多路分解</h2><p>多路：路—-网络层</p>
<p>套接字：运输层 对  应用层 提供的接口</p>
<ul>
<li>多路复用：生成报文段，传递到网络层的过程<ul>
<li>把多个来源的数据导向一个输出</li>
<li>多个进程，数据，交付网络层运输</li>
</ul>
</li>
<li>多路分解：把运输层 报文段 的数据正确交付到 正确的套接字 的过程<ul>
<li>从一个来源接收的数据发送到多个输出。</li>
<li>网络层数据，按需交付应用层</li>
</ul>
</li>
</ul>
<p>UDP：二元组– 目的 IP+端口号</p>
<blockquote>
<p>UDP报文段，IP地址存储在IP首部，判断报文段所属的UDP套接字时，根据目的 IP+端口号</p>
</blockquote>
<p>TCP：四元组 –  源IP+端口 ，目的IP+端口</p>
<blockquote>
<p>判断报文段所属的套接字时，根据四元组</p>
<p>四元组，端口复用</p>
</blockquote>
<h2 id="3-3-无连接传输：UDP"><a href="#3-3-无连接传输：UDP" class="headerlink" title="3.3 无连接传输：UDP"></a>3.3 无连接传输：UDP</h2><p>基于IP，除了少量的  复用&#x2F;分解  和 差错检测 外 ，几乎没有增加新的内容</p>
<p><strong>无连接</strong>：发送报文段之前，发送&#x2F;接收 方的 运输层之间没有握手</p>
<p>优点</p>
<ul>
<li>立即发送，控制何时，发送什么样的数据</li>
<li>无需连接建立：无建立连接的时延</li>
<li>无连接状态：能支持更多用户</li>
<li>分组首部开销小：TCP–20字节，UDP–8字节</li>
</ul>
<p>例子：</p>
<ul>
<li>DNS,RIP，多媒体应用（因特网电话，视频直播）</li>
</ul>
<p>UDP无拥塞控制，可能导致，UDP发送&#x2F;接收方的高丢包率</p>
<blockquote>
<p>每个UDP大量发送包，导致网络拥塞，UDP包被丢弃</p>
</blockquote>
<h3 id="3-3-1-UDP报文段结构"><a href="#3-3-1-UDP报文段结构" class="headerlink" title="3.3.1 UDP报文段结构"></a>3.3.1 UDP报文段结构</h3><blockquote>
<table>
<thead>
<tr>
<th>源端口号(16比特，4字节)</th>
<th>目的端口号  (16比特，4字节)</th>
</tr>
</thead>
<tbody><tr>
<td>长度(16比特，4字节)</td>
<td>校验和(16比特，4字节)</td>
</tr>
</tbody></table>
<p>​														应用数据（报文）</p>
</blockquote>
<h3 id="3-3-2-UDP校验和"><a href="#3-3-2-UDP校验和" class="headerlink" title="3.3.2 UDP校验和"></a>3.3.2 UDP校验和</h3><p><strong>校验和</strong>：差错检测功能，确定UDP报文比特是否发生变化</p>
<p>发送方的UDP对报文段中所有16比特字的和进行反码运算，遇到溢出，回卷（），结果放到校验和中</p>
<blockquote>
<p>链路可能没有差错检测，存入内存中，可能比特差错</p>
</blockquote>
<p><strong>端到端原则</strong>：功能基于端到端实现，在较低级别实现，功能可能冗余或没有价值。</p>
<h2 id="3-4-可靠数据传输原理"><a href="#3-4-可靠数据传输原理" class="headerlink" title="3.4 可靠数据传输原理"></a>3.4 可靠数据传输原理</h2><p>可靠数据传输协议：基于下层不可靠的协议，构建一个可靠数据传输。</p>
<h3 id="3-4-1-构造可靠数据传输协议"><a href="#3-4-1-构造可靠数据传输协议" class="headerlink" title="3.4.1 构造可靠数据传输协议"></a>3.4.1 构造可靠数据传输协议</h3><ol>
<li>经由完全可靠信道的 可靠传输协议</li>
</ol>
<p>发送端：高层调用，发送报文段</p>
<p>接受端：收到消息，传递高层</p>
<ol start="2">
<li>经具有比特差错信道，假定所有分组按照发送的顺序被接收</li>
</ol>
<ul>
<li><p>自动重传协议：肯定确认&#x2F;否定确认</p>
<blockquote>
<p>控制报文让发送方知道哪些内容被正确传输，哪些接收有误</p>
</blockquote>
<ul>
<li>差错检测：分组<strong>校验和</strong></li>
<li>接收方反馈：回送<strong>ACK&#x2F;NCK分组</strong></li>
<li><strong>重传</strong>：</li>
</ul>
</li>
<li><p><em><strong>停等协议</strong></em>：发送完分组，确认对方已经接受才发送其他的分组</p>
</li>
<li><p><strong>序号</strong>：针对回送报文出错的情况。</p>
</li>
</ul>
<ol start="3">
<li>经具有比特差错 的 丢包信道  的可靠数据传输</li>
</ol>
<p>发送方：检测和恢复丢包工作</p>
<ul>
<li>倒计数<strong>定时器</strong>：一个分组对应一个计数器，</li>
</ul>
<h3 id="3-4-2-流水线可靠数据传输协议"><a href="#3-4-2-流水线可靠数据传输协议" class="headerlink" title="3.4.2 流水线可靠数据传输协议"></a>3.4.2 流水线可靠数据传输协议</h3><p>信道的利用率：发送方实际发送比特送进信道的时间 &#x2F; 发送时间</p>
<p>流水线：允许发送方发送多个分组而无需等待确认</p>
<ul>
<li>增加序号范围：</li>
<li>发送&#x2F;接收  缓存多个分组</li>
<li>回退N步 Go Back N  GBN</li>
<li>选择重传 Selective Repeat SR</li>
</ul>
<h3 id="3-4-3-回退N步-Go-Back-N-GBN"><a href="#3-4-3-回退N步-Go-Back-N-GBN" class="headerlink" title="3.4.3 回退N步 Go Back N  GBN"></a>3.4.3 回退N步 Go Back N  GBN</h3><p>受限于 未确认分组数 不能 超过 某个最大允许数N</p>
<ul>
<li>基序号 base：最早的未确认分组的序号</li>
<li>下一个序号 nextSeqnum：最小的未使用序号<ul>
<li>0-base - 1 ： 已发送且被确认的序号</li>
<li>base - nextSeqnum-1：已发送，但 未被确认</li>
<li>nextSeqnum - base+N-1：能够用于那些被发送的分组</li>
</ul>
</li>
</ul>
<p>N：窗口长度，<strong>滑动窗口协议</strong></p>
<ul>
<li>累计确认：对序号分组为n的分组的确认，表明接收方已正确接收到序号为n的  <strong>以前且包括n</strong>的 分组</li>
<li>超时：一个定时器<ul>
<li>超时：重发所有已发送，却未被确认的分组</li>
<li>收到ACK：定时器重新启动</li>
</ul>
</li>
</ul>
<p><strong>接收方</strong>：<em>不缓存任何失序分组</em>，只接收  按序 的分组数</p>
<ul>
<li>仅维护下一个要接受的分组序号</li>
</ul>
<h3 id="3-4-4-选择重传-Selective-Repeat-SR"><a href="#3-4-4-选择重传-Selective-Repeat-SR" class="headerlink" title="3.4.4 选择重传  Selective Repeat SR"></a>3.4.4 选择重传  Selective Repeat SR</h3><p>GBN：的缺点：单一的分组丢失，可能引起 GBN 重传大量的分组</p>
<p>SR：发送方仅仅重传  怀疑 接收方出错的分组</p>
<p>窗口长度N：每个分组都有自己的定时器</p>
<ul>
<li><p>发送方：已经确认，</p>
<ul>
<li>收到ACK：<ul>
<li>分组序号在窗口内：SR把那个被确认的分组标记未已接受</li>
<li>序号等于 base  ： 窗口 基序号 向前移动到具有最小序号的未确认分组处</li>
</ul>
</li>
</ul>
</li>
<li><p>接收方：失序-已缓存但未被确认 ， 可接受  ， 期待–还未收到</p>
<ul>
<li>确认接收的正确分组，不管是否按照次序，失序的分组被缓存直到所有 之前的 分组 被收到 为止，这时将按序的分组交付上文</li>
<li>每次收到正确分组 都会返回 该分组对应的 ACK</li>
</ul>
</li>
<li><p>接收分组</p>
<ul>
<li>base - base+N-1：正确接收，回送ACK<ul>
<li>分组序号等于 base：将连续的分组交付上层，窗口移动</li>
<li>序号 base -N–base -1 ：的分组，回送ACK，为了让发送方能够知道已经接收到的序号</li>
</ul>
</li>
<li>窗口长度小于序号空间的一半：防止窗口过大，base -N   &gt; base +N-1 (mod N)</li>
</ul>
</li>
<li><p>发送方与接收方不能看到相同的结果</p>
<ul>
<li>发送：窗口范围：x—-x+N</li>
<li>接收：窗口范围： x+N—x+2N</li>
</ul>
</li>
</ul>
<h3 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h3><ul>
<li>检验和：传输分组是否有差错</li>
<li>定时器：用于ACK接收超时的时侯，重传分组 （分组丢失，ack丢失–冗余分组）</li>
<li>序号：数据分组编号</li>
<li>确认：接收方告诉发送方 ，分组已被正确接收</li>
<li>否定确认：接收方告诉发送方 ，分组未被正确接收</li>
<li>窗口，流水线：发送序号在一个范围内的分组，（根据接收方缓存+网络拥塞设置）</li>
</ul>
<p>分组重新排序：序号的旧版本—设定分组的存活时间</p>
<h2 id="3-5-面向连接的传输：TCP"><a href="#3-5-面向连接的传输：TCP" class="headerlink" title="3.5 面向连接的传输：TCP"></a>3.5 面向连接的传输：TCP</h2><p>差错检测，重传，累计确认，定时器，首部的序号，确认号</p>
<h3 id="3-5-1-TCP连接"><a href="#3-5-1-TCP连接" class="headerlink" title="3.5.1 TCP连接"></a>3.5.1 TCP连接</h3><p>面向连接的：进程间发送数据之前需要先相互  <strong>握手</strong> ，相互发送预备报文段，建立数据传输的参数</p>
<blockquote>
<p>序号相互协商，不从0开始：</p>
<ul>
<li>防止止网络中被延迟的分组在以后被重传，避免数据混淆<ul>
<li>example：ab建立连接，发送包，断开后，又迅速建立建立，上次连接仍活着的包被当成这次的包</li>
<li>解决方法：设置存活时长，timewait 2msl</li>
</ul>
</li>
<li>TCP序列预测攻击：预测服务端的序列号，伪装服务器认证的合法用户（IP欺骗），欺骗服务器，建立连接</li>
</ul>
</blockquote>
<ul>
<li>连接信息保存在两个端系统中</li>
<li>全双工服务：</li>
<li>点对点：单个 发送 与 单个 接收</li>
</ul>
<p>三次握手建立连接</p>
<ul>
<li><p>发送缓存：进程向套接字传输到数据，缓存在发送缓存中</p>
</li>
<li><p>接收缓存：接收方收到报文段后，放到该TCP连接对应的接收缓存中</p>
</li>
<li><p>MSS Maximum Segment Size:最大报文段长度，message的大小，不包含 TCP&#x2F;IP首部信息</p>
</li>
<li><p>MTU Maximum Transmission Unit：最大传输单元，最大链路层帧长度</p>
</li>
<li><blockquote>
<p>MSS受限于MTU，  MSS+TCP&#x2F;IP首部 &lt;&#x3D; MTU</p>
<p>以太网与PPP链路层协议的MTU：1500字节，TCP&#x2F;IP通常：40，因此MSS，通常：1460</p>
</blockquote>
</li>
</ul>
<h3 id="3-5-2-TCP报文段结构"><a href="#3-5-2-TCP报文段结构" class="headerlink" title="3.5.2 TCP报文段结构"></a>3.5.2 TCP报文段结构</h3><p>首部字段+数据字段：MSS限制数据字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| 			源端口号-（16比特） 	| 		目的端口号--16比特    |		---32比特，4字节</span><br><span class="line">								序号</span><br><span class="line">								确认号</span><br><span class="line">首部长度|未保留|URG|ACK|PSH|RST|SYN|FIN| 		接收窗口		   |</span><br><span class="line">			因特网校验和			   |		紧急数据指针		|     -------------共20字节</span><br><span class="line">								 选项</span><br><span class="line">								 数据</span><br></pre></td></tr></table></figure>

<ul>
<li><p>源，目的端口号：多路复用，分解&#x2F; 送到上层应用的数据</p>
</li>
<li><p>序号，确认号（32比特）：被TCP发送&#x2F;接收用来实现  可靠数据传输</p>
</li>
<li><p>接收窗口字段（16比特）：流量控制，接收方愿意接受的字节数量</p>
</li>
<li><p>首部长度（4比特）： 以32比特为单位的TCP首部长度，（可变的TCP首部长度）</p>
<ul>
<li>选项字段：协商MSS，窗口调节因子</li>
<li>标志字段（6比特）：<ul>
<li>ACK：表明，确认字段数值有效</li>
<li>RST, SYN, FIN：连接的建立和拆除</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>序号和确认号：可靠数据传输</li>
</ol>
<p>确认号：此报文段的主机期望收到的下一个字节的序号</p>
<h3 id="3-5-2-往返时间的估计-与-超时"><a href="#3-5-2-往返时间的估计-与-超时" class="headerlink" title="3.5.2 往返时间的估计 与 超时"></a>3.5.2 往返时间的估计 与 超时</h3><ol>
<li>估计往返时间</li>
</ol>
<p>  估计的往返时间：样本RTT(SampleRTT) 被发出到确认 被收到的 时间间隔</p>
<p>​	 某个时刻做一次RTT测量。</p>
<p>​	TCP维持一个SampleRTT均值：$EstimatedRTT &#x3D; ( 1 - \alpha)*ERTT+\alpha * SampleRTT$    一般$\alpha $ 取值 0.125   </p>
<p>​	RTT偏差DevRTT：估计SRTT偏离 ERTT的程度： $DevRTT &#x3D; (1-\beta)<em>DevRTT + \beta</em>|SRTT-ERTT|$</p>
<ol start="2">
<li><p>设置和管理 重传超时间隔</p>
<p>​	$TimeoutInterval &#x3D; ERTT + 4* DevRTT$</p>
<ul>
<li>初始超时：1s</li>
<li>出现超时，加倍</li>
<li>收到ACK，更新ERTT，并设置超时</li>
</ul>
</li>
</ol>
<h3 id="3-5-4-可靠数据传输"><a href="#3-5-4-可靠数据传输" class="headerlink" title="3.5.4 可靠数据传输"></a>3.5.4 可靠数据传输</h3><p><strong>超时+冗余确认</strong>（快速重传）</p>
<ul>
<li><p>超时：重传，重启定时器， <em>仅使用一个定时器</em>，该定时器与最早的未确认报文相连接</p>
<ul>
<li>时间间隔加倍</li>
</ul>
</li>
<li><p>ACK：</p>
<ul>
<li>重新估算时间间隔，并设置</li>
<li>确认号y &gt;&#x3D; sendbase：累计确认，证明接收端无误的接收到了 序号为 y-1 的字段，期望接收 序号为y的字段，<ul>
<li>若此时，有未被确认的报文段，重启定时器</li>
</ul>
</li>
</ul>
</li>
<li><p>快速重传：收到 相同数据  的三个 冗余ACK ，重传丢失的报文段（定时器象关联的，第一个分组）</p>
<ul>
<li>冗余ACK：收到 序号 大于 确认号  的分组，发送 ACK–确认号不变<ul>
<li>一个报文段丢失，后续的报文段都会引发 冗余ACK  的发送</li>
</ul>
</li>
<li>接收方，收到 相同数据  的三个 冗余ACK ：认为此报文段已经丢失，执行快速重传</li>
</ul>
</li>
</ul>
<p>回退N步，还是选择重传？</p>
<ul>
<li>发送方：未被确认的 sendBase + 下一个要发送的字节号	NextSeqNum</li>
<li>TCP至多重传一个报文段</li>
<li>接收方：选择确认，有选择的确认失序报文段</li>
<li>GBN 和 SR  的混合：<ul>
<li>重传只发一个</li>
<li>接收方缓存分组，返回ACK确认号为最后一个 按序的序号</li>
</ul>
</li>
</ul>
<h3 id="3-5-5-流量控制"><a href="#3-5-5-流量控制" class="headerlink" title="3.5.5 流量控制"></a>3.5.5 流量控制</h3><p>针对  接收缓存  ，防止 接收缓存溢出</p>
<p>流量控制服务：消除发送方使接收方 接收缓存溢出的情况</p>
<ul>
<li>接收窗口 reveive window：发送方维护的变量，该接收方还有多少可以的缓存空间<ul>
<li>revBuffer：接收方的最大缓存空间</li>
<li>LastByteRead：主机B从缓存读取的 最后一个 字节 编号</li>
<li>LastByteRcvd：放入B缓存数据流的最后一个字节的编号</li>
<li>LastByteRcvd  - LastByteRead &lt; revBuffer<ul>
<li>接收窗口 rwnd &#x3D;  revBuffer - （LastByteRcvd  - LastByteRead  ）</li>
</ul>
</li>
</ul>
</li>
<li>主机B把这个数值放入 报文段的 接收窗口字段中。<ul>
<li>发送方： LastByteSent - LastByteAcked &lt;&#x3D; rwnd<ul>
<li>LastByteSent：最后一个发送的字节编号</li>
<li>LastByteAcked：最后一个 确认B接收的字节编号</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>拥塞控制：ip网络的拥塞</p>
<h3 id="3-5-6-TCP连接管理"><a href="#3-5-6-TCP连接管理" class="headerlink" title="3.5.6 TCP连接管理"></a>3.5.6 TCP连接管理</h3><ul>
<li>三次握手：SYN<ul>
<li>第三次，可负载信息</li>
</ul>
</li>
<li>四次挥手：FIN</li>
</ul>
<p>RST：无对应的套接字</p>
<p>UDP：ICMP–无对应的套接字</p>
<h2 id="3-6-拥塞控制"><a href="#3-6-拥塞控制" class="headerlink" title="3.6 拥塞控制"></a>3.6 拥塞控制</h2><p>网络拥塞时，遏制发送方</p>
<p>异步传递方式 ATM：</p>
<p>可用比特率 ABR</p>
<h3 id="3-6-1-拥塞原因及代价"><a href="#3-6-1-拥塞原因及代价" class="headerlink" title="3.6.1 拥塞原因及代价"></a>3.6.1 拥塞原因及代价</h3><ol>
<li>两个发送方+无穷大缓存的路由器<ul>
<li>链路速率存在上限  — &gt; 排队时延</li>
</ul>
</li>
<li>两个发送方+有限缓存的路由器<ul>
<li>丢失分组：重传</li>
<li>大时延：不必要的重传</li>
</ul>
</li>
<li>四个发送方+ 有限缓存的多台路由器 及 多跳路径<ul>
<li>一个分组在某路径被丢弃时，</li>
</ul>
</li>
</ol>
<h3 id="3-6-2-拥塞控制方法"><a href="#3-6-2-拥塞控制方法" class="headerlink" title="3.6.2 拥塞控制方法"></a>3.6.2 拥塞控制方法</h3><ul>
<li>端到端的拥塞控制：网络层没有提供拥塞控制<ul>
<li>从丢失与时延中推断网络拥塞情况</li>
</ul>
</li>
<li>网络辅助的拥塞控制：路由器向发送方显示反馈 网络拥塞状态<ul>
<li><ol>
<li>阻塞分组：直接反馈信息，从路由器到发送方</li>
<li>路由器更新&#x2F;标记 发送方往接收方的分组的字段来标识拥塞的产生，接收方向发送方通知拥塞</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="3-6-3-网络辅助拥塞的例子-ATM-ABR"><a href="#3-6-3-网络辅助拥塞的例子-ATM-ABR" class="headerlink" title="3.6.3 网络辅助拥塞的例子 ATM  ABR"></a>3.6.3 网络辅助拥塞的例子 ATM  ABR</h3><ul>
<li>ATM：虚电路</li>
</ul>
<h2 id="3-7-TCP拥塞控制"><a href="#3-7-TCP拥塞控制" class="headerlink" title="3.7 TCP拥塞控制"></a>3.7 TCP拥塞控制</h2><p>让每一个发送方都能感知网络的拥塞程度，来限制发送速率</p>
<ol>
<li>限制连接发送流量<ul>
<li>拥塞窗口 cwnd</li>
<li>LastByteSend - LastByteAcked &lt;&#x3D; min{ cwnd，rwnd}</li>
<li>通过限制发送方未被确认的数据量，间接限制发送方的发送速率</li>
</ul>
</li>
<li>感知出现拥塞：<ul>
<li>丢包：超时 ， 3次冗余ACK</li>
<li>丢包—减少窗口；  ACK—增加窗口</li>
</ul>
</li>
</ol>
<ul>
<li><p>TCP拥塞控制算法：超时–丢包，3个冗余ACK–快速重传</p>
<ul>
<li><p>慢启动：TCP连接建立的时候，cwnd的初始值较小，一个MSS</p>
<ul>
<li><p>每次收到一个ACK,cwnd窗口就增加一个MSS——-指数增长</p>
<ul>
<li><blockquote>
<p>每轮RTT，都能收到发送的x个报文的ACK，增加x个MSS</p>
</blockquote>
</li>
</ul>
</li>
<li><p>超时–发生丢包：TCP，将cwnd数值设为1，从新开始慢启动，并设置 <strong>ssthresh慢启动阈值</strong> 设置为 拥塞发生时窗口的一半</p>
</li>
<li><p>到达ssthresh：结束慢启动，进入拥塞避免</p>
</li>
<li><p>检测到3个冗余ACK：快速重传，快速恢复</p>
</li>
</ul>
</li>
<li><p>拥塞避免：每次RTT，将cwnd的数值增加1</p>
<ul>
<li>线性增长</li>
<li>超时：与慢启动一样</li>
<li>检测到3个冗余ACK：更新ssthresh（1&#x2F;2 cwnd），将cwnd数值减半，快速重传，快速恢复</li>
</ul>
</li>
<li><p>快速恢复：每个冗余ACK，增加一个MSS</p>
<ul>
<li>超时：慢启动</li>
</ul>
</li>
</ul>
</li>
<li><p>TCP拥塞控制：实现二</p>
<ul>
<li>忽视连接开始时的初始慢启动状态：假定  丢包 &#x3D; 3个冗余 ACK</li>
<li>加性增，乘性减：每个RTT内，cwnd 线性增加1MSS，3个冗余ACK的时候，cwnd减半<ul>
<li>锯齿装的cwnd</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>network-web</title>
    <url>/2020/04/23/internet/chapterTwo%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<h2 id="2-1-应用层协议原理"><a href="#2-1-应用层协议原理" class="headerlink" title="2.1 应用层协议原理"></a>2.1 应用层协议原理</h2><p>网络应用程序：运行在不同端系统，通过网络彼此通信的程序</p>
<span id="more"></span>

<h3 id="２-１-１-网络应用程序体系结构"><a href="#２-１-１-网络应用程序体系结构" class="headerlink" title="２.１.１　网络应用程序体系结构"></a>２.１.１　网络应用程序体系结构</h3><ul>
<li><p>CS客户服务器体系，</p>
<ul>
<li>服务器：总是打开的的主机，服务于来自其他称为客户的主机的请求。<ul>
<li>数据中心，被创建服务器</li>
</ul>
</li>
<li>客户之间不相互通信</li>
<li>FTP,Web</li>
</ul>
</li>
<li><p>P2P对等体系结构</p>
<ul>
<li>主机对之间直接通信，对等方</li>
<li>自扩展性</li>
</ul>
</li>
</ul>
<h3 id="2-1-2-进程通信"><a href="#2-1-2-进程通信" class="headerlink" title="2.1.2 进程通信"></a>2.1.2 进程通信</h3><p>进程通过网络交换报文</p>
<ol>
<li>客户和服务器进程</li>
</ol>
<p>网络程序由成对的进程组成，一个客户，一个服务器。</p>
<ul>
<li>客户：发起通信的进程</li>
<li>服务器：会话开始时，等待联系的进程</li>
</ul>
<ol start="2">
<li>进程与计算机网络之间的接口</li>
</ol>
<p>套接字软件接口：向网络  发送&#x2F;接收 报文</p>
<p>套接字：应用层与传输层之间的接口，应用程序接口</p>
<ol start="3">
<li>进程寻址</li>
</ol>
<p>主机地址+接收进程的标识符：IP地址+端口号</p>
<h3 id="2-1-3-可供应用程序使用的传输服务"><a href="#2-1-3-可供应用程序使用的传输服务" class="headerlink" title="2.1.3 可供应用程序使用的传输服务"></a>2.1.3 可供应用程序使用的传输服务</h3><ol>
<li>可靠数据传输</li>
<li>吞吐量</li>
</ol>
<blockquote>
<p> 可用吞吐量：发送进程能够向接收进程交付比特的速率</p>
<ul>
<li>带宽敏感的应用：具有吞吐量要求的应用程序</li>
<li>弹性应用：利用可供使用的吞吐量</li>
</ul>
</blockquote>
<ol start="3">
<li>定时：提供定时保证</li>
<li>安全性：安全性服务</li>
</ol>
<blockquote>
<p>机密性（加密），数据完整性，端点鉴别</p>
</blockquote>
<h3 id="2-1-4-因特网提供的运输服务"><a href="#2-1-4-因特网提供的运输服务" class="headerlink" title="2.1.4 因特网提供的运输服务"></a>2.1.4 因特网提供的运输服务</h3><ol>
<li>TCP服务</li>
</ol>
<ul>
<li>面向连接 ；可靠传输 ；拥塞控制</li>
</ul>
<blockquote>
<p>安全套接字层SSL：加强版TCP，额外增加了进程到进程的安全性服务，加密，数据完整性，端点鉴别</p>
</blockquote>
<ol start="2">
<li>UDP服务</li>
</ol>
<ul>
<li>轻量级运输协议：无连接，不可靠</li>
</ul>
<h3 id="2-1-5-应用层协议"><a href="#2-1-5-应用层协议" class="headerlink" title="2.1.5 应用层协议"></a>2.1.5 应用层协议</h3><p>应用层协议：定义端系统的应用程序进程如何相互传递报文</p>
<ul>
<li>交换的报文类型</li>
<li>报文类型的语法</li>
<li>字段的语义</li>
<li>进程如何，何时发送报文，对报文响应</li>
</ul>
<h2 id="2-2-Web-和HTTP"><a href="#2-2-Web-和HTTP" class="headerlink" title="2.2 Web  和HTTP"></a>2.2 Web  和HTTP</h2><p>Web：按需操作</p>
<h3 id="2-2-1-HTTP概况"><a href="#2-2-1-HTTP概况" class="headerlink" title="2.2.1 HTTP概况"></a>2.2.1 HTTP概况</h3><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>HTTP URL (URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息)的格式如下： </p>
<p><code>[http://host[&quot;:&quot;port\][abs_path](http://host[&quot;&quot;port][abs_path/)]</code></p>
<p>http表示要通过HTTP协议来定位网络资源  : <code>http:192.168.0.116:8080/index.jsp </code></p>
<ul>
<li>host表示合法的Internet主机域名或者IP地址</li>
<li>port指定一个端口号，为空则使用缺省端口80</li>
<li>abs_path指定请求资源的URI</li>
</ul>
<h4 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h4><p>http请求由三部分组成，分别是：请求行、消息报头、请求正文。</p>
<ul>
<li><p>请求行：Method Request-URI HTTP-Version CRLF </p>
<ul>
<li><p>Method表示请求方法</p>
</li>
<li><p>Request-URI是一个统一资源标识符</p>
</li>
<li><p>HTTP-Version表示请求的HTTP协议版本</p>
</li>
<li><p>CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。</p>
</li>
<li><table>
<thead>
<tr>
<th>method</th>
<th>content</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>请求获取Request-URI所标识的<strong>资源</strong></td>
</tr>
<tr>
<td>POST</td>
<td>在Request-URI所标识的资源后附加新的<strong>数据</strong>,<br />被请求服务器接受附在请求后面的数据，常用于提交表单。</td>
</tr>
<tr>
<td>HEAD</td>
<td>请求获取由Request-URI所标识的资源的响应消息报头</td>
</tr>
<tr>
<td>PUT</td>
<td>请求服务器存储一个资源，并用Request-URI作为其标识</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器删除Request-URI所标识的资源</td>
</tr>
<tr>
<td>TRACE</td>
<td>请求服务器回送收到的请求信息，主要用于测试或诊断</td>
</tr>
<tr>
<td>CONNECT</td>
<td>保留将来使用</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>请求查询服务器的性能，或者查询与资源相关的选项和需求</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>请求报头</p>
</li>
<li><p>请求正文</p>
</li>
</ul>
<h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><p>HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文</p>
<ul>
<li><p>状态行：HTTP-Version Status-Code Reason-Phrase CRLF</p>
<ul>
<li><p>HTTP-Version表示服务器HTTP协议的版本</p>
</li>
<li><p>Status-Code表示服务器发回的响应状态代码</p>
</li>
<li><p>Reason-Phrase表示状态代码的文本描述。</p>
</li>
<li><blockquote>
<p>1xx：指示信息–表示请求已接收，继续处理<br>2xx：成功–表示请求已被成功接收、理解、接受    </p>
<blockquote>
<p>200 OK   &#x2F;&#x2F;客户端请求成功</p>
</blockquote>
<p>3xx：重定向–要完成请求必须进行更进一步的操作<br>4xx：客户端错误–请求有语法错误或请求无法实现</p>
<blockquote>
<p>400 Bad Request &#x2F;&#x2F;客户端请求有语法错误，不能被服务器所理解<br>401 Unauthorized &#x2F;&#x2F;请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用<br>403 Forbidden &#x2F;&#x2F;服务器收到请求，但是拒绝提供服务<br>404 Not Found &#x2F;&#x2F;请求资源不存在，eg：输入了错误的URL</p>
</blockquote>
<p>5xx：服务器端错误–服务器未能实现合法的请求</p>
<blockquote>
<p>500 Internal Server Error &#x2F;&#x2F;服务器发生不可预期的错误<br>503 Server Unavailable &#x2F;&#x2F;服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p>
</blockquote>
</blockquote>
</li>
</ul>
</li>
<li><p>响应报头</p>
</li>
<li><p>响应正文：服务器返回的资源的内容</p>
</li>
</ul>
<h4 id="报头"><a href="#报头" class="headerlink" title="报头"></a>报头</h4><p>消息报头：普通报头、请求报头、响应报头、实体报头。</p>
<ul>
<li>报头格式：名字+“：”+空格+值     <ul>
<li>消息报头域的名字是大小写无关的。</li>
</ul>
</li>
<li>普通：</li>
<li>请求：客户端向服务器端传递请求的附加信息以及客户端自身的信息。<br>* </li>
<li>响应：服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。</li>
<li>实体：实体报头定义了关于实体正文（eg：有无实体正文）和请求所标识的资源的元信息。</li>
</ul>
<p>Web的应用层协议：HTTP–超文本传输协议 HyperText Transfer Protocol，Web的核心</p>
<p>Web页面（文档）是由对象组成的，一个对象是一个文件，可通过URL地址寻址。</p>
<p>​								一个Web页面 &#x3D; 一个HTML基本文件+引用对象</p>
<ul>
<li>Web浏览器 ： HTTP的客户端</li>
<li>Web服务器 ： HTTP的服务端，存储Web对象</li>
</ul>
<p>应用层协议 – HTTP：客户程序+服务器程序</p>
<p>HTTP</p>
<ul>
<li><p>定义了Web客户向服务器交互的格式。</p>
</li>
<li><p>HTML文件通过对象的URL地址引用其他对象。</p>
<ul>
<li><blockquote>
<p>URL：协议+ 服务器名+路径名</p>
</blockquote>
</li>
</ul>
</li>
<li><p>基于TCP协议。</p>
</li>
<li><p>不存储用户的状态信息，无状态协议</p>
</li>
</ul>
<h3 id="2-2-2-非持续连接-和持续连接"><a href="#2-2-2-非持续连接-和持续连接" class="headerlink" title="2.2.2 非持续连接 和持续连接"></a>2.2.2 非持续连接 和持续连接</h3><ul>
<li>非持续连接：请求&#x2F;响应  经过一个单独的TCP连接发送</li>
<li>持续链接：请求&#x2F;响应  经过同一个TCP连接发送</li>
</ul>
<p>默认。HTTP：持续连接</p>
<ol>
<li>非持续连接的HTTP：<ol>
<li>每次请求一个页面的引用对象，都新开一个TCP连接</li>
<li>每次TCP连接，只传送一个  请求&#x2F;响应  报文</li>
</ol>
</li>
</ol>
<p>RTT 往返时间，Round-Trip Time ：从客户到服务器在返回客户所需要的时间。</p>
<ol start="2">
<li>持续连接的TCP<ol>
<li>所有的请求和响应通过一个TCP连接，发送对象的请求，接收；然后请求下一个对象</li>
<li>流水线的持续连接</li>
</ol>
</li>
</ol>
<h3 id="2-2-3-HTTP报文格式"><a href="#2-2-3-HTTP报文格式" class="headerlink" title="2.2.3 HTTP报文格式"></a>2.2.3 HTTP报文格式</h3><ol>
<li>请求报文</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法 sp URL sp 版本 cr lf  回车  换行</span><br><span class="line">首部字段名： sp 值 cr lf</span><br><span class="line">。。。</span><br><span class="line">首部字段名： sp 值 cr lf</span><br><span class="line">cr lf</span><br><span class="line">实体主体</span><br><span class="line"></span><br><span class="line">GET /some/1.html HTTP/1.1</span><br><span class="line">Host: www.hello.edu</span><br><span class="line">Connection:close		持续连接？</span><br><span class="line">User-agent:Mozilla/5.0   浏览器的类型</span><br><span class="line">Accept-language:en</span><br><span class="line">						Get方法时，主体为空</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>HTTP响应报文</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">版本 sp 状态码 sp cr lf</span><br><span class="line">首部字段名： sp 值 cr lf</span><br><span class="line">。。。</span><br><span class="line">首部字段名： sp 值 cr lf</span><br><span class="line">cr lf</span><br><span class="line">实体</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Connection：close</span><br><span class="line">Date：Tue，09， ....</span><br><span class="line">Server：Apache/2.2.3（CentOS）</span><br><span class="line">Last-Modified：**</span><br><span class="line">Content-Length：**</span><br><span class="line">Content-Type：text/html</span><br><span class="line"></span><br><span class="line">data。。。。。</span><br></pre></td></tr></table></figure>

<p>状态码：</p>
<ul>
<li>信息响应(<code>100</code>–<code>199</code>)</li>
<li>成功响应(<code>200</code>–<code>299</code>)</li>
<li>重定向(<code>300</code>–<code>399</code>)</li>
<li>客户端错误(<code>400</code>–<code>499</code>)</li>
<li>服务器错误 (<code>500</code>–<code>599</code>)</li>
</ul>
<h3 id="2-2-4-用户和服务器的交互-：cookie"><a href="#2-2-4-用户和服务器的交互-：cookie" class="headerlink" title="2.2.4 用户和服务器的交互 ：cookie"></a>2.2.4 用户和服务器的交互 ：cookie</h3><p>cookie：四个组件</p>
<ol>
<li>HTTP响应的cookie首部行</li>
<li>HTTP请求的cookie首部行</li>
<li>用户端系统中，保留一个cookie文件，并由用户的浏览器进行管理</li>
<li>Web站点的一个后端数据库，</li>
</ol>
<p>cookie用于表示一个用户，在无状态连接的HTTP之上建立了一个用户会话层</p>
<h3 id="2-2-5-Web-缓存"><a href="#2-2-5-Web-缓存" class="headerlink" title="2.2.5 Web 缓存"></a>2.2.5 Web 缓存</h3><p>Web缓存器（Web Cache）– 代理服务器    proxy server：代表初始Web服务器来满足HTTP请求的网络实体</p>
<p>浏览器请求时，向Web缓存器请求，</p>
<ul>
<li>web缓存器持有缓存：返回</li>
<li>不持有缓存：Web缓存向节点请求，等待返回，缓存，并发送给请求的用户</li>
</ul>
<p>优点：</p>
<ul>
<li>减少对客户请求的响应时间</li>
<li>减少通信量</li>
</ul>
<h3 id="2-2-6-条件GET方法"><a href="#2-2-6-条件GET方法" class="headerlink" title="2.2.6 条件GET方法"></a>2.2.6 条件GET方法</h3><p>条件Get方法：验证持有的对象是否是最新的版本</p>
<p>请求报文：</p>
<ul>
<li>请求报文，Get方法</li>
<li>首部包含：If-Modified-Since，字段</li>
</ul>
<p>响应报文：</p>
<ul>
<li>是最新， not modified，空报文体</li>
<li>不是最新，返回对象</li>
</ul>
<h2 id="2-3-FTP，文件传输协议"><a href="#2-3-FTP，文件传输协议" class="headerlink" title="2.3 FTP，文件传输协议"></a>2.3 FTP，文件传输协议</h2><p>FTP用户代理，用户提供远程主机名，建立TCP连接，提供用户标识+口令，若用户被授权，用户可以进行本地文件与远程文件系统的上传下载。</p>
<ul>
<li><p>两个并行的TCP连接来传输文件</p>
<ul>
<li>控制连接 端口 21：传输控制信息，用户标识，口令，put&#x2F;get 文件 等命令<ul>
<li>持续连接</li>
</ul>
</li>
<li>数据连接 端口 20：实际传输文件<ul>
<li>非持续连接</li>
</ul>
</li>
</ul>
<p>FTP的控制信息是带外传输的。</p>
<p>HTTP带内传输控制信息</p>
</li>
</ul>
<p>FTP保存用户状态，连接用户账户-控制连接</p>
<p>FTP的命令和回答</p>
<p>命令：7比特的ASCII格式传输。</p>
<ul>
<li>USER username：用户名</li>
<li>PASS password：口令</li>
<li>LIST：文件列表</li>
<li>RETR filename：get文件</li>
<li>STOR filename：put文件</li>
</ul>
<h2 id="2-4-电子邮件"><a href="#2-4-电子邮件" class="headerlink" title="2.4 电子邮件"></a>2.4 电子邮件</h2><p>电子邮件：异步通信媒介</p>
<p>组成成分：</p>
<ol>
<li>用户代理：</li>
<li>邮件服务器：</li>
<li>简单邮件传输协议 SMTP：</li>
</ol>
<h3 id="2-4-1-SMTP"><a href="#2-4-1-SMTP" class="headerlink" title="2.4.1 SMTP"></a>2.4.1 SMTP</h3><p>SMTP是因特网电子邮件协议应用的核心。基于TCP协议，持续连接</p>
<p>A写邮件，发送给B：</p>
<p>A写邮件，并提供B的邮件地址，发送邮件，邮件发送到A的邮件服务器的报文队列上，A的SMTP客户端建立一个到B的SMTP服务器的TCP连接，通过TCP连接发送邮件报文。B的邮件服务器接收报文，放入B的邮箱。</p>
<h3 id="2-4-2-HTTP与SMTP对比"><a href="#2-4-2-HTTP与SMTP对比" class="headerlink" title="2.4.2 HTTP与SMTP对比"></a>2.4.2 HTTP与SMTP对比</h3><ul>
<li>HTTP：拉协议，用户从服务器拉去信息</li>
<li>SMTP：堆协议，邮箱服务器向 另一个 邮件服务器 推送 信息<ul>
<li>编码格式：	SMTP必须7比特的ASCII编码，HTTP无约束</li>
</ul>
</li>
<li>对象内容：<ul>
<li>SMTP:一个对象</li>
<li>HTTP：每个分属不同的对象</li>
</ul>
</li>
</ul>
<h3 id="2-4-4-邮件访问协议"><a href="#2-4-4-邮件访问协议" class="headerlink" title="2.4.4 邮件访问协议"></a>2.4.4 邮件访问协议</h3><ol>
<li>POP3</li>
</ol>
<ul>
<li>特许：用户发送用户名+口令来鉴别用户<ul>
<li>user+pass</li>
</ul>
</li>
<li>事务处理：用户取回，删除，统计报文信息<ul>
<li>list+retr+dele+，quie</li>
</ul>
</li>
<li>更新：结束POP会话</li>
</ul>
<ol start="2">
<li><p>IMAP</p>
<ul>
<li>一个报文就是一个文件夹，创建&#x2F;移动 文件夹，查询邮件</li>
<li>允许用户查看部分报文。</li>
</ul>
</li>
<li><p>基于Web的电子邮件</p>
<ul>
<li>用户和邮箱通信通过HTTP协议进行。</li>
<li>浏览器—–（http） —-邮件服务器—–（SMTP）——-邮件服务器——（HTTP）——浏览器</li>
</ul>
</li>
</ol>
<h2 id="2-5-DNS-因特网的目录服务"><a href="#2-5-DNS-因特网的目录服务" class="headerlink" title="2.5 DNS 因特网的目录服务"></a>2.5 DNS 因特网的目录服务</h2><p>识别主机的方式：1.主机名		2.IP地址 </p>
<h3 id="2-5-1-DNS提供的服务"><a href="#2-5-1-DNS提供的服务" class="headerlink" title="2.5.1 DNS提供的服务"></a>2.5.1 DNS提供的服务</h3><p>主机名 与 ip地址  之间的转换</p>
<p>DNS Domian Name System：分层的DNS服务器（数据库），主机能够查询分布式数据库的应用层协议</p>
<ul>
<li>主机别名：</li>
<li>邮件服务器别名：MX</li>
<li>负载分配：IP地址集合–  规范的主机名</li>
</ul>
<h3 id="2-5-2-工作原理"><a href="#2-5-2-工作原理" class="headerlink" title="2.5.2 工作原理"></a>2.5.2 工作原理</h3><p>用户的DNS客户端发送DNS查询报文，基于UDP协议经过端口53发送，接收到DNS回答报文，获得IP地址</p>
<ol>
<li><p>分布式层次数据库</p>
<ul>
<li>根DNS服务器</li>
<li>顶级域DNS服务器</li>
<li>权威DNS服务器</li>
</ul>
<p>本地DNS</p>
<p>递归查询：请求，获得最终结果</p>
<p>迭代查询：请求，获得结果，再根据结果查询</p>
</li>
<li><p>DNS缓存</p>
<p>缓存查询的信息，减少向根&#x2F;顶级等DNS发送查询的报文数</p>
</li>
</ol>
<h3 id="2-5-3-DNS记录和报文"><a href="#2-5-3-DNS记录和报文" class="headerlink" title="2.5.3 DNS记录和报文"></a>2.5.3 DNS记录和报文</h3><p>资源记录 Resource Record：主机名到IP地址的映射</p>
<blockquote>
<p>(Name,Value,Type,TTL)</p>
<p>type:</p>
<ul>
<li>A：name为主机名</li>
<li>NS：name 为域，value为记录域名的权威DNS服务器</li>
<li>CNAME: value为别名为Name的主机名</li>
<li>MX： value为别名为Name的邮件服务器的规范主机名</li>
</ul>
</blockquote>
<p>每个DNS回答包含了 一条 或多条 资源记录</p>
<ol>
<li>DNS报文</li>
<li>往DNS数据库插入数据</li>
</ol>
<h2 id="2-6-P2P应用"><a href="#2-6-P2P应用" class="headerlink" title="2.6 P2P应用"></a>2.6 P2P应用</h2><p>p2p 彼此直接通信</p>
<h3 id="2-6-1-P2P-文件分发"><a href="#2-6-1-P2P-文件分发" class="headerlink" title="2.6.1 P2P 文件分发"></a>2.6.1 P2P 文件分发</h3><p>P2P文件分发中。每个对等方都能够重新发送自己所拥有的文件</p>
<h2 id="2-7-TCP套接字编程"><a href="#2-7-TCP套接字编程" class="headerlink" title="2.7 TCP套接字编程"></a>2.7 TCP套接字编程</h2><p>UDP：<strong>显式</strong> 确认 目的地址：目的ip+目的端口号</p>
<p>在底层，将源地址（ip ） <strong>隐式</strong> 加上</p>
<p>server：</p>
<ul>
<li>UDP：<ul>
<li>bind，：绑定端口号</li>
<li>recvfrom：接收分组消息</li>
</ul>
</li>
<li>TCP：<ul>
<li>bind：绑定端口号</li>
<li>listen：设置监听状态</li>
<li>accpet：接收新的连接</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>network-internet</title>
    <url>/2020/04/23/internet/chapterOne%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/</url>
    <content><![CDATA[<h2 id="1-1-因特网"><a href="#1-1-因特网" class="headerlink" title="1.1 因特网"></a>1.1 因特网</h2><ul>
<li>具体构成：基本硬件+软件组件</li>
<li>联网基础设施：为分布式应用提供服务的联网基础设施<!--mroe--></li>
</ul>
<h3 id="1-1-1-具体构成"><a href="#1-1-1-具体构成" class="headerlink" title="1.1.1 具体构成"></a>1.1.1 具体构成</h3><p><strong>主机（host） 或  端系统（end system）</strong></p>
<p>端系统通过 通信链路（communication link） 和分组交换机（packet switch）连接在一起</p>
<p><strong>分组</strong>：发送端系统将  数据分段 加上首部字节  的产物</p>
<blockquote>
<p>传输速率：比特&#x2F;秒  bit&#x2F;s  bps</p>
</blockquote>
<p><strong>分组交换机</strong>：</p>
<ol>
<li>路由器：通常用于网络核心</li>
<li>链路层交换机：通常用于接入网中</li>
</ol>
<blockquote>
<p>路径route &#x2F;path：分组经历的一系列通信链路和分组交换机，成为通过该网络的路径</p>
</blockquote>
<p><strong>ISP</strong> 因特网服务提供商Internet Service Provider：一个由多个分组交换机和多段通信网络组成的网络，为端系统提供网络接入。</p>
<blockquote>
<p>底层的ISP通过高层的ISP互联，高层ISP通过高速光纤链路互联。</p>
</blockquote>
<p>协议Protocol：控制因特网中信息的接受与传送。</p>
<p>TCP Transmission Control Protocol：传输控制协议</p>
<p>IP Internet Protocol：网际协议，定义了路由器和端系统之间发送和接收的分组格式</p>
<h3 id="1-1-2-服务描述"><a href="#1-1-2-服务描述" class="headerlink" title="1.1.2 服务描述"></a>1.1.2 服务描述</h3><p>服务描述：从应用程序提供服务的基础设施描述因特网。应用程序，运行在端系统上。</p>
<p>分布式应用程序 Distributed Application：涉及多台相互交换数据的端系统</p>
<p>端系统提供了 应用程序编程接口API  Application Programming Interface。</p>
<p><strong>API</strong>：规定了一个在端系统上的<em>软件</em>  请求因特网基础设施向 运行在另一个端系统特定目的软件 交付数据  的方式。</p>
<h3 id="1-1-3-协议"><a href="#1-1-3-协议" class="headerlink" title="1.1.3 协议"></a>1.1.3 协议</h3><p><strong>协议</strong>：定义了两个或多个通信实体之间交换的<strong>报文格式和次序</strong>，以及报文发送&#x2F;接收 或其他事件所采取的<strong>动作</strong></p>
<h2 id="1-2-网络边缘"><a href="#1-2-网络边缘" class="headerlink" title="1.2 网络边缘"></a>1.2 网络边缘</h2><p>端系统：处于因特网的边缘</p>
<p>主机：运行应用程序。	客户&#x2F;服务器</p>
<h3 id="1-2-1-接入网-Access-Network"><a href="#1-2-1-接入网-Access-Network" class="headerlink" title="1.2.1 接入网 Access Network"></a>1.2.1 接入网 Access Network</h3><p><em><strong>接入网</strong></em>：将端系统连接到其 边缘路由器 edge router 的 <strong>物理链路</strong>。</p>
<blockquote>
<p>边缘路由器：端系统到其他端系统 <em>路径</em> 上的第一台路由器</p>
</blockquote>
<ol>
<li>家庭接入：DSL,电缆，FTTH，拨号卫星</li>
</ol>
<ul>
<li><p>DSL Digital Subscriber Line：数字用户线，DSL调制解调器</p>
<p>从提供本地电话接入的本地电话公司处获得DSL因特网接入。 通过频分复用，使得电话和网络可以同时共享链路</p>
</li>
<li><p>电缆因特网接入：利用了有线电视现有的有线电视基础设施。电缆调制解调器cable modem</p>
</li>
<li><p>FTTH fuber To The Home:光纤到户</p>
</li>
</ul>
<ol start="2">
<li>企业&#x2F;家庭接入：以太网，wifi</li>
</ol>
<ul>
<li><p>通过LAN局域网接入到边缘路由器。</p>
</li>
<li><p>无限LAN环境，无限用户从一个接入点收发数据，接入点与ISP相连</p>
</li>
</ul>
<ol start="3">
<li>广域无线网接入：3G,LTE</li>
</ol>
<h3 id="1-2-2-物理媒体"><a href="#1-2-2-物理媒体" class="headerlink" title="1.2.2 物理媒体"></a>1.2.2 物理媒体</h3><p>网络接入技术对应的物理媒体</p>
<ul>
<li>导引型媒体：电波沿着固体媒体前行，光缆，双绞铜线，同轴电缆</li>
<li>非导引型媒体：电波在空气或外层空间传播，无线局域网，数字卫星频道</li>
</ul>
<ol>
<li>双绞铜线</li>
</ol>
<p>最便宜且使用最普遍的引导性媒体</p>
<ol start="2">
<li>同轴电缆：</li>
<li>光纤：每个脉冲一个比特，长途引导型传输媒体</li>
<li>陆地无线电信道</li>
<li>卫星无线电信道</li>
</ol>
<h2 id="1-3-网络核心"><a href="#1-3-网络核心" class="headerlink" title="1.3 网络核心"></a>1.3 网络核心</h2><p>网络核心：分组交换机+链路构成的网状网络</p>
<h3 id="1-3-1-分组交换"><a href="#1-3-1-分组交换" class="headerlink" title="1.3.1 分组交换"></a>1.3.1 分组交换</h3><ol>
<li>存储转发传输：交换机在向输出链路传输该分组的第一个比特之前，必须接收到整个分组</li>
</ol>
<p>N条速率为R的链路组成的路径（有N-1个路由器），端到端时延：$d_{端到端} &#x3D; N \frac{L}{R}$</p>
<ol start="2">
<li>排队时延和分组丢失</li>
</ol>
<p>原因：每个分组机有多条链路与之相连，对于每条相连的链路，具有一个输出缓存（输出队列）。若到达的分组需要传输到某条链路上，但发现该链路正忙于传输其他分组，则该分组在输出队列中等待。</p>
<p>排队时延：等待的时长。</p>
<p>分组丢失：队列已满，仍往里添加分组</p>
<ol start="3">
<li>转发表和路由选择协议</li>
</ol>
<p>转发表：将目的IP地址映射为输出链路</p>
<p>路由选择协议：自动设置转发表</p>
<h3 id="1-3-2-电路交换"><a href="#1-3-2-电路交换" class="headerlink" title="1.3.2 电路交换"></a>1.3.2 电路交换</h3><p>通过网络链路和交换机移动数据有两种基本方法：电路交换+分组交换</p>
<p>电路交换：电路交换网络中，在端系统通信期间，预留了端系统通信沿路径所需要的资源（缓存，链路传输速率）</p>
<p>传统的电话网络：电路交换网络。</p>
<ol>
<li>电路交换网络中的<strong>复用</strong></li>
</ol>
<p><strong>频分复用FDM</strong>：频谱由所有链接共享，</p>
<blockquote>
<p>连接期间–每个连接专用一个频段，频段的宽度—带宽</p>
</blockquote>
<p><strong>时分复用TDM</strong>：时间被划分为固定区间的帧，每个帧划分为时隙。</p>
<blockquote>
<p>连接期间，为连接在帧中划分一个时隙，该时隙专门由此连接使用</p>
<p>传输速率：帧速率*一个时隙中的比特数量</p>
</blockquote>
<h3 id="分组和电路的区别"><a href="#分组和电路的区别" class="headerlink" title="分组和电路的区别"></a>分组和电路的区别</h3><p>分组优点：更好的带宽共享，简单有效，成本低</p>
<blockquote>
<p>有效：使用网络的时间频度不在一起，相当于用户专享链路。时间局部性</p>
</blockquote>
<p>分组缺点：端到端时延是不可变且不可预测的</p>
<h3 id="1-3-3-网络的网络"><a href="#1-3-3-网络的网络" class="headerlink" title="1.3.3 网络的网络"></a>1.3.3 网络的网络</h3><p>接入ISP自身必须互联，网络的网络</p>
<p>网络结构1：单一的全球承载ISP互联所有接入ISP</p>
<p>网络结构2：数十万接入SP+多个全球承载ISP</p>
<p>网络结构3：接入ISP与区域ISP相连，区域ISP与第一级ISP相连。</p>
<p>网络结构4：接入ISP，区域ISP，第一层ISP，PoP，多宿，对等，IXP（因特网交换点）组成</p>
<p>网络结构5：4+内容提供商网络</p>
<h2 id="1-4-分组交换的时延。丢包，吞吐量"><a href="#1-4-分组交换的时延。丢包，吞吐量" class="headerlink" title="1.4 分组交换的时延。丢包，吞吐量"></a>1.4 分组交换的时延。丢包，吞吐量</h2><p>吞吐量：每秒能够传送的数据量</p>
<h3 id="1-4-1-节点时延概述"><a href="#1-4-1-节点时延概述" class="headerlink" title="1.4.1 节点时延概述"></a>1.4.1 节点时延概述</h3><p>节点总时延 &#x3D; 节点处理时延+排队时延+传输时延+传播时延</p>
<p>节点处理时延：检查分组首部，决定该分组导向何处所需要的时间（主要）+ 差错检测等</p>
<p>排队时延：在链路上等待传输的时延</p>
<p>传输时延：L&#x2F;R  L：分组比特数，R：传输速率</p>
<p>传播时延：物理媒体，d&#x2F;s  d：长度，s：传播速率</p>
<h3 id="1-4-2-排队时延和丢包"><a href="#1-4-2-排队时延和丢包" class="headerlink" title="1.4.2 排队时延和丢包"></a>1.4.2 排队时延和丢包</h3><p>a：分组到达队列的平均速率，pkt&#x2F;s</p>
<p>La：比特到达队列的平均速率，La  bps</p>
<p>R：传输速率，从队列中推出比特的速率，bps，b&#x2F;s</p>
<p>La&#x2F;R：流量强度：设计系统时候，流量强度不能超过一</p>
<blockquote>
<p>流量强度：in 比特 与  MAXout 比特的比值</p>
</blockquote>
<p>丢包：分组交换机  链路的缓存队列已满，没有地方存储这个分组，产生丢包，分组被丢弃</p>
<h3 id="1-4-3-端到端时延"><a href="#1-4-3-端到端时延" class="headerlink" title="1.4.3 端到端时延"></a>1.4.3 端到端时延</h3><p>N条速率为R的链路组成的路径（有N-1个路由器），</p>
<p>$d_{end-end} &#x3D; N ( d_{proc} + d_{trans} + d_{prop})$</p>
<p>端系统，应用程序+其他时延：</p>
<h3 id="1-4-4-计算机网络中的吞吐量"><a href="#1-4-4-计算机网络中的吞吐量" class="headerlink" title="1.4.4 计算机网络中的吞吐量"></a>1.4.4 计算机网络中的吞吐量</h3><p>瞬时吞吐量：主机接收文件的速率</p>
<p>平均吞吐量：F&#x2F;T</p>
<p>瓶颈链路：路径中的最小传输速率</p>
<h2 id="1-5-协议层次及其服务模型"><a href="#1-5-协议层次及其服务模型" class="headerlink" title="1.5 协议层次及其服务模型"></a>1.5 协议层次及其服务模型</h2><p>分层：改变服务的实现不影响其他系统组件</p>
<ol>
<li>协议分层</li>
</ol>
<p>分层的方式组织协议以及实现。</p>
<p>某层向上一层提供服务。</p>
<p>协议层的实现：软件+硬件</p>
<p>缺点：</p>
<ol>
<li>冗余底层的功能</li>
<li>某层的功能可能需要其他层的信息</li>
</ol>
<p>协议栈：物理层，链路层，网络层，运输层，应用层</p>
<ul>
<li>应用层：网络应用程序及应用层协议存留的地方，<ul>
<li>HTTP（web）,FTP(电子邮件),SMTP(文件)</li>
<li>部署在多个端系统上</li>
<li><strong>报文 message</strong></li>
</ul>
</li>
<li>运输层：应用<strong>程序端点</strong>之间传送应用层报文<ul>
<li>TCP(连接，可靠，拥塞控制，流量控制),UDP（不可靠）</li>
<li><strong>报文段 segment</strong>  &#x3D; 运输层首部信息+报文</li>
</ul>
</li>
<li>网络层：将<strong>数据报</strong>从一台<em>主机</em>移动到另一台主机<ul>
<li>IP协议，路由选择协议</li>
<li>运输层向网络层提供报文段+目的地址</li>
<li><strong>数据报 datagram</strong> &#x3D; 网络层首部信息 + 报文段</li>
</ul>
</li>
<li>链路层：链路层沿着路径把<strong>数据报</strong>传递给下一个节点<ul>
<li>链路层的服务决定链路层的协议，</li>
<li>**帧 frame **   &#x3D; 链路层首部信息 +  数据报</li>
</ul>
</li>
<li>物理层：把帧的一个个<strong>比特</strong>从一个节点移动到下一个节点<ul>
<li><strong>比特 byte</strong></li>
</ul>
</li>
</ul>
<p>OSI模型：</p>
<p>应用层，表示层，会话层，运输层，网络层，数据链路层，物理层</p>
<p>表示层：应用程序能够解释交换数据的含义，数据压缩&#x2F;解密&#x2F;描述</p>
<p>会话层：数据交换定界和同步功能，建立检查点，恢复方案等</p>
<p>链路交换机：一，二层</p>
<p>路由器：一到三层</p>
<h2 id="1-6-面对攻击的网络"><a href="#1-6-面对攻击的网络" class="headerlink" title="1.6 面对攻击的网络"></a>1.6 面对攻击的网络</h2><p>病毒：需要用户交互的恶意软件</p>
<p>蠕虫：不需要交互的恶意软件</p>
<p>DOS-Denial Of Service：拒绝服务攻击</p>
<ul>
<li>弱点攻击：精细的报文</li>
<li>带宽泛洪：大量的分组</li>
<li>连接洪泛：大量半开&#x2F;全开  TCP连接</li>
</ul>
<p>分布式DOS：控制多个源，并让每个源向目标发送流量</p>
<p>分组嗅探器</p>
<p>IP哄骗</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>linux学习笔记</title>
    <url>/2020/04/21/linux/linuxStudy/</url>
    <content><![CDATA[<h1 id="Linux-学习笔记"><a href="#Linux-学习笔记" class="headerlink" title="Linux 学习笔记"></a>Linux 学习笔记</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul>
<li>pwd：显示当前路径</li>
<li>ls：列出当前目录下文件<ul>
<li>ls -l：以列表形式出现</li>
</ul>
</li>
<li>mkdir</li>
<li>rmdir：删除空文件夹</li>
<li>rm ：recurse递归删除<ul>
<li>rm -r +name：有询问，是否删除</li>
<li><strong>rm -rf</strong> name：强制全部删除</li>
</ul>
</li>
<li>cp: copy文件  cp  1  2</li>
<li>mv: move文件  mv  1 2 </li>
<li>vi：vim，文本编辑器</li>
</ul>
<span id="more"></span>

<ul>
<li>clear ：清屏</li>
<li>find：find + 路径 + name  ： 查找文件</li>
<li>whereis ：whereis name  东西在哪</li>
</ul>
<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p>命令1 | 命令 2 .。。</p>
<p>将一个命令的输出，作为另一个命令的输入，传送给另一个命令</p>
<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>linux 的文件的后缀名无意义</p>
<h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><ul>
<li>sh：原始shell</li>
<li>bash：shell</li>
</ul>
<h2 id="系统权限管理"><a href="#系统权限管理" class="headerlink" title="系统权限管理"></a>系统权限管理</h2><ul>
<li><p>su + 用户名;切换用户   switch user</p>
</li>
<li><p>sudo -i：进入root账户</p>
</li>
<li><p>useradd</p>
</li>
</ul>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ul>
<li>ln “建立连接，硬&#x2F;软连接，  <ul>
<li>ln  a  b</li>
</ul>
</li>
<li>touch：生成新文件，修改文件的时间</li>
<li>find ：查找文件 find + 路径 + name </li>
<li>tree：显示目录树</li>
<li>wc：统计文件的行数，字数，字符数<ul>
<li>more：显示文件内容</li>
<li>cat：显示文件信息</li>
<li>tac：反序显示文件信息</li>
<li>head ：可选项，查看前多少行</li>
<li>tail：可选项，查看后多少行</li>
</ul>
</li>
<li>grep：查找字符所在文件的位置—  grep   字符  文件名</li>
<li>col：过滤字符</li>
</ul>
<h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><ul>
<li><p>ls - l :前面的是文件的权限</p>
<ul>
<li>r：read</li>
<li>w：write</li>
<li>-：没有任何权限</li>
<li>x：执行权限</li>
</ul>
<p>三组，第一组，文件的所有者</p>
<p>第二组：文件所有者的同组</p>
<p>第三组，剩下的其他人</p>
</li>
<li><p>chmod：修改文件权限,默认u</p>
<ul>
<li>chmod [u&#x2F;g&#x2F;o] +&#x2F;- 权限名  文件名</li>
<li>chmod 755  文件名  （三组权限，9位表示）</li>
</ul>
</li>
<li><p>chown： chown username  文件名：修改文件默认的用户</p>
</li>
</ul>
<h3 id="vi-：vim编辑器"><a href="#vi-：vim编辑器" class="headerlink" title="vi ：vim编辑器"></a>vi ：vim编辑器</h3><p>* </p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><ul>
<li>输出重定向<ul>
<li>命令 &gt;  文件：命令信息输出到文件中</li>
<li>命令 &gt;&gt; 文件：输出两次</li>
<li>命令  2&gt;  文件：命令错误时输出错误信息到文件中，正确时，正常进行</li>
</ul>
</li>
<li>输入重定向;<ul>
<li>目的  &lt; 来源</li>
</ul>
</li>
</ul>
<h2 id="帮助命令介绍"><a href="#帮助命令介绍" class="headerlink" title="帮助命令介绍"></a>帮助命令介绍</h2><ul>
<li>命令 –help</li>
<li>man  命令  (Manuel 查看命令的手册)</li>
</ul>
<h2 id="信息显示命令"><a href="#信息显示命令" class="headerlink" title="信息显示命令"></a>信息显示命令</h2><ul>
<li>date：显示当前时间</li>
<li>stat：显示文件信息</li>
<li>who，w：显示在线登录用户</li>
<li>whoami：显示当前用户身份</li>
<li>id：当前用户id信息</li>
<li>hostname：显示主机名称</li>
<li>uname：显示操作系统信息</li>
<li>dmesg：显示系统启动信息</li>
<li>du：显示指定的文件&#x2F;目录已使用的磁盘总量</li>
<li>df：显示文件系统磁盘空间的使用情况</li>
<li>free：显示当前内存和交换空间的使用情况</li>
<li>fdisk -l：显示磁盘信息</li>
<li>locale：显示当前语言环境</li>
</ul>
<h2 id="目录意义"><a href="#目录意义" class="headerlink" title="目录意义"></a>目录意义</h2><ul>
<li><p>&#x2F;：根分区</p>
</li>
<li><p>SWAP：虚拟内存分区</p>
</li>
<li><p>&#x2F;boot：启动程序</p>
</li>
<li><p>&#x2F;urs：</p>
</li>
<li><p>&#x2F;bin：系统所需要的命令位于此目录，文件都是可执行的</p>
</li>
<li><p>&#x2F;dev：设备文件存储目录，声卡，磁盘等</p>
</li>
<li><p>&#x2F;etc：系统配置文件所在地，</p>
</li>
<li><p>&#x2F;home：普通用户默认存放目录</p>
</li>
<li><p>lib：库文件存放目录</p>
</li>
</ul>
<h2 id="linux分区的命名-dev-xxyN"><a href="#linux分区的命名-dev-xxyN" class="headerlink" title="linux分区的命名 &#x2F;dev&#x2F;xxyN"></a>linux分区的命名 &#x2F;dev&#x2F;xxyN</h2><p>&#x2F;dev&#x2F;：设备文件所在的目录名，分区在硬盘上，硬盘是设备，硬盘上所有可能的分区。</p>
<p>xx：分区的前两个字母表明1分区所在的设备的类型，hd（IDE磁盘），sd（SCSI磁盘）</p>
<p>y：表明分区所在的设备 a第一个，b第二个  </p>
<p>N：代表分区，主分区（扩展分区） 1-4，逻辑分区从5开始</p>
<p>hda3：第一个IDE磁盘上的第三个分区</p>
<h3 id="磁盘分区与挂载点-mnt"><a href="#磁盘分区与挂载点-mnt" class="headerlink" title="磁盘分区与挂载点  &#x2F;mnt"></a>磁盘分区与挂载点  &#x2F;mnt</h3><h2 id="boot顺序"><a href="#boot顺序" class="headerlink" title="boot顺序"></a>boot顺序</h2><ol>
<li>load bios</li>
<li>read MBR‘s config to find out the OS</li>
<li>load the kernel of the OS</li>
<li>init process starts</li>
<li>execute  &#x2F;etc&#x2F;rc .d&#x2F;sysinit    runcommond demon</li>
<li>start other modules(etc&#x2F;modules.conf)</li>
<li>execute the run level scripts</li>
<li>execute &#x2F;etc&#x2F;rc.d&#x2F;rc.local</li>
<li>execute &#x2F;bin&#x2F;login</li>
<li>shell started</li>
</ol>
<h2 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h2><ul>
<li>exit</li>
<li>shutdown</li>
<li>reboot</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>tools list</title>
    <url>/2020/04/20/tools-list/</url>
    <content><![CDATA[<h1 id="java-Tools"><a href="#java-Tools" class="headerlink" title="java Tools"></a>java Tools</h1><h2 id="jclasslab-Bytecode-viewer：一个看字节码的工具"><a href="#jclasslab-Bytecode-viewer：一个看字节码的工具" class="headerlink" title="jclasslab Bytecode viewer：一个看字节码的工具"></a>jclasslab Bytecode viewer：一个看字节码的工具</h2><span id="more"></span>

<h2 id="BinaryViewer：查看二进制文件的工具"><a href="#BinaryViewer：查看二进制文件的工具" class="headerlink" title="BinaryViewer：查看二进制文件的工具"></a>BinaryViewer：查看二进制文件的工具</h2><h2 id="JOL：java-object-layout：查看对象的内存布局的工具"><a href="#JOL：java-object-layout：查看对象的内存布局的工具" class="headerlink" title="JOL：java object layout：查看对象的内存布局的工具"></a>JOL：java object layout：查看对象的内存布局的工具</h2><p><a href="https://github.com/zhongmingmao/java_object_layout/tree/master/jol-sample">maven环境下的pox.xml配置文件</a></p>
<h2 id="jitWatch：查看汇编代码"><a href="#jitWatch：查看汇编代码" class="headerlink" title="jitWatch：查看汇编代码"></a>jitWatch：查看汇编代码</h2><p>JIT目录下（d，ubuntu，jitwatch）（zip解压目录下执行）</p>
<p>mvn clean compile exec:java（需要配置maven）</p>
<p><a href="https://blog.csdn.net/hengyunabc/article/details/26898657">安装教程</a></p>
<p><a href="https://github.com/AdoptOpenJDK/jitwatch">github主页</a></p>
<h2 id="arthas：是Alibaba开源的Java诊断工具"><a href="#arthas：是Alibaba开源的Java诊断工具" class="headerlink" title="arthas：是Alibaba开源的Java诊断工具"></a>arthas：是Alibaba开源的Java诊断工具</h2><p><a href="https://github.com/alibaba/arthas">github主页</a></p>
<p>目录下执行：java -jar arthas-boot.jar</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora+PicGo+github写Markdown文档</title>
    <url>/2020/04/06/dailyFun/TyporeANDPicGo/</url>
    <content><![CDATA[<h1 id="Typora-PicGo-github写Markdown文档"><a href="#Typora-PicGo-github写Markdown文档" class="headerlink" title="Typora+PicGo+github写Markdown文档"></a>Typora+PicGo+github写Markdown文档</h1><h2 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h2><p><a href="https://picgo.github.io/PicGo-Doc/zh/guide/">PicGo官方下载链接</a></p>
<p>具体内容文档里写的很清楚，我是用Github图床的。</p>
<span id="more"></span>

<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/PicGo%E7%9A%84Typore%E8%AE%BE%E7%BD%AEautourl.png" alt="image-20200406164454580"></p>
<h2 id="失败的可能情况"><a href="#失败的可能情况" class="headerlink" title="失败的可能情况"></a>失败的可能情况</h2><p>如果设置完成出现了上传失败的问题，可能是github的名称不能有&#x3D;&#x3D;空格&#x3D;&#x3D;。</p>
<p>这位老哥的文章写的很清楚，我的一开始就上传失败，关了一下PicGo的&#x3D;&#x3D;server&#x3D;&#x3D;，又开了一下就好了</p>
<p><a href="https://blog.csdn.net/TalesOV/article/details/104450037">PicGo踩坑记录</a></p>
<p>6.18 打开，Typore，PicGo能够上传文件，Typore显示failed to fetch</p>
<p>解决方法：查看此处 <strong>端口号</strong> 与 server设置的是否一致（目前没找到修改Typore端口号修改的地方，只能修改PicGo的端口号）</p>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/dailyFun/PicGo/Picgo618%E6%8A%A5%E9%94%99.jpg" alt="Picgo618报错"></p>
]]></content>
      <categories>
        <category>DailyFun</category>
      </categories>
      <tags>
        <tag>dailyFun</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo的博客搭建记录</title>
    <url>/2020/04/06/dailyFun/hexonext%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="搭建hexo，Next版本7"><a href="#搭建hexo，Next版本7" class="headerlink" title="搭建hexo，Next版本7"></a>搭建hexo，Next版本7</h1><p>具体我是参考这篇文章的内容</p>
<p><a href="https://tding.top/archives/42c38b10.html">Hexo-NexT (v7.0+) 主题配置</a></p>
<span id="more"></span>

<h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><ol>
<li>碰到了menu点击出现错误的情况</li>
</ol>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/HexoMenuSet.png" alt="image-20200406170306735"></p>
<p>这个地方&#x3D;&#x3D;不能有空格&#x3D;&#x3D;，有空格会会把空格默认成字符，就找不到路径了</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一开始搭建找各种教程做，碰到了很多由于版本更新造成的问题，后来就直接看官方文档了，才发现官方文档写的异常清楚。</p>
<p><img src="D:%5CStudy%5Cgithub%5CMyHexo%5Csource%5C_posts%5CdailyFun%5Cupload%5Cimage-20200406170703715.png" alt="image-20200406170703715"></p>
<p>就比如这个，登录上方的网站就可以看到关于这部分设置（流量统计与浏览人数）的相关教程。</p>
]]></content>
      <categories>
        <category>DailyFun</category>
      </categories>
      <tags>
        <tag>dailyFun</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM--字节码执行引擎</title>
    <url>/2020/04/06/java/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8C%BA%E5%9F%9F%E4%B8%8E%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h1 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h1><p>物理机的执行引擎：建立在操作系统的层面上的</p>
<p>虚拟机的执行引擎：软件自行实现的</p>
<blockquote>
<p>不受物理条件制约的定制指令集与执行引擎的结构体系，执行不被硬件<strong>直接</strong>支持的指令集格式</p>
</blockquote>
<span id="more"></span>

<h2 id="栈帧区域"><a href="#栈帧区域" class="headerlink" title="栈帧区域"></a>栈帧区域</h2><p>栈帧(Stack Frame)：用于支持虚拟机进行<strong>方法调用与方法执行</strong>的数据结构。运行时数据区<code>虚拟机栈</code>的栈元素。</p>
<p>栈帧内容：方法的局部变量表，操作数栈，动态链接，方法返回地址等信息。</p>
<blockquote>
<p>栈帧的大小（局部变量表，操作数栈等的大小）存储在方法表的Code属性当中，编译成class文件后就固定了。</p>
</blockquote>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表Local Variables Table:变量值的存储空间，用于存放<strong>方法参数</strong>与方法内部定义的<strong>局部变量</strong>。</p>
<blockquote>
<p>Class文件中Code属性的<em>max_local</em>数据项就确定了该方法需要的局部变量表的<strong>最大值</strong>。</p>
</blockquote>
<p><em>存储单位</em>：变量槽Variable Slot</p>
<blockquote>
<p> 虚拟机规范未强制此项大小，一个变量槽的长度可以根据具体的事先有不同的长度。</p>
</blockquote>
<p><em>引用方式</em>：索引定位，从0开始，若某个变量占据两个槽，无法仅访问其中的一个。</p>
<p>变量槽可重用：变量的作用域造成的。</p>
<blockquote>
<p>tips：在引用变量x出作用域，slot槽还未被其他的变量使用的时候，slot槽还存有x的引用，gc roots仍能找到其引用，x指向的对象不会被回收（即使这个x变量已经无用，可以被回收），最好在变量出作用域前，赋初值（<em><strong>主要是reference类型的变量</strong></em>。</p>
<p>但由于概念模型与实际虚拟机的差别（比如:即时编译优化），可能并不会出现上面这种区别。</p>
</blockquote>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈Operand Stack: 操作栈，后入先出的 栈。</p>
<blockquote>
<p>操作数栈的最大深度也是在编译的时候被写入到Code属性的max_stacks中。</p>
</blockquote>
<p>栈的内容：任意类型的java数据类型。32位的数据占据栈容量1；64位的容量为2.</p>
<p>程序运行开始，操作数栈为空，根据字节码指令进行相应的入栈出栈操作。</p>
<blockquote>
<p>操作数栈的数据类型与字节码指令的序列严格匹配，</p>
<ul>
<li>编译器保证</li>
<li>类校验阶段验证(验证中的字节码验证)</li>
</ul>
</blockquote>
<p>栈帧之间可能有数据共享。</p>
<h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><p>在运行时间，将字节码的方法调用指令的符号引用 转化为直接引用。</p>
<blockquote>
<ul>
<li><p>静态解析：类加载阶段，符号引用—&gt;直接引用</p>
</li>
<li><p>动态连接：每一次运行期间转化为直接引用</p>
</li>
</ul>
</blockquote>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>方法开始执行后，退出方法的两个途径</p>
<ol>
<li>正常调用完成：遇到了返回的字节码指令，返回到上层调用</li>
<li>异常调用完成：遇上了妥善处理的异常，不会返回给上层任何返回值的。</li>
</ol>
<h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>一般把动态连接，方法返回地址，附加信息统称一类栈帧 信息</p>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法调用：确定被调用的方法的版本（确定是哪一个方法）</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><ul>
<li>类加载的<strong>解析</strong>：符号引用–&gt;直接引用 ； 此方法调用在运行期间不可改变</li>
</ul>
<blockquote>
<p>编译期可知，运行期不可变： 静态方法（与类型直接相连），私有方法（外部不可访问）。</p>
<p>这两类方法不可通过<strong>继承或其他方式</strong> <em>重写</em>其他版本，能够在类加载阶段进行解析</p>
<ul>
<li>非虚方法：静态，私有，实例构造器，父类方法+ final修饰的方法</li>
<li>虚方法：其他方法。</li>
</ul>
</blockquote>
<p>方法调用的字节码指令：invoke </p>
<blockquote>
<ul>
<li>static: 静态方法</li>
<li>special: 实例构造器<init> ，私有，父类中的方法。</li>
<li>virtual</li>
<li>interface:</li>
<li>dynamic:</li>
</ul>
</blockquote>
<p>static与special调用的方法，在类加载阶段可以唯一确定调用的版本</p>
<h3 id="分派Dispatch，重写，重载"><a href="#分派Dispatch，重写，重载" class="headerlink" title="分派Dispatch，重写，重载"></a>分派Dispatch，重写，重载</h3><p>方法签名：方法名+参数类型（不包括返回值）</p>
<ol>
<li>重写：根据方法的参数选择，静态<ol>
<li>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</li>
<li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 private&#x2F;final&#x2F;static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
<li><strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变</strong></li>
</ol>
</li>
<li>重载：根据方法的调用者选择，动态<ol>
<li>发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</li>
<li><strong>重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</strong></li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载方法</th>
<th>重写方法</th>
</tr>
</thead>
<tbody><tr>
<td>发生范围</td>
<td>同一个类</td>
<td>子类 中</td>
</tr>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>异常</td>
<td>可修改</td>
<td>可以减少或删除，一定不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译期</td>
<td>运行期</td>
</tr>
</tbody></table>
<ul>
<li>静态分派： 依据&#x3D;&#x3D;静态类型&#x3D;&#x3D;决定方法执行版本的分派动作。<em>编译阶段</em></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Human</span> <span class="variable">man</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line">Human 为静态类型，编译期可知；Man为实际类型，运行期可知</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(Human t)</span>&#123;&#125;;<span class="comment">//</span></span><br><span class="line"> 	<span class="keyword">void</span> <span class="title function_">say</span><span class="params">( Man t)</span>&#123;&#125;;</span><br><span class="line"><span class="comment">//重写，根据静态类型确定方法执行那个版本</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>***重载(典型的静态分派)***：虚拟机&#x2F;编译器根据传入变量的静态类型进行作为判断依据。</p>
<p>重载：确定的是相对最合适的，不是唯一的</p>
<p>按照与参数的关系进行匹配，优先级从高到低，与参数的继承（+实现的接口）的关系一致（从底层向父类找）</p>
</blockquote>
<ul>
<li>动态分派：<em>运行期</em>根据&#x3D;&#x3D;实际类型&#x3D;&#x3D;确定方法执行版本的分派过程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Human&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">say</span><span class="params">(Object t)</span>;</span><br><span class="line">&#125;</span><br><span class="line">Man <span class="keyword">extends</span> <span class="title class_">Human</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">say</span><span class="params">(Object t)</span>;<span class="comment">//重载，根据调用方法的对象，选择哪个方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em><strong>重写</strong></em>：根据<em><strong>方法接收者的</strong></em>实际类型选择方法版本</p>
<p>invokevirtual:</p>
<ol>
<li>先找操作数栈顶指向对象的<em><strong>实际类型</strong></em>C</li>
<li>在类型C找到相对应的方法，若有访问权限，返回方法的直接引用，否则，java.lang&#x2F;IllegalAccessError异常</li>
<li>类型C中找不到，按照继承关系从下往上依次对父类进行搜索与验证</li>
<li>仍然找不到，java.lang.AbstratMethodError异常</li>
</ol>
</blockquote>
<ul>
<li>单分派与多分派</li>
</ul>
<p>方法的<strong>宗量</strong>：方法的接收者与方法的参数。</p>
<blockquote>
<ul>
<li>单分派：根据一个总量对目标方法进行选择</li>
<li>多分派：根据多于一个总量对目标方法进行选择</li>
</ul>
<p>静态多分派：静态类型+方法参数</p>
<p>动态单分派：方法参数类型已经确定，方法的接收者尚未确定</p>
</blockquote>
<ul>
<li>虚拟机动态分派的实现</li>
</ul>
<p>动态分派，运行时搜索类型的方法元数据来找到合适的目标，反复搜索类型元数据—耗时</p>
<p><em><strong>虚方法表</strong></em>：在类型的方法表中建立，使用虚方法表索引代替元数据查找以提高性能。</p>
<blockquote>
<p>虚方法表中存储各个方法的<strong>实际入口地址</strong>（方法对应的字节码，存储在各个类的方法区中），</p>
<p>虚方法表一般在类加载的连接–准备后，在准备的类的变量初始值后，初始化虚方法表。</p>
</blockquote>
<h2 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h2><p>动态类型语言：类型检查的主体过程是在运行期而不是编译期；变量无类型，变量值有类型</p>
<blockquote>
<p>运行时确定方法的接收者</p>
</blockquote>
<h3 id="invoke包"><a href="#invoke包" class="headerlink" title="invoke包"></a>invoke包</h3><blockquote>
<p>invoke包：提供方法句柄来动态确定目标方法的机制。</p>
<p>把查找目标代码的决定权从虚拟机迁移到具体的用户代码中。</p>
</blockquote>
<ul>
<li><p>Reflection：模拟java代码层次的调用，重量级，信息全</p>
</li>
<li><p>MethodHandle：模拟字节码层次的调用。轻量级，仅仅包含执行该方法的相关信息。</p>
</li>
</ul>
<h3 id="invokedynamic指令"><a href="#invokedynamic指令" class="headerlink" title="invokedynamic指令"></a>invokedynamic指令</h3><h2 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h2><p>java程序的编译：半独立</p>
<blockquote>
<p>javac编译器：生成线性字节码指令流（基于栈的指令集架构）</p>
<p>解释器：虚拟机内部</p>
</blockquote>
<ul>
<li>栈架构：速度慢(<em><strong>解释执行的情况下</strong></em>)<ul>
<li>由于指令数量与内存访问的原因</li>
</ul>
</li>
</ul>
<p>即时编译器形成的物理机的汇编指令流：虚拟机采取的指令架构与运行速度无关系。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM--类加载机制</title>
    <url>/2020/04/05/java/jvm/ClassLoader/</url>
    <content><![CDATA[<h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><p>类加载机制：虚拟机把描述类的数据从Class文件<em>加载</em>到内存，并对数据进行<em>校验</em>，<em>转换解析</em>和<em>初始化</em>，最终形成被虚拟机直接使用的java类型。</p>
<p>类的加载，连接，初始化都是在程序运行期间完成的。</p>
<blockquote>
<p>优点：扩展性，灵活性。—动态加载，动态连接。</p>
<p>缺点：提前编译有困难，类加载有开销。</p>
</blockquote>
<span id="more"></span>

<h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><blockquote>
<p>初始化类的时候，应该先初始化父类</p>
</blockquote>
<p>加载，验证，准备，解析，初始化。</p>
<ul>
<li>加载：获取该<em><strong>类的二进制字节流</strong></em>。在<strong>方法区</strong>中存储数据，在<strong>堆内存</strong>生成class对象</li>
<li>验证：确保Class文件中的字节流包含的信息符合约束要求</li>
<li>准备：为<strong>类变量</strong>(<em>static 修饰的静态变量</em>)<strong>分配内存</strong>并设定<em><strong>类变量初始值</strong></em>的阶段。<ul>
<li><strong>final static</strong>类型的变量，在此阶段初始化，从常量池中取数据</li>
</ul>
</li>
<li>解析：把常量池中的符号引用替换为直接引用的过程。</li>
<li>初始化：<clinit>()方法<ul>
<li><strong>static修饰的变量与块的顺序执行过程</strong></li>
</ul>
</li>
</ul>
<h2 id="（）方法分析"><a href="#（）方法分析" class="headerlink" title="&lt;clinit&gt;（）方法分析"></a>&lt;clinit&gt;（）方法分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">parent</span>&#123;</span><br><span class="line">	<span class="keyword">static</span> &#123; a = <span class="number">5</span>;&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="type">int</span> c=initc();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a = <span class="number">500</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;1.父类静态代码块：赋值b成功&quot;</span> + b);</span><br><span class="line">     <span class="comment">//  System.out.println(&quot;1.父类静态代码块：a的值&quot;+a);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">static</span>  <span class="type">int</span> <span class="title function_">initc</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;3.父类成员变量赋值：---&gt; c的值&quot;</span>+c);</span><br><span class="line">        c=<span class="number">12</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;3.父类成员变量赋值：---&gt; c的值&quot;</span>+c);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">parent</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;4.父类构造方式开始执行---&gt; a:&quot;</span>+a+<span class="string">&quot;,b:&quot;</span>+b);</span><br><span class="line">        System.out.println(<span class="string">&quot;4.父类构造方式开始执行---&gt; c:&quot;</span>+c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> <span class="keyword">extends</span> <span class="title class_">parent</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="type">int</span> sa=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">int</span> sb;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">sfinal</span> <span class="operator">=</span> <span class="number">56</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        sb=<span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;2.子类静态代码块：赋值sb成功&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;2.子类静态代码块：sa的值&quot;</span>+sa);</span><br><span class="line">       <span class="comment">// System.out.println(&quot;5.子类成员变量赋值---&gt;：sc的值&quot;+sc);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">sonObjectFinal</span> <span class="operator">=</span> <span class="number">45</span>;</span><br><span class="line">   <span class="keyword">private</span>   <span class="type">int</span> sc=initc2();</span><br><span class="line">   <span class="type">int</span> <span class="title function_">initc2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;5.子类成员变量赋值---&gt;：sc的值&quot;</span>+sc);</span><br><span class="line">        <span class="built_in">this</span>.sc=<span class="number">12</span>;</span><br><span class="line">        <span class="keyword">return</span> sc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">son</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;6.子类构造方式开始执行---&gt; sa:&quot;</span>+sa+<span class="string">&quot;,sb:&quot;</span>+sb);</span><br><span class="line">        System.out.println(<span class="string">&quot;6.子类构造方式开始执行---&gt; sc:&quot;</span>+sc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">son</span><span class="params">( String name)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>();</span><br><span class="line">    	System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> son的clinit字节码文件：</span><br><span class="line"> </span><br><span class="line"> <span class="number">0</span> iconst_1</span><br><span class="line"> <span class="number">1</span> putstatic #<span class="number">15</span> &lt;tempTest/ClassLoader/son.sa&gt;</span><br><span class="line">     <span class="comment">//这里，源代码中有final static的变量，这里没有代码进行赋值</span></span><br><span class="line"> <span class="number">4</span> iconst_1</span><br><span class="line"> <span class="number">5</span> putstatic #<span class="number">17</span> &lt;tempTest/ClassLoader/son.sb&gt;</span><br><span class="line"> <span class="number">8</span> getstatic #<span class="number">19</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">11</span> ldc #<span class="number">25</span> &lt;<span class="number">2.</span>子类静态代码块：赋值sb成功&gt;</span><br><span class="line"><span class="number">13</span> invokevirtual #<span class="number">27</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">16</span> getstatic #<span class="number">19</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">19</span> <span class="keyword">new</span> #<span class="number">33</span> &lt;java/lang/StringBuilder&gt;</span><br><span class="line"><span class="number">22</span> dup</span><br><span class="line"><span class="number">23</span> ldc #<span class="number">35</span> &lt;<span class="number">2.</span>子类静态代码块：sa的值&gt;</span><br><span class="line"><span class="number">25</span> invokespecial #<span class="number">37</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">28</span> getstatic #<span class="number">15</span> &lt;tempTest/ClassLoader/son.sa&gt;</span><br><span class="line"><span class="number">31</span> invokevirtual #<span class="number">40</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">34</span> invokevirtual #<span class="number">44</span> &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">37</span> invokevirtual #<span class="number">27</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">40</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>从中可以看到clinit函数执行的代码就是son函数<strong>static修饰的变量与块的顺序执行过程</strong>，但注意，<strong>final static</strong> 修饰的变量在这里并没有字节码进行赋值，是因为在编译阶段，final类型变量就已经写入常量池中，final static在准备阶段为类变量准备空间的时候就已经赋值完成了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> #<span class="number">8</span> = Utf8               sfinal</span><br><span class="line"> #<span class="number">9</span> = Utf8               ConstantValue</span><br><span class="line">#<span class="number">10</span> = Integer            <span class="number">56</span></span><br><span class="line">     <span class="comment">// public static final int sfinal = 56;</span></span><br><span class="line">#<span class="number">11</span> = Utf8               sonObjectFinal</span><br><span class="line">#<span class="number">12</span> = Integer            <span class="number">45</span></span><br><span class="line">     <span class="comment">//  public final int sonObjectFinal = 45;</span></span><br></pre></td></tr></table></figure>

<h2 id="多线程时类加载的方案"><a href="#多线程时类加载的方案" class="headerlink" title="多线程时类加载的方案"></a>多线程时类加载的方案</h2><p>对于<strong>每一个类&#x2F;接口</strong>，都有一个<strong>唯一的初始化锁</strong>与之对应。</p>
<ol>
<li>通过在Class对象上同步（获取对应的初始化锁），来控制初始化。获取锁的线程会一直等待，直到当前线程获得了锁。</li>
<li>当前线程A获得了锁，由于**state **&#x3D; noInitialization，设置state &#x3D; initializing 执行初始化的过程，线程B等待初始化锁</li>
<li>线程A完成类的初始化（类加载生成class对象），设置状态state&#x3D;initialized，唤醒等待锁的线程</li>
<li>读取state&#x3D;initialized，结束初始化。</li>
<li>其他线程初始化线程，获得初始化锁，读取state&#x3D;initialized，结束初始化。</li>
</ol>
<h1 id="对象创建的过程"><a href="#对象创建的过程" class="headerlink" title="对象创建的过程"></a>对象创建的过程</h1><ul>
<li>检查类是否加载</li>
<li>内存分配，设置对象头，赋予初值</li>
<li>执行构造函数&lt;init&gt;函数<ul>
<li>先调用父类的init函数，</li>
<li>然后是类实例变量的初始化（按照出现的顺序），</li>
<li>最后是new对象时采取的构造函数的代码。几个构造函数就有几个init方法</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassNewDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">	        son sons=<span class="keyword">new</span> <span class="title class_">son</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	   <span class="comment">// 	String className = &quot;tempTest.ClassLoader.son&quot;;</span></span><br><span class="line">	   <span class="comment">// 	ClassLoader.getSystemClassLoader().loadClass(className);</span></span><br><span class="line">	    		<span class="comment">//loadclass，只加载（读取class文件到内存生成class对象），不进行初始化</span></span><br><span class="line">	    <span class="comment">//	Class.forName(className);</span></span><br><span class="line">         			<span class="comment">//类加载，执行到类的初始化</span></span><br><span class="line">	    	<span class="comment">//System.out.println(son.a);</span></span><br><span class="line">            	<span class="comment">//类的static变量，只加载，初始化 类静态变量所在的类</span></span><br><span class="line">         <span class="comment">//	System.out.println(son.sfinal);</span></span><br><span class="line">	    <span class="comment">//	System.out.println(son.sa);</span></span><br><span class="line">           		 <span class="comment">//读取类的final static 类型变量，不进行类加载与初始化</span></span><br><span class="line">	  <span class="comment">//  	son[] arr = new son[10];</span></span><br><span class="line">            		<span class="comment">//数组，不触发类加载</span></span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>son sons &#x3D; new son(“hello”)</p>
<ol>
<li>分配空间，2.实例final，3.init函数初始化，4.赋值引用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对应的字节码文件</span><br><span class="line"><span class="number">0</span> <span class="keyword">new</span> #<span class="number">19</span> &lt;tempTest/ClassLoader/son&gt;</span><br><span class="line">    <span class="comment">//Create new object  the instance variables of the new object are initialized to their default initial values (§2.3, §2.4).</span></span><br><span class="line">    <span class="comment">//1. 分配内存，赋初值</span></span><br><span class="line"> <span class="number">3</span> dup</span><br><span class="line">    <span class="comment">//Duplicate the top operand stack value，</span></span><br><span class="line"> <span class="number">4</span> ldc #<span class="number">21</span> &lt;hello&gt;</span><br><span class="line">    <span class="comment">//Push item from run-time constant pool，</span></span><br><span class="line">    <span class="comment">//2.类的实例final变量，从常量池获取string字符串</span></span><br><span class="line"> <span class="number">6</span> invokespecial #<span class="number">23</span> &lt;tempTest/ClassLoader/son.&lt;init&gt;&gt;</span><br><span class="line">    <span class="comment">//	Invoke instance method; special handling for superclass, private, and instance initialization method invocations</span></span><br><span class="line">    <span class="comment">//3.调用son的init函数来进行初始化</span></span><br><span class="line"> <span class="number">9</span> astore_1</span><br><span class="line">    <span class="comment">//Store reference into local variable，</span></span><br><span class="line">    <span class="comment">//4. 赋值引用， 把引用 赋值本地变量表中下标为1的变量，son，</span></span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">           <span class="number">10</span>       <span class="number">1</span>     <span class="number">1</span>  sons   LtempTest/ClassLoader/son;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="init函数分析"><a href="#init函数分析" class="headerlink" title="init函数分析"></a>init函数分析</h2><p>从字节码文件可以看出，init方法，</p>
<ul>
<li>先调用父类的init函数，</li>
<li>然后是类实例变量的初始化（按照出现的顺序），</li>
<li>最后是new对象时采取的构造函数的代码。几个构造函数就有几个init方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String参数对应的init函数 </span><br><span class="line"><span class="number">0</span> aload_0</span><br><span class="line"> <span class="comment">//Load reference from local variable ，this指针</span></span><br><span class="line"> <span class="number">1</span> invokespecial #<span class="number">75</span> &lt;tempTest/ClassLoader/son.&lt;init&gt;&gt;</span><br><span class="line">     <span class="comment">//调用函数，this（）；</span></span><br><span class="line"> <span class="number">4</span> getstatic #<span class="number">21</span> &lt;java/lang/System.out&gt;</span><br><span class="line">     <span class="comment">//Get static field from class </span></span><br><span class="line"> <span class="number">7</span> aload_1</span><br><span class="line"> <span class="number">8</span> invokevirtual #<span class="number">29</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">11</span> <span class="keyword">return</span></span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"> LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">12</span>     <span class="number">0</span>  <span class="built_in">this</span>   LtempTest/ClassLoader/son;</span><br><span class="line">            <span class="number">0</span>      <span class="number">12</span>     <span class="number">1</span>  name   Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">空构造函数对应的init函数</span><br><span class="line"> <span class="number">0</span> aload_0</span><br><span class="line"> <span class="number">1</span> invokespecial #<span class="number">60</span> &lt;tempTest/ClassLoader/parent.&lt;init&gt;&gt;</span><br><span class="line">    <span class="comment">//调用父类的初始化函数</span></span><br><span class="line"> <span class="number">4</span> aload_0</span><br><span class="line"> <span class="number">5</span> bipush <span class="number">45</span></span><br><span class="line"> <span class="number">7</span> putfield #<span class="number">62</span> &lt;tempTest/ClassLoader/son.sonObjectFinal&gt;</span><br><span class="line"><span class="number">10</span> aload_0</span><br><span class="line"><span class="number">11</span> aload_0</span><br><span class="line"><span class="number">12</span> invokevirtual #<span class="number">64</span> &lt;tempTest/ClassLoader/son.initc2&gt;</span><br><span class="line"><span class="number">15</span> putfield #<span class="number">56</span> &lt;tempTest/ClassLoader/son.sc&gt;</span><br><span class="line">    <span class="comment">//类的实例变量初始化完毕</span></span><br><span class="line"><span class="number">18</span> getstatic #<span class="number">21</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">21</span> <span class="keyword">new</span> #<span class="number">35</span> &lt;java/lang/StringBuilder&gt;</span><br><span class="line"><span class="number">24</span> dup</span><br><span class="line"><span class="number">25</span> ldc #<span class="number">66</span> &lt;<span class="number">6.</span>子类构造方式开始执行---&gt; sa:&gt;</span><br><span class="line">    </span><br><span class="line"><span class="number">27</span> invokespecial #<span class="number">39</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line">    </span><br><span class="line"><span class="number">30</span> getstatic #<span class="number">17</span> &lt;tempTest/ClassLoader/son.sa&gt;</span><br><span class="line">    ---</span><br><span class="line"><span class="number">56</span> <span class="keyword">new</span> #<span class="number">35</span> &lt;java/lang/StringBuilder&gt;</span><br><span class="line"><span class="number">59</span> dup</span><br><span class="line"><span class="number">60</span> ldc #<span class="number">73</span> &lt;<span class="number">6.</span>子类构造方式开始执行---&gt; sc:&gt;</span><br><span class="line"><span class="number">62</span> invokespecial #<span class="number">39</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">65</span> aload_0</span><br><span class="line">	---</span><br><span class="line"><span class="number">78</span> <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="对象创建的一些要点"><a href="#对象创建的一些要点" class="headerlink" title="对象创建的一些要点"></a>对象创建的一些要点</h1><ul>
<li>数组，不触发类加载</li>
<li><strong>类的static变量</strong>，只加载，初始化类静态变量<strong>所在的类</strong></li>
<li>读取<strong>类的final static 类型变量</strong>，不进行类加载与初始化</li>
</ul>
<h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><p>对象大小：一定8字节的整数倍</p>
<ol>
<li><p>对象头：</p>
<ol>
<li><p>markword64 - 8个字节（锁，hashcode，分代年龄，具体内容 markOop文件）</p>
</li>
<li><p>类型指针   8个字节，压缩–4个字节</p>
</li>
<li><p>数组信息（如果是数组类型）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> OFFSET  SIZE                 TYPE DESCRIPTION        VALUE</span><br><span class="line">      0     4                      (object header)    (1)</span><br><span class="line">      4     4                      (object header)   (0)</span><br><span class="line">      8     4                      (object header)   (1539673)</span><br><span class="line">     12     4                      (object header)   (10)//数组长度</span><br><span class="line">     16    40   self.test.demo.son son;.&lt;elements&gt;    N/A//对象引用</span><br><span class="line">Instance size: 56 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>实例变量：</p>
<ol>
<li><p>优先与对象头凑成8字节，（不一定按照变量出现的顺序）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码：     </span><br><span class="line">	<span class="keyword">public</span> <span class="type">long</span> <span class="variable">slong</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">	  <span class="keyword">private</span> <span class="type">int</span> sc=initc2(); </span><br><span class="line">内存布局：	  </span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>    <span class="type">int</span> son.sc                                    <span class="number">12</span></span><br><span class="line">     <span class="number">16</span>     <span class="number">8</span>   <span class="type">long</span> son.slong                                 <span class="number">5</span></span><br><span class="line">Instance size: <span class="number">24</span> bytes</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span>改成<span class="type">int</span>后：   </span><br><span class="line">    	<span class="keyword">public</span> <span class="type">int</span> <span class="variable">slong</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">	  	<span class="keyword">private</span> <span class="type">int</span> sc=initc2(); </span><br><span class="line"> 		<span class="number">12</span>     <span class="number">4</span>    <span class="type">int</span> son.slong                                 <span class="number">5</span></span><br><span class="line">    	<span class="number">16</span>     <span class="number">4</span>    <span class="type">int</span> son.sc                                    <span class="number">12</span></span><br><span class="line">Instance size: <span class="number">24</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> <span class="type">bytes</span> <span class="variable">external</span> <span class="operator">=</span> <span class="number">4</span> bytes total</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>对齐填充：补对象大小到8字节</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">20     4        (loss due to the next object alignment)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="指针压缩"><a href="#指针压缩" class="headerlink" title="指针压缩"></a>指针压缩</h3><pre><code>-XX:+UseComressedClassPointers：压缩类指针
   
-XX:+UseCompressedOops：压缩对象指针
</code></pre>
<p>内存最小单元，1字节，8位。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>数量</th>
<th>内存最小单元</th>
<th>单位</th>
</tr>
</thead>
<tbody><tr>
<td>64位</td>
<td>$2^{64}$</td>
<td>一个字节，8位</td>
<td>B</td>
</tr>
<tr>
<td>32位（开启压缩指针）</td>
<td>$2^{32}$</td>
<td>八个字节，</td>
<td>8B</td>
</tr>
</tbody></table>
<p>开启压缩指针的32位，内存最小单位8字节，$2^{32}*8B &#x3D; 32GB$</p>
<blockquote>
<p>内存最小单位8字节：每八个字节（一个64位的内存地址）记录一次引用</p>
</blockquote>
<p>指针压缩后的寻址范围：4GB-32GB</p>
<ul>
<li>4GB：$2^{32}*1B &#x3D; 4GB$ ，32位，4个字节，单位1B</li>
<li>32GB：$2^{32}*8B &#x3D; 32GB$，32位，4个1字节，单位8B</li>
</ul>
<p>64位，内存最小单元为一字节，数量：$2^{64}$，单位：B，在0-32GB的内存中，使用了35位，$2^{35} &#x3D; 2^5<em>2^{10</em>3}$</p>
<h1 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h1><p>类型的生命周期：加载(Loading) -&gt; 验证(Verification)-&gt;准备(Preparation)-&gt;解析(Resolution)-&gt;初始化(Initialization)-&gt;使用(Using)-&gt;卸载(Unloading)</p>
<p><img src="https://fkyang-blog-cloud-photo.oss-cn-beijing.aliyuncs.com/img/java/JVM/ClassLoader.jpg" alt="ClassLoader"></p>
<blockquote>
<ol>
<li>解析可以在初始化之前，也可以在初始化之后（动态&#x2F;晚期绑定）</li>
<li>以上图为开始顺序，各阶段可以并行</li>
</ol>
</blockquote>
<p>六种情况必须对类进行初始化：对一个类型进行主动引用</p>
<blockquote>
<ol>
<li>遇到new，getstatic，putstatic，invokestatic字节码指令时。<ol>
<li>new ：new关键字实例化对象时</li>
<li>读取&#x2F;设置一个类型的静态字段时，（final修饰的，在编译期把结果放入常量池的静态字段除外）</li>
<li>调用一个类型的静态方法时。</li>
</ol>
</li>
<li>使用java.long.reflect包的方法对类型进行反射调用的时候。</li>
<li>初始化类的时候，若父类未初始化，则先初始化父类</li>
<li>虚拟机启动时，初始化主类（main方法的类）</li>
<li>JDK7的动态语言支持，java.long.invoke.MethodHandle实例最后的解析结果未，1.1的四种类方法句柄，且该类未被初始化</li>
<li>一个接口中定义了JDK8新加入的默认方法，该类的实现类初始化前，该接口需要先初始化。</li>
</ol>
</blockquote>
<p>被动引用不会触发初始化：</p>
<blockquote>
<ol>
<li>通过子类引用父类的<strong>静态字段</strong>，父类会初始化，子类不会</li>
<li>通过<strong>数组</strong>定义引用类，不会初始化。new对象往数组里添加时，new会导致初始化。</li>
<li><strong>常量</strong>会在编译期存入<em><strong>调用类</strong></em>的常量池中，本质上并没有直接引用到定义常量的类，不会导致类的初始化</li>
</ol>
</blockquote>
<p>接口的初始化：</p>
<ol>
<li>无法使用static{} ,但是编译器仍会构造<clinit>()构造器，初始化接口中定义的成员变量</li>
<li>接口在初始化时，不要求父接口也初始化，只有使用父接口的时候，才要求初始化。</li>
</ol>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p>加载，验证，准备，解析，初始化。</p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载的三个过程：</p>
<ol>
<li>通过一个类的全限定名， 来获取该<em><strong>类的二进制字节流</strong></em>。<ol>
<li>获取方式多种多样，压缩包(JAR),网络（Web Applet），计算生成（动态代理），其他文件生成（JSP），数据库，加密文件。。。。。</li>
<li>可以通过定义自己的类加载器区控制字节流的获取方式（重写一个类加载器的findClass()或loadClass()），来实现程序获取运行代码的动态性<ul>
<li>数组类不通过类加载器创建，由java虚拟机直接在内存中动态构造出来的。<ul>
<li><ol>
<li>数组的组件类型(去掉一个维度)为引用类型，则递归加载该组件类型</li>
<li>不是引用类型，虚拟机把数组标记为与对应的类加载器关联</li>
<li>数组类的可访问性与组件类型的可访问性一致，不是引用类型，默认public</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>将这个字节流所代表的静态存储结构转化为<em><strong>方法区</strong></em>运行时的数据结构。</li>
<li>在<em><strong>堆内存</strong></em>中生成一个此类的java.lang.Class对象，作为方法区这个类的各种数据的入口。</li>
</ol>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证的目的：确保Class文件中的字节流包含的信息符合约束要求，确保代码运行之后不会危害虚拟机自身到安全。</p>
<p>连接的第一步，总体分为四部分内容：文件格式验证，元数据验证，字节码验证，符号引用验证。</p>
<ol>
<li><p>文件格式验证：基于二进制流</p>
<ol>
<li>确保输入的字节流能够正确的解析并存储到方法区之内，<strong>格式</strong>上符合一个Java类型信息的要求。</li>
<li>通过了此阶段，字节流才被允许进入Java虚拟机内存的方法区存储。</li>
</ol>
</li>
<li><p>元数据验证：基于方法区的存储结构</p>
<ol>
<li>目的：<ol>
<li>对字节码描述的信息进行<strong>语义</strong>分析，保证其描述的信息符合要求。</li>
<li>对类的元数据类型进行语义校验。元数据是指用来描述数据的数据，</li>
</ol>
</li>
</ol>
</li>
<li><p>字节码验证:</p>
<ol>
<li><p>目的：通过数据流分析与控制流分析，确定<strong>程序语义</strong>是合法的，符合逻辑的。</p>
</li>
<li><p>对类的方法体：Class文件的<strong>Code属性</strong>进行校验分析，确保方法在运行时不会做出危害虚拟机安全的行为。</p>
<ol>
<li>任意时刻操作数栈的数据类型与指令代码序列都能配合工作。</li>
<li>跳转指令不会跳转到方法体以外的区域。</li>
</ol>
</li>
<li><p>Code属性中的StackMapTable属性：描述了基本块开始时本地变量表和操作栈的状态</p>
<blockquote>
<p>用来供类型检验证器检查和处理目标方法的局部变量和操作数栈需要的类型是否匹配,</p>
<p>把字节码验证—-&gt; 类型检查，节省了校验时间。</p>
</blockquote>
</li>
</ol>
</li>
<li><p>符号引用验证：重要却非必要，若大部分类都是重复使用的，则可以关闭此验证，节约时间。</p>
<ol>
<li>确保解析阶段能正常运行。</li>
<li>对类自身以外（常量池中的符号引用）的各类信息进行匹配性校验，该类是否<strong>缺少</strong>他依赖的外部类&#x2F;方法&#x2F;字段等<strong>资源</strong><ol>
<li>能否通过全限定名找到类</li>
<li>方法字段是否存在，是否可访问</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段：为类定义的变量(<em>static 修饰的静态变量</em>)分配内存并设定<em><strong>类变量初始值</strong></em>的阶段。</p>
<blockquote>
<p>初始值是变量的初始值，不是初始化值</p>
<p>在此阶段ConstantValue属性会被初始化赋值，final static 修饰的 基本类型&#x2F;String 类变量 </p>
</blockquote>
<blockquote>
<p>规范要求所有class信息存放到方法区中，但hotspot，jdk7之后的hotspot虚拟机把静态变量存放到Class对象中，堆内存中。</p>
</blockquote>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段：java虚拟机把常量池中的符号引用替换为直接引用的过程。</p>
<ul>
<li>符号引用：以一组符号来描述所引用的目标，符合Class文件格式的字面量，能无歧义的定位到目标即可。</li>
<li>直接引用：直接指向目标的指针，相对偏移量，或间接定位到目标的句柄。此时目标以及存在在虚拟机中</li>
</ul>
<p>在某些字节码指令之前，需要解析。</p>
<p>解析主要目标：类或接口，字段，类方法，接口方法，方法类型，方法句柄，调用点限定符。</p>
<ul>
<li><p>类或接口的解析：将一个符号引用N解析为一个类或接口的直接引用</p>
<ul>
<li>如果N不是数组类型，类加载器根据类的全限定名加载该类。</li>
<li>若N是数组类型且元素为对象，按照第一个加载</li>
<li>完成类加载，进行符号引用验证，解析完成</li>
</ul>
</li>
<li><p>字段解析：字段符号引用，首先进行类解析，类解析完成后</p>
<ul>
<li>若该类包含此字段，则解析完成，返回该字段的直接引用</li>
<li>or 若类实现了接口，按照继承关系搜索各个接口与父接口，若找到，返回该方法的直接引用</li>
<li>or 搜索父类，若找到，返回该方法的直接引用</li>
<li>or error，java.longNoSuchFieldError（）异常</li>
</ul>
</li>
<li><p>方法解析：基本类似字段解析</p>
<ul>
<li><blockquote>
<p>按照方法&#x2F;字段表-属性表里序号，在常量池查找所属类型CONSTANT_Methodref_info，然后查所属类</p>
</blockquote>
</li>
</ul>
</li>
<li><p>接口方法解析</p>
</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>执行类编写的Java程序代码。</p>
<p>准备阶段，赋初值，初始化阶段，初始化变量和其他资源。</p>
<p><clinit>()方法：需要是线程安全的。</p>
<blockquote>
<p>根据用户的静态块与类变量赋值语句生成的，收集的顺序是出现的顺序</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">	temp = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"><span class="comment">//初始化完成后：temp = 50</span></span><br></pre></td></tr></table></figure>

<p>静态语句可以赋值后面出现的变量，但无法访问</p>
</blockquote>
<p><clinit>父类先执行，子类的后执行。</p>
<p><clinit>方法，若无静态初始化内容，不会生成此方法。</p>
<ul>
<li>接口，无静态块，有接口变量初始化，会生成<clinit>,但不需要先执行父接口的此方法；父接口变量被使用时才初始化</li>
</ul>
</blockquote>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>类加载器功能：通过一个类的全限定名来获取该类的二进制字节流。</p>
<h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>java虚拟机中类唯一性的确定：类本身+加载它的类加载器</p>
<blockquote>
<p>equals , inInstance的返回结果</p>
</blockquote>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p><img src="https://fkyang-blog-cloud-photo.oss-cn-beijing.aliyuncs.com/img/java/JVM/JVMBootstrap.jpg" alt="JVMBootstrap"></p>
<ul>
<li><p><em><strong>启动类加载器(Bootstrap Class Loader)</strong></em>:加载在**<JAVA_HOME>\lib , -Xbootclasspath **指定路径的,被虚拟机识别的类库</p>
<ul>
<li>c++语言实现</li>
</ul>
</li>
<li><p><em><strong>扩展类加载器(Extension Class Loader)</strong></em>: **<JAVA_HOME>\lib\ext , java.ext.dirs系统变量 **路径下的类库.</p>
<ul>
<li>java语言实现</li>
</ul>
</li>
<li><p><em><strong>应用程序类加载器(Application Class Loader)</strong></em>: sun.misc.Launcher$AppClassLoader 实现</p>
<ul>
<li>ClassLoader.getSystemClassLoader() 方法的返回值就是该类.</li>
</ul>
<blockquote>
<p>以上三个系统类库,系统类加载器,负责加载用户类路径上的所有类库,</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>双亲委派模型:除了启动类加载器,其它类加载器都有自己的父类加载器,通常不是继承实现,<em><strong>组合实现</strong></em></p>
</blockquote>
<p>双亲委派:类加载器收到加载请求,请求父类加载,最终找到启动类加载器开始加载,</p>
<ul>
<li>加载完成:结束</li>
<li>父加载器加载失败:子加载器加载</li>
</ul>
<p>实现了类加载的优先级,保障了java程序的稳定性.</p>
<blockquote>
<p>自己写的java.long.Object类可以编译,但无法被加载</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/java/%E7%B1%BB%E5%8A%A0%E8%BD%BD/jdk9%E4%B9%8B%E5%90%8E%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8.png" alt="jdk9之后的加载器"></p>
<p>扩展类加载器被平台类加载器取代：</p>
<ul>
<li>JDK基于模块化构建，Java类库天然满足可扩展的需求，不需要<JAVA_HOME>\lib\ext目录来扩展JDK功能。</li>
</ul>
<p>类似的，<JAVA_HOME>\jre目录也不需要存在，因为可以随时组合出程序运行的jre来。</p>
<h4 id="双亲委派模型的破坏"><a href="#双亲委派模型的破坏" class="headerlink" title="双亲委派模型的破坏"></a>双亲委派模型的破坏</h4><ol>
<li><p>双亲委派模型在1.2被引进，1.1就有类加载器的概念。</p>
<ul>
<li>为了兼容，无法避免loadclass被子类重写的情况，加入findclass（），引导用户重写此方法</li>
</ul>
</li>
<li><p>有基础类型调回用户的代码，JNDI，</p>
<ul>
<li>引入，线程上下文类加载器</li>
</ul>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/java/%E7%B1%BB%E5%8A%A0%E8%BD%BD/%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.png" alt="线程上下文类加载器"></p>
<p><a href="http://blog.csdn.net/javazejian">图片来源</a></p>
</li>
<li><p>对程序的动态性的追求，热替换，热部署等。</p>
<ul>
<li>OSGI：不是双亲委派的树结构，网状结构</li>
</ul>
</li>
<li><p>模块化系统：在平台&#x2F;应用程序类加载器收到类的请求的时候，</p>
<ul>
<li>在委托父加载器之前，判断是否属于某个系统模块<ul>
<li>找到这样的归属关系，<strong>优先委派</strong>给那个<strong>模块的加载器</strong>加载</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="类加载的两种方式"><a href="#类加载的两种方式" class="headerlink" title="类加载的两种方式"></a>类加载的两种方式</h1><ul>
<li><p>Class.forname()</p>
</li>
<li><p>ClassLoader.loadClass(className)</p>
<ul>
<li>loadClass：双亲委派模型，protected 的loadClass方法代码逻辑实现<ul>
<li>可被重写，可以不符合 双亲委派模型</li>
</ul>
</li>
<li>findClass方法：提供 用来重写的符合双亲委派模型的  类加载器子类</li>
</ul>
</li>
</ul>
<h2 id="ClassLoader-loadClass-className"><a href="#ClassLoader-loadClass-className" class="headerlink" title="ClassLoader.loadClass(className)"></a>ClassLoader.loadClass(className)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">       <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>默认调用的loadClass(String name)方法调用了一个protected的LoadClass（String name，boolean resolve）方法，设置的resolve（解析）为false，默认不解析</p>
<p>loadclass方法，可以在自定义类的构造器的时候进行重写，但不建议，protected的loadclass方法内部实现了双亲委派的逻辑.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">      <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//上锁，防止并发时，多个线程同时进行对一个类进行加载</span></span><br><span class="line">      <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">          Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">          <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;<span class="comment">//类还没有被加载，堆中无class对象</span></span><br><span class="line">              <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                      c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                      <span class="comment">//委托给父类进行加载</span></span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      c = findBootstrapClassOrNull(name);</span><br><span class="line">                      <span class="comment">//bootstrap class loader是否能够加载</span></span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                  <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                  <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="comment">//仍然未找到,调用findclass进行类加载</span></span><br><span class="line">                  <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                  c = findClass(name);	<span class="comment">//Classloader为abstract类，子类需要实现这个方法</span></span><br><span class="line">                  sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                  sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                  sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (resolve) &#123;<span class="comment">//是否在类加载的时候,进行解析(初始化在解析之后)</span></span><br><span class="line">              resolveClass(c);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> c;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>默认的,loadclass不进行解析,也就不会在调用loadclass之后完成类的初始化工作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">protected</span> Object <span class="title function_">getClassLoadingLock</span><span class="params">(String className)</span> &#123;</span><br><span class="line">     <span class="comment">// 默认情况下，类加载器本身作为锁，只能串行加载</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (parallelLockMap != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果注册成功了，则支持分段锁，即支持并行加载</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">newLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">            <span class="comment">// 对同一个类，返回同一把锁,类名当作hashmap的key</span></span><br><span class="line">            lock = parallelLockMap.putIfAbsent(className, newLock);</span><br><span class="line">            <span class="keyword">if</span> (lock == <span class="literal">null</span>) &#123;</span><br><span class="line">                lock = newLock;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">//返回锁</span></span><br><span class="line">        <span class="keyword">return</span> lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Object&gt; parallelLockMap;</span><br><span class="line">构造函数中,若类加载器是并行的类加载器,</span><br><span class="line">parallelLockMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!checkName(name))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> findLoadedClass0(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//true if the name is null or has the potential to be a valid binary 如果名称为null或有可能成为有效的二进制名称，则为true</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((name == <span class="literal">null</span>) || (name.length() == <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> ((name.indexOf(<span class="string">&#x27;/&#x27;</span>) != -<span class="number">1</span>)</span><br><span class="line">            || (!VM.allowArraySyntax() &amp;&amp; (name.charAt(<span class="number">0</span>) == <span class="string">&#x27;[&#x27;</span>)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass0(String name);</span><br><span class="line"><span class="comment">//本地方法,是否类被加载</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a class loaded by the bootstrap class loader;</span></span><br><span class="line"><span class="comment">     * or return null if not found.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; findBootstrapClassOrNull(String name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!checkName(name)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> findBootstrapClass(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return null if not found</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> Class&lt;?&gt; findBootstrapClass(String name);</span><br></pre></td></tr></table></figure>



<h2 id="Class-forname"><a href="#Class-forname" class="headerlink" title="Class.forname()"></a>Class.forname()</h2><p>默认加载类，并执行到初始化阶段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line">                <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> forName0(className, <span class="literal">true</span>,</span><br><span class="line">                        ClassLoader.getClassLoader(Reflection.getCallerClass()));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//ClassLoader.getClassLoader(Reflection.getCallerClass())：APPClassLoader</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; forName0(String name, <span class="type">boolean</span> initialize,</span><br><span class="line">                                            ClassLoader loader)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>默认调用的Class.forname(String classname)方法，调用了一个本地的classname0方法，设置的默认initialize（是否初始化）为true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String name, <span class="type">boolean</span> initialize,</span><br><span class="line">                                   ClassLoader loader)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (sun.misc.VM.isSystemDomainLoader(loader)) &#123;</span><br><span class="line">            <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">ClassLoader</span> <span class="variable">ccl</span> <span class="operator">=</span> ClassLoader.getClassLoader(Reflection.getCallerClass());</span><br><span class="line">                <span class="keyword">if</span> (!sun.misc.VM.isSystemDomainLoader(ccl)) &#123;</span><br><span class="line">                    sm.checkPermission(</span><br><span class="line">                        SecurityConstants.GET_CLASSLOADER_PERMISSION);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> forName0(name, initialize, loader);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h2 id="AppClassLoader"><a href="#AppClassLoader" class="headerlink" title="AppClassLoader"></a>AppClassLoader</h2><p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/AppClassLoader%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="AppClassLoader类加载过程"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-- classloader</span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">-- loadClass(name, <span class="literal">false</span>); AppClassLoader</span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String cn, <span class="type">boolean</span> resolve)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// for compatibility reasons, say where restricted package list has</span></span><br><span class="line">            <span class="comment">// been updated to list API packages in the unnamed module.</span></span><br><span class="line">            <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cn.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (i != -<span class="number">1</span>) &#123;</span><br><span class="line">                    sm.checkPackageAccess(cn.substring(<span class="number">0</span>, i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.loadClass(cn, resolve);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">--<span class="built_in">super</span>.loadClass(cn, resolve);BuiltinClassLoader</span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String cn, <span class="type">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        Class&lt;?&gt; c = loadClassOrNull(cn, resolve);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(cn);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">--loadClassOrNull(cn, resolve);BuiltinClassLoader</span><br><span class="line">     <span class="keyword">protected</span> Class&lt;?&gt; loadClassOrNull(String cn, <span class="type">boolean</span> resolve) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(cn)) &#123;</span><br><span class="line">            <span class="comment">// check if already loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(cn);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// find the candidate module for this class</span></span><br><span class="line">                <span class="type">LoadedModule</span> <span class="variable">loadedModule</span> <span class="operator">=</span> findLoadedModule(cn);</span><br><span class="line">                <span class="keyword">if</span> (loadedModule != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// package is in a module</span></span><br><span class="line">                    <span class="type">BuiltinClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> loadedModule.loader();</span><br><span class="line">                    <span class="keyword">if</span> (loader == <span class="built_in">this</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (VM.isModuleSystemInited()) &#123;</span><br><span class="line">                            c = findClassInModuleOrNull(loadedModule, cn);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// delegate to the other loader</span></span><br><span class="line">                        c = loader.loadClassOrNull(cn);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// check parent</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClassOrNull(cn);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// check class path</span></span><br><span class="line">                    <span class="keyword">if</span> (c == <span class="literal">null</span> &amp;&amp; hasClassPath() &amp;&amp; VM.isModuleSystemInited()) &#123;</span><br><span class="line">                        c = findClassOnClassPathOrNull(cn);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve &amp;&amp; c != <span class="literal">null</span>)</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">---findClassInModuleOrNull(loadedModule, cn);BuiltinClassLoader</span><br><span class="line"> <span class="keyword">private</span> Class&lt;?&gt; findClassInModuleOrNull(LoadedModule loadedModule, String cn) &#123;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(cn, loadedModule);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            PrivilegedAction&lt;Class&lt;?&gt;&gt; pa = () -&gt; defineClass(cn, loadedModule);</span><br><span class="line">            <span class="keyword">return</span> AccessController.doPrivileged(pa);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM--内存区域与溢出异常</title>
    <url>/2020/04/05/java/jvm/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="java内存区域"><a href="#java内存区域" class="headerlink" title="java内存区域"></a>java内存区域</h2><h2 id="1-1-运行时数据区域"><a href="#1-1-运行时数据区域" class="headerlink" title="1.1 运行时数据区域"></a>1.1 运行时数据区域</h2><span id="more"></span>

<p><img src="https://fkyang-blog-cloud-photo.oss-cn-beijing.aliyuncs.com/img/java/JVM/jdkMemory.png" alt="jdkMemory"></p>
<p>jdk1.8之后元空间</p>
<img src="https://fkyang-blog-cloud-photo.oss-cn-beijing.aliyuncs.com/img/java/JVM/JDK1-8Memory.jpg" alt="JDK1-8Memory" style="zoom:67%;" />



<h3 id="1-程序计数器：线程私有"><a href="#1-程序计数器：线程私有" class="headerlink" title="1. 程序计数器：线程私有"></a>1. 程序计数器：线程私有</h3><p><em><strong>较小的内存空间，当前线程所执行的字节码的行号指示器</strong></em></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>数据</th>
</tr>
</thead>
<tbody><tr>
<td>Java方法</td>
<td>记录的是虚拟机字节码指令的 <em>地址</em></td>
</tr>
<tr>
<td>本地方法</td>
<td>计数器数值为 <em><strong>空</strong></em> Undefined</td>
</tr>
</tbody></table>
<h3 id="2-java虚拟机栈：线程私有"><a href="#2-java虚拟机栈：线程私有" class="headerlink" title="2. java虚拟机栈：线程私有"></a>2. java虚拟机栈：线程私有</h3><ol>
<li><p>生命周期与线程相同</p>
</li>
<li><p>每一个<em><strong>方法（java方法）</strong></em>被调用到执行完毕返回，对应着栈帧在虚拟机的入栈与出栈过程</p>
</li>
<li><p>栈帧：存储<em>局部变量表</em>，操作数栈，动态链接，方法出口等信息。</p>
<blockquote>
<p>局部变量表：</p>
<ol>
<li>存放基本类型+对象的引用类型数据</li>
<li>存放方式:slot槽的方式，一个slot槽32bits</li>
<li>局部变量表的内存空间 – 编译期间完成分配<br>原因：一个方法在运行期间不会改变局部变量表的大小（slot数量）</li>
</ol>
</blockquote>
</li>
<li><p>异常</p>
<table>
<thead>
<tr>
<th>异常类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>StackOverflowError()</td>
<td>线程请求的栈深度大于虚拟机所允许的深度</td>
</tr>
<tr>
<td>OutOfMemoryError(OOM)</td>
<td>允许栈扩展，栈在扩展时，无法申请到足够的内存</td>
</tr>
</tbody></table>
<blockquote>
<p>HotSpot不支持栈扩展，只会出现StackOverflowError()异常</p>
</blockquote>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>异常类型：SOE,OOM</p>
<blockquote>
<p>HotSpot 不区分虚拟机栈与本地方法栈</p>
</blockquote>
<h3 id="java堆-：-线程共享"><a href="#java堆-：-线程共享" class="headerlink" title="java堆 ： 线程共享"></a>java堆 ： 线程共享</h3><ol>
<li>虚拟机启动时创建，存放对象实例</li>
</ol>
<blockquote>
<p>垃圾收集器管理的区域，GC堆</p>
</blockquote>
<p>异常类型：OOM    </p>
<blockquote>
<p>java 堆没有完成内存实例分配，并且堆也无法再扩展时。</p>
</blockquote>
<p><span id="string-pool"><em><strong>全局字符串池String Pool</strong></em></span>：类加载完成，经过验证，<strong>准备阶段之后</strong>在<em><strong>堆</strong></em>中生成字符串对象实例，然后将该字符串对象实例的<em><strong>引用值</strong></em>存到string pool中（记住：string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。）</p>
<blockquote>
<p>字符串常量池实际对象实例在堆中存储，方法区的常量池持有其引用。</p>
</blockquote>
</li>
</ol>
<h3 id="3-方法区：线程共享，元空间"><a href="#3-方法区：线程共享，元空间" class="headerlink" title="3. 方法区：线程共享，元空间"></a>3. 方法区：线程共享，元空间</h3><ol>
<li><p>存储虚拟机<em><strong>加载</strong></em>的类型信息，常量，静态变量，即时编译器编译后的代码缓存等数据。</p>
<blockquote>
<p>jdk 8 之前，永久代概念，实现。字符串常量池+静态变量 在jdk7移到堆中</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>jdk 8 ，完全废弃永久代概念，改为在<strong>本地内存</strong>中实现的<em><strong>元空间</strong></em>来替代。—-存储内容：类型数据</p>
</blockquote>
<p>  异常类型：OOM，方法区无法满足新的内存分配需求。</p>
<blockquote>
<table>
<thead>
<tr>
<th>name</th>
<th>content</th>
</tr>
</thead>
<tbody><tr>
<td>(静态)常量池</td>
<td>常量池数据编译期被确定，是<em><strong>Class文件中的一部分</strong></em>。存储了类、方法、接口等中的常量，当然也包括字符串常量。</td>
</tr>
<tr>
<td><a href="#string-pool">字符串池&#x2F;字符串常量池</a></td>
<td>是常量池中的一部分，存储编译期类中产生的字符串类型数据。<br /> 1. JDK1.6之前字符串常量池位于方法区之中。<br /> 2. JDK1.7字符串常量池已经被挪到堆之中。</td>
</tr>
<tr>
<td>运行时常量池</td>
<td>方法区的一部分，所有线程共享。虚拟机加载Class后把常量池中的数据（常量池表）放入到运行时常量池。</td>
</tr>
</tbody></table>
<ol>
<li>常量池：Class文件中的一部分，它是Class文件结构中与其他项目资源关联最多的数据类型。</li>
<li>常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic Reference），编译器生成。<ol>
<li>字面量：文本字符串、声明为final的常量值等；</li>
<li>符号引用：类和接口的完全限定名（Fully Qualified Name）、字段的名称和描述符（Descriptor）、方法的名称和描述符</li>
</ol>
</li>
</ol>
</blockquote>
<h4 id="3-1-运行时常量池-：-方法区的一部分"><a href="#3-1-运行时常量池-：-方法区的一部分" class="headerlink" title="3.1 运行时常量池 ： 方法区的一部分"></a>3.1 运行时常量池 ： 方法区的一部分</h4><p><em>class文件</em>：类版本，字段，方法，接口等描述信息+ 常量池表。</p>
<p>通过 String.intern()方法不断往运行时常量池里加字符串变量，最后Java.lang.OutOfMemoryError: Java heap space。证明java常量池字符串对象存储位置是堆空间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> String.valueOf(i).intern();</span><br><span class="line">           list.add(temp);</span><br><span class="line">       &#125;</span><br><span class="line">  <span class="comment">//     -Xms12M -Xmx12M,虚拟机运行参数，设置堆空间12m</span></span><br></pre></td></tr></table></figure>

<p>   <em><strong>动态性</strong></em>：编译期可以产生常量，运行时也可以把新的常量放入池中。</p>
<blockquote>
<p>String 的intern()，方法，若常量池中不存在该字符串，则加入常量池并返回其引用，若存在，则返回常量池的该字符串对象的引用</p>
</blockquote>
<p>异常类型：OOM，常量池无法申请到内存时。</p>
<h3 id="直接内存：本机内存，不属于java虚拟机运行时数据区的一部分"><a href="#直接内存：本机内存，不属于java虚拟机运行时数据区的一部分" class="headerlink" title="直接内存：本机内存，不属于java虚拟机运行时数据区的一部分"></a>直接内存：本机内存，不属于java虚拟机运行时数据区的一部分</h3><p>直接内存常被忽略，虚拟机内存+直接内存&lt;物理内存，否则，容易OOM</p>
<blockquote>
<p>NIO基于通道与缓冲区的I&#x2F;O方式，使用Native函数库直接分配堆外内存，通过一个堆中的DirectByteBuffer对象作为此内存的引用进行操作，避免在Java堆与Native堆相互复制数据。</p>
</blockquote>
<h2 id="1-2-HotSpot虚拟机"><a href="#1-2-HotSpot虚拟机" class="headerlink" title="1.2 HotSpot虚拟机"></a>1.2 HotSpot虚拟机</h2><blockquote>
<p>针对HotSpot虚拟机，java堆</p>
</blockquote>
<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><ol>
<li><p>检测<strong>类是否加载</strong></p>
</li>
<li><p>虚拟机为新生对象<strong>分配内存</strong>，内存大小在加载完便可以确定。</p>
<p>两种分配方法基于java堆是否完整：</p>
<table>
<thead>
<tr>
<th>name</th>
<th>content</th>
</tr>
</thead>
<tbody><tr>
<td>指针碰撞</td>
<td>堆完整&#x2F;连续内存，分为使用过的，未使用的。<br />分配内存表现为指针的移动<br />适用收集器：压缩整理过程的收集器</td>
</tr>
<tr>
<td>空闲列表</td>
<td>堆内存不完整，通过维护列表记录内存的使用情况。<br />分配内存：找一个足够大的空闲区，更新列表<br />适用收集器：清除算法的收集器</td>
</tr>
</tbody></table>
</li>
<li><p>将分配的内存空间（除了对象头）<strong>初始化为零值</strong>。</p>
</li>
<li><p><strong>设置对象头</strong>相关信息。</p>
</li>
<li><p>执行构造函数，class文件的**<init>**()方法</p>
</li>
</ol>
<p>​     </p>
<h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>三部分：对象头Header，实例数据Instance Data，对齐填充Padding</p>
<p>对象头：包含两类信息。</p>
<blockquote>
<ol>
<li>Mark Word –对象自身的运行时数据：哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳。</li>
</ol>
<p>与对象自身定义的数据无关的额外存储成本，动态的数据结构。</p>
<ol start="2">
<li>类型指针：对象指向它的类型元数据的指针。 —– 不一定由<br> 类型指针表明该对象是哪个类的实例。 查对象元数据不一定经过该对象，<br> 数组对象，记录数组长度的数据—–如果数组长度确定<br>        数组长度不定—无法通过元数据信息推断数组大小。</li>
</ol>
</blockquote>
<p>实例数据：对象真正存储的有效信息,程序代码中定义的各种类型的字段内容。</p>
<blockquote>
<p>父类，子类定义的字段。</p>
<p>存储顺序：按照相同宽度，先父后子的顺序。</p>
</blockquote>
<p>对齐填充：占位符的作用。</p>
<blockquote>
<p>填充到8字节的整倍数。对象头长度，8字节的整数倍</p>
</blockquote>
<h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>reference：对象的引用。</p>
<p>主流的访问方式：</p>
<table>
<thead>
<tr>
<th>name</th>
<th>content</th>
<th>优点</th>
</tr>
</thead>
<tbody><tr>
<td>句柄访问</td>
<td>java堆中句柄池，reference数值就是对象的句柄地址<br />句柄中包含对象的实例数据 ， 类型数据 各自的地址信息。</td>
<td>对象移动时(垃圾收集)，只改变句柄</td>
</tr>
<tr>
<td>直接指针访问(HotSpot)</td>
<td>reference数值为对象的地址</td>
<td>速度快</td>
</tr>
</tbody></table>
<p>   HotSpot主要使用直接指针访问。</p>
<h3 id="虚拟机测试实例"><a href="#虚拟机测试实例" class="headerlink" title="虚拟机测试实例"></a>虚拟机测试实例</h3><table>
<thead>
<tr>
<th>参数</th>
<th>content</th>
</tr>
</thead>
<tbody><tr>
<td>-Xms 20m</td>
<td>设置堆的最小值 20MB</td>
</tr>
<tr>
<td>-Xmx 20m</td>
<td>设置堆的最大值 20MB</td>
</tr>
<tr>
<td>-XX:+HeapDumpOnOutOfMemoryError</td>
<td>虚拟机内存异常时，打印当前堆存储快照</td>
</tr>
<tr>
<td>-Xss128k</td>
<td>栈空间</td>
</tr>
<tr>
<td>-XX:MaxMetaspaceSize</td>
<td>最大元空间大小，默认-1收到本机内存限制</td>
</tr>
<tr>
<td>-XX:MetaspaceSize</td>
<td>元空间初始大小，单位：字节；<br />达到该值，进行垃圾收集，类型卸载，同时调整该值 <br />释放大量空间，则减小，释放少量，适当增加</td>
</tr>
<tr>
<td>-XX:MinMetaspaceFreeRatio</td>
<td></td>
</tr>
<tr>
<td>-XX:MaxDirectMemorySize</td>
<td>直接内存，默认java最大堆数值</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>-Xlog:gc</td>
<td>输出GC日志</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM--垃圾回收</title>
    <url>/2020/04/05/java/jvm/GC/</url>
    <content><![CDATA[<h1 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h1><p>现在都是准确性垃圾回收</p>
<p>关注要点：</p>
<ol>
<li>那些内存需要回收</li>
<li>什么时候开始回收</li>
<li>如何回收</li>
</ol>
<blockquote>
<p>学习垃圾回收原因：虽然垃圾回收已经自动化，但是当垃圾回收成为更高并发量的瓶颈时，需要对其进行监控和调节</p>
</blockquote>
<span id="more"></span>

<p>程序计数器，虚拟机栈，本地方法栈：随线程的生命周期，栈帧的内存在编译器就确定(不考虑即时编译器的优化)。因此，不需要考虑内存的回收。</p>
<p>Java堆与方法区：不确定，运行时才能确定，垃圾收集器管理这一部分内存。</p>
<h2 id="判定对象已死：垃圾收集器的第一步"><a href="#判定对象已死：垃圾收集器的第一步" class="headerlink" title="判定对象已死：垃圾收集器的第一步"></a>判定对象已死：垃圾收集器的第一步</h2><p>第一步判断对象是否存活。死去：没有途径可以使用此对象。</p>
<h3 id="引用计数算法Reference-Counting"><a href="#引用计数算法Reference-Counting" class="headerlink" title="引用计数算法Reference Counting"></a>引用计数算法Reference Counting</h3><p>原理：每个对象持有一个引用计数器，有人引用，+1；引用失效，-1；若数值为0，则不会再被使用。</p>
<blockquote>
<p>优点：原理简单，判定效率高。</p>
<p>缺点：需要大量的额外处理才能正常工作。</p>
</blockquote>
<h3 id="可达性分析算法-Reachability-Analysis"><a href="#可达性分析算法-Reachability-Analysis" class="headerlink" title="可达性分析算法 Reachability Analysis"></a>可达性分析算法 Reachability Analysis</h3><p>基本思路：通过一系列<strong>GC Root <strong>的</strong>根对象</strong>作为起始节点集，从这些结点开始根据引用关系向下搜索，走过的路径称为“引用链”，如果某个对象到GC Root间没有任何引用链相连，则此对象不可到达。</p>
<p>Java中，可固定作为GC Roots的对象包含：</p>
<ol>
<li>虚拟机栈（栈帧的本地变量表）中的引用对象，方法堆栈用到的参数，局部变量，临时变量</li>
<li>方法区静态属性引用的对象，Java类的引用类型静态变量。</li>
<li>方法区中，常量引用的对象，比如：字符串常量池中的引用对象</li>
<li>JNI（Native方法）引用的对象。</li>
<li>Java虚拟机内部的引用，基本数据类型的Class对象，常驻的异常对象（NullPointException），系统类加载器</li>
<li>被同步锁（synchronized）持有的对象</li>
<li>反应Java虚拟机内部情况的JMXBean，JVMTI中注册的回调，本地代码缓存等。</li>
<li>其他临时性的对象</li>
</ol>
<p>GC回收中，注意内存的对象之间都是可以相互联系的。</p>
<h3 id="java的引用类型"><a href="#java的引用类型" class="headerlink" title="java的引用类型"></a>java的引用类型</h3><table>
<thead>
<tr>
<th>name</th>
<th>content</th>
</tr>
</thead>
<tbody><tr>
<td>强引用Strongly Reference</td>
<td>传统的引用定义，若对象有此引用，垃圾回收器不会回收</td>
</tr>
<tr>
<td>软引用Soft</td>
<td>还有用，非必须的对象，OOM前，把这些对象进行第二次回收</td>
</tr>
<tr>
<td>弱引用Weak</td>
<td>非必须，弱于软引用，生存到下一次垃圾收集器。GC开始工作时，无论当前内存是否足够，都会回收此类引用。</td>
</tr>
<tr>
<td>虚引用Phantom</td>
<td>最弱的引用，目的，在对象被gc回收时，能够收到通知。</td>
</tr>
</tbody></table>
<h3 id="java对象生存期"><a href="#java对象生存期" class="headerlink" title="java对象生存期"></a>java对象生存期</h3><p>两次标记进行回收：</p>
<blockquote>
<p>第一次标记：没有发现与GC Roots相连接的引用链</p>
<p>第二次标记：是否有必要执行finalize()方法，无必要或以及执行过，都当成没必要执行。</p>
<p>​						没必要执行，则进行第二次标记，等待被回收。</p>
<blockquote>
<p>Finalize（）流程：任何一个对象的此方法只会被调用一次。</p>
<ol>
<li>对象把自己放入F-Queue的队列之中。优先级较低的队列，虚拟机创建的队列，去执行finalize方法，不一定肯定执行完。（优先级较低，或者死循环）</li>
<li>稍后将对F-Queue中的对象进行标记，若连上GC Root，则逃脱，否则被回收。</li>
</ol>
<p>try–finally或者其他方法也可以完成此功能，finalize不提供保证一定执行。</p>
</blockquote>
</blockquote>
<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>方法区回收的性价比比较低：堆中，新生代中一次回收可以回收70%-90%的内存区域，而方法去很少</p>
<p>方法区回收的内容：废弃的常量 + 不再使用的类型</p>
<blockquote>
<ol>
<li><p>废弃常量：回收与java堆对象相似。字符串常量，其他类（接口），方法，字段的符号引用也与此类似。</p>
<p>当前系统没有一个引用常量池中的对象，发生内存回收，若有必要，清出常量池。</p>
</li>
<li><p>不再使用的类:以下三个需要全部满足</p>
<ol>
<li>该类实例全部被回收，java堆中不存在该类及其派生子类的实例。</li>
<li>加载该类的类加载器已经被回收，这个条件需要精心设计。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用。</li>
</ol>
<p>若满足这三个条件，可以被回收，不一定被回收，需要虚拟机进行参数设置。</p>
<blockquote>
<p> 在大量使用字节码框架(反射，动态代理)，或自定义类加载器的场景中(动态生成JSP)，java虚拟机需要具备类型卸载的功能，防止方法区过大。</p>
</blockquote>
</li>
</ol>
</blockquote>
<h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h3 id="新生代：标记复制"><a href="#新生代：标记复制" class="headerlink" title="新生代：标记复制"></a>新生代：标记复制</h3><p>不使用整理原因：整理比复制多了对象的拷贝（为了减少内存碎片）</p>
<ol>
<li>复制：从其他地方，移动到 suivi区<ol>
<li>直接将存活对象复制到另一块空闲内存区域中</li>
<li>按顺序分配内存–无内存碎片化问题</li>
</ol>
</li>
<li>整理：进行对象的交换（为了减少内存碎片）</li>
</ol>
<h3 id="老年代：标记-整理"><a href="#老年代：标记-整理" class="headerlink" title="老年代：标记-整理"></a>老年代：标记-整理</h3><p>标记整理算法解决来标记-清除算法的<strong>内存碎片化</strong>的问题，又解决了复制算法的两个Survivor区（<strong>额外内存</strong>）的问题</p>
<p>不用 标记–复制</p>
<ul>
<li>标记复制，在存活对象数量较多时，<ul>
<li>需要很多复制</li>
<li>也需要额外的内存空间</li>
</ul>
</li>
</ul>
<ul>
<li>弱分代：大多数对象是朝生夕灭的</li>
<li>强分代：熬过多次垃圾收集过程的对象就越难以消亡。</li>
<li>跨代引用假说：跨代引用相对于同代引用来说仅占少数。</li>
</ul>
<p>垃圾收集器的原则：把java堆划分不同的区域，把对象依据年龄放到不同的区域存储。</p>
<ul>
<li>新生代：每次垃圾收集有大批对象死去，每次回收后少量存活的对象，逐步晋升到老年代中</li>
<li>老年代：</li>
</ul>
<p>收集分类：</p>
<ul>
<li><p>部分收集Partial GC：不是完整的收集Java堆的垃圾收集</p>
<ul>
<li>Minor GC：新生代</li>
<li>Major GC：老年代</li>
<li>Mixed GC：混合收集</li>
</ul>
</li>
<li><p>整堆收集Full GC：收集整个Java堆和方法区的垃圾收集</p>
</li>
</ul>
<h2 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h2><p>首先<strong>标记</strong>出需要回收的对象，标记完成后，统一回收所有被标记的对象；</p>
<p>或者，标记存活的对象，统一回收未被标记的对象。</p>
<p>缺点：</p>
<ol>
<li>执行效率不稳定：效率随对象的增长而降低</li>
<li>内存空间的碎片化问题：标记清除产生大量不连续的内存碎片，大对象分配引发另一次垃圾回收。</li>
</ol>
<h2 id="标记复制算法：新生代的回收算法"><a href="#标记复制算法：新生代的回收算法" class="headerlink" title="标记复制算法：新生代的回收算法"></a>标记复制算法：新生代的回收算法</h2><p>目的:为了解决标记清除算法的效率低问题</p>
<p><em><strong>半区复制</strong></em>：把内存按容量分为大小相同的两块，每次使用其中的一块，垃圾回收的时候，就把存活的对象复制到另一块上</p>
<p>缺点：可用内存缩小一半。</p>
<p>优点：运行高效，实现简单，适用于大多数对象都是可回收的情形  —-  <em><strong>新生代</strong></em>。</p>
<h3 id="Appel式回收"><a href="#Appel式回收" class="headerlink" title="Appel式回收"></a>Appel式回收</h3><p>Appel式回收:Serial, ParNew等新生代收集器采用此方法设计新生代的内存布局。</p>
<p><em><strong>具体内容</strong></em>：把新生代分为一块<em><strong>较大的Eden</strong></em>空间，两块<em><strong>较小的Suivivor</strong></em>空间。</p>
<p>每次分配内存都只用Eden与一块Suivivor，发生垃圾收集时，将二者存活的对象放入未使用的Suivivor空间，然后直接清理用过的Eden与Suivivor空间。</p>
<p>Hotspot默认的Eden：Suivivor &#x3D; 8 ：1；每次新生代可用内存空间占据90%，只有一个10%的Suivivor会被浪费。</p>
<p>当发生垃圾回收的时候，Suivivor空间不足以容纳一次Minor GC存活的对象，就需要依赖其他区域（大多数时老年代）来进行<em><strong>分配担保</strong></em>。</p>
<h2 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h2><p>标记存活的对象，让存活的对象向一端移动，然后直接清除边界以外的内存。</p>
<blockquote>
<p>标记整理—移动活的对象：移动复杂，需要暂停程序，垃圾回收有<strong>停顿时间</strong></p>
<p>标记清除—不移动活得对象：分配复杂（碎片化），内存分配与访问器-降低吞吐量。垃圾回收无停顿时间</p>
</blockquote>
<ul>
<li>Parallel Scavenge：标记整理算法</li>
<li>CMS：平时标记清除,碎片化严重时标记整理</li>
</ul>
<h1 id="hotspot实现细节"><a href="#hotspot实现细节" class="headerlink" title="hotspot实现细节"></a>hotspot实现细节</h1><h2 id="根节点枚举GC-Roots"><a href="#根节点枚举GC-Roots" class="headerlink" title="根节点枚举GC Roots"></a>根节点枚举GC Roots</h2><p>根节点枚举时需要暂停用户线程</p>
<blockquote>
<p>现在可以与用户线程并发，但根节点枚举时仍然需要在保障一致性的快照中得以进行。</p>
<p>一致性：分析过程中，根节点集合的对象引用关系没有发生变化。</p>
<p>否则，正确性无法保证</p>
</blockquote>
<p>OopMap的数据结构：存放对象引用的地方。记录内存中那些地方有对象引用</p>
<blockquote>
<p>垃圾收集器直接通过这个数据结构的内容知晓对象引用的存储位置，不需要扫描GC Roots来查找</p>
<p>类加载完成后，就可以计算出类那些存有引用</p>
</blockquote>
<h2 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h2><p>安全点：在特定的位置上记录信息，这些位置为安全点</p>
<blockquote>
<p>指令必须到达安全点后才能进行垃圾回收。</p>
<p>安全点的选择：具有让程序长时间执行的特征，指令序列的服用的复用，方法调用，循环跳转，异常跳转等</p>
</blockquote>
<p>垃圾回收时，让所有的线程跑到最近的安全点停顿下来</p>
<ul>
<li>抢占式中断：不需要线程的执行代码主动去配合<ul>
<li>垃圾收集时，系统中断全部线程，若线程不在中断点上，就恢复线程的执行，过一会中断，知道安全点处</li>
</ul>
</li>
<li>主动式中断：垃圾回收时，不对线程进行操作，仅仅设置一个标志位<ul>
<li>线程轮流<strong>主动</strong>询问标志位，若标志位为真，自己就在最近的安全点上挂起，</li>
</ul>
</li>
</ul>
<h2 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h2><p>当程序处于sleep状态，Blocked状态，无法到达安全点</p>
<p>安全区域：在此区域内，引用关系不会发生变化。 ——- 扩展了的安全点</p>
<h2 id="记忆集与卡表（跨界引用问题）"><a href="#记忆集与卡表（跨界引用问题）" class="headerlink" title="记忆集与卡表（跨界引用问题）"></a>记忆集与卡表（跨界引用问题）</h2><p>记忆集：为了解决对象跨代引用的问题而引入的数据结构，避免把整个老年代加入GC Roots的扫描范围。</p>
<blockquote>
<p>记忆集：记录从非收集区域指向收集区域的指针集合的抽象数据结构。</p>
</blockquote>
<p>记录的精度：</p>
<ul>
<li>字长精度：每个记录精确到一个机器字长</li>
<li>对象精度：每个记录精确到一个对象</li>
<li>卡精度：记录精确到一块内存区域———最常见的</li>
</ul>
<p>卡表的一个单位，卡页通常不止一个对象，但只要有对象存在跨代引用，则该卡页标识为1</p>
<h2 id="GCRoot并行的可达性分析"><a href="#GCRoot并行的可达性分析" class="headerlink" title="GCRoot并行的可达性分析"></a>GCRoot并行的可达性分析</h2><p>三色标记算法：</p>
<ul>
<li>黑色：确定对象为非垃圾，并且其成员变量也找完了</li>
<li>灰色：确定对象为非垃圾，但是其成员变量尚未标完</li>
<li>白色：没有遍历的对象，垃圾对象</li>
</ul>
<p>对象消失问题：原本存活的对象，标记为死亡。</p>
<blockquote>
<p> 例子：原本灰色–&gt; 白色  转变为  黑色—&gt;白色  ，但是黑色已经被标记完成了，垃圾回收会把这个黑色相连的白色回收（但白色不是垃圾）</p>
</blockquote>
<p>解决方法：</p>
<ul>
<li>增量更新Incremental Update：黑色对象中新增指向白色对象的引用，把黑色对象变灰色<ul>
<li>写屏障更新</li>
<li>CMS</li>
</ul>
</li>
<li>原始快照Snapshot At The Beginning：灰色对象删除指向白色对象的引用时，记录删除的引用（白色），并发扫描结束后，看这些记录的删除的白色引用是否存在可达的（黑色）引用指向<ul>
<li>G1</li>
</ul>
</li>
</ul>
<h1 id="经典的垃圾回收器"><a href="#经典的垃圾回收器" class="headerlink" title="经典的垃圾回收器"></a>经典的垃圾回收器</h1><p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/HotSpot%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%A6%82%E8%BF%B0%E5%9B%BE.jpg" alt="HotSpot垃圾收集器"></p>
<p>Serial 几十M</p>
<p>Parallel 几个G</p>
<blockquote>
<p> 分代 需要写屏障</p>
</blockquote>
<p>CMS 几十G 开启并发回收</p>
<blockquote>
<p>三色标记 + 写屏障</p>
</blockquote>
<p>G1 上百G内存—–分区回收，逻辑分代，物理上不分</p>
<blockquote>
<p>三色标记 + SATB + 写批屏障</p>
</blockquote>
<p>ZGC,Shenandoah —-4T，逻辑物理不分代</p>
<blockquote>
<p>颜色指针 + 读屏障</p>
</blockquote>
<p>Epsilon 啥也不干，调试用，确认不需要GC参与，就能正常运行</p>
<h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>基于<strong>标记复制</strong>算法 </p>
<p>新生代收集器，<strong>单线程</strong>工作的</p>
<blockquote>
<p>单线程： </p>
<ul>
<li><p>只使用一个处理器</p>
</li>
<li><p>**Stop the World **在进行垃圾回收的时候，必须暂停其他所有工作线程，直到它收集结束</p>
</li>
</ul>
</blockquote>
<p>优点：简单而高效， 额外内存消耗最小，单核处理器的时候，没有线程交互的开销，效率高</p>
<p>大多数适合运行在客户端模式下的虚拟机</p>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/HotSpot%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8-Serial%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="HotSpot垃圾收集器-Serial收集器"></p>
<h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p>serial收集器的<strong>多线程并行</strong>版本，基于<strong>标记复制</strong>算法 ，<strong>STW</strong></p>
<p>能与CMS收集器配合工作，适合于服务端模式下的</p>
<p>在G1收集器出世之后，作为CMS处理新生代的基本组成部分，也是第一款退出的收集器。</p>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/HotSpot%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8-ParNew%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="HotSpot垃圾收集器-ParNew收集器"></p>
<h2 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h2><p>基于<strong>标记复制</strong>算法，并行收集的<strong>多线程</strong>收集器，不能与CMS一起使用</p>
<p>目的：达到一个可控制的吞吐量(Throughput)</p>
<p>吞吐量：处理器用于运行用户代码的时间与处理器总消耗时间的比值。</p>
<blockquote>
<p>吞吐量 &#x3D; 运行用户代码的时间&#x2F;（运行用户代码的时间 + 垃圾收集的时间 ）</p>
</blockquote>
<ul>
<li>停顿时间短:适合需要与用户交互或需要保证服务响应质量的程序</li>
<li>高吞吐量:最高效率的利用处理器资源,尽快完成程序的运算任务,时刻在后台运算不需要太多交互的任务</li>
</ul>
<blockquote>
<p>垃圾收集停顿时间缩短是以牺牲吞吐量为和新生代空间为代价的</p>
</blockquote>
<h2 id="Serial-Old收集器–Old"><a href="#Serial-Old收集器–Old" class="headerlink" title="Serial Old收集器–Old"></a>Serial Old收集器–Old</h2><p>serial收集器的老年代版本，单线程收集器，<strong>标记整理</strong>算法</p>
<p>使用：</p>
<ol>
<li>JDK5之前+Parallel Scavenge收集器搭配使用</li>
<li>作为CMS的失败的后备预案。</li>
</ol>
<h2 id="Parallel-Old收集器-–Old"><a href="#Parallel-Old收集器-–Old" class="headerlink" title="Parallel Old收集器 –Old"></a>Parallel Old收集器 –Old</h2><p>Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于<strong>标记整理</strong></p>
<p>适用于注重吞吐量，处理器资源比较稀缺、</p>
<h1 id="CMS于G1比较"><a href="#CMS于G1比较" class="headerlink" title="CMS于G1比较"></a>CMS于G1比较</h1><ul>
<li><p>并发时，线程继续运行的内存分配。</p>
</li>
<li><p>线程改变引用到错误处理：</p>
<ul>
<li>错标（）：是垃圾的标成了存活</li>
<li>漏标（）：不是垃圾的成了垃圾。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>NAME</th>
<th>并发</th>
<th>错标</th>
<th>漏标</th>
<th>跨界引用</th>
</tr>
</thead>
<tbody><tr>
<td>CMS</td>
<td>预留内存，<br />不够的时候，启动预留方案Serial old收集器</td>
<td>不够的时候，启动预留方案Serial old收集器</td>
<td>增量更新</td>
<td>一个卡表，记录新生代于老年代之间的引用</td>
</tr>
<tr>
<td>G1</td>
<td>region的一部分预留</td>
<td></td>
<td>原始快照</td>
<td>每个region维护一个卡表，记录自己指向其他，与其他指向自己</td>
</tr>
</tbody></table>
<h2 id="CMS收集器-Concurrent-Mark-Sweep-Old"><a href="#CMS收集器-Concurrent-Mark-Sweep-Old" class="headerlink" title="CMS收集器 Concurrent Mark Sweep Old"></a>CMS收集器 Concurrent Mark Sweep Old</h2><p>目标：<em>最短停顿时间</em>，基于<strong>标记清除</strong>，</p>
<p>适用于服务的响应速度要求高，系统的停顿时间短，更好的交互体验。</p>
<blockquote>
<p>耗时最长的2，4并发标记&#x2F;清除都是并发工作的</p>
<p>由于并发：</p>
<ol>
<li>gc线程占用资源</li>
<li>并发清除时间长，并发清除期间产生浮动垃圾</li>
<li>标记整理 碎片化</li>
</ol>
</blockquote>
<p>基于<strong>标记清除</strong>，过程分为四步</p>
<ol>
<li>初始标记 CMS initial mark—- <strong>STW</strong>停止用户线程<ol>
<li>标记<strong>GC Roots能直接关联</strong>的对象</li>
</ol>
</li>
<li>并发标记 CMS concurrent mark<ol>
<li>从GC Roots的直接关联对象开始遍历整个对象图的过程，可以与垃圾收集线程一起并发执行</li>
</ol>
</li>
<li>重新标记 CMS remark—-<strong>STW</strong>停止用户线程<ol>
<li>修正并发标记期间，因用户继续运作而导致标记产生变动的对象的标记记录。（增量更新）</li>
</ol>
</li>
<li>并发清除 CMS concurrent sweep<ol>
<li>清理删除标记阶段判断的已死亡的对象，不需要移动对象，标记清除算法</li>
</ol>
</li>
</ol>
<p>三色标记：</p>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/HotSpot%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8-CMS%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="HotSpot垃圾收集器-CMS收集器"></p>
<p>并发停顿收集器，三个缺点：</p>
<ol>
<li>对处理器资源非常敏感 – 并发占用资源导致应用程序变慢<ol>
<li>增量并发收集器，降低资源的消耗</li>
</ol>
</li>
<li>无法处理浮动垃圾，可能出现Concurrent Mode Failure导致Full GC<ol>
<li>浮动垃圾：CMS运行时产生的垃圾，标记过程以后，清除阶段产生的</li>
<li>Concurrent Mode Failure，<strong>预留的内存</strong>无法满足CMS运行时新分配对象的需要，启动预留方案，<strong>Serial old</strong>收集器运行，冻结用户进程</li>
</ol>
</li>
<li>标记清除，碎片化<ol>
<li>在Full GC前进行碎片整理（随着jdk版本的更新，设置的参数也没了-XX：）</li>
</ol>
</li>
</ol>
<h2 id="Garbage-First收集器-young-old"><a href="#Garbage-First收集器-young-old" class="headerlink" title="Garbage First收集器 young+old"></a>Garbage First收集器 young+old</h2><p><strong>标记复制算法</strong></p>
<p><strong>停顿时间模型</strong>的收集器：在长度M的时间片段中，垃圾回收消耗的时间大概率不超过N的目标</p>
<p>面向<strong>局部收集</strong>的设计思路，基于<strong>Region的内存布局</strong>。全功能的垃圾收集器。面向服务端的垃圾收集器，</p>
<p>局部收集：面向对内存的任何部分来组成<strong>回收集</strong>（Collection set Cset）进行回收，回收的衡量标准是哪块内存中存放的垃圾数量最多，<em>回收收益最大</em>。</p>
<h3 id="Region堆内存模型"><a href="#Region堆内存模型" class="headerlink" title="Region堆内存模型"></a>Region堆内存模型</h3><p>G1遵循分代收集理论，但不再坚持固定大小／数量的内存区域划分；把连续的Ｊａｖａ堆划分为多个大小相同的独立区域Region（-XX：G1HeapRegionSize 设置大小 1-32M 2的n次幂）。每一个Region都可以是Eden，suivive，老年代区域，收集器根据region所属的类型采用不同的垃圾回收策略。</p>
<p>Humongous区域：专门用来存储大对象的区域。基本上当作老年代</p>
<ul>
<li>大对象：大小超过了一个Region容量的一半的对象。</li>
<li>超级大对象（大小超过一个Region）：放在N个连续的Humongous Region区域，</li>
</ul>
<p>新生代与老年代是一系列动态区域的集合，把Region当成回收的最小单元每次回收的内存空间都是Region的整数倍。避免全区域的垃圾收集。</p>
<p>G1跟踪各个Region的价值（回收空间&#x2F;消耗时间）大小，维护一个优先级列表，优先回收价值收益最大的Region区域。</p>
<p>难点：</p>
<ul>
<li>跨引用：每个Region维护自己的记忆集，记录别的Region指向自己的指针，并标记这些指针在哪些卡页之中。<ul>
<li>G1的记忆集，hash表，key，其他region的起始地址，value，一个集合，存储卡表索引号。</li>
<li>双向指向：自身Region卡表谁指向我，其他region，我指向谁。</li>
<li>G1的卡表占用更多的内存消耗来记录信息。</li>
</ul>
</li>
<li>并发标记时：互不干扰：STAB（Snapshot at The Beginning ）原始快照。<ul>
<li>并发回收：为每一个Region设计两个TAMS（Top at Mark Start）指针，把Region的一部分划分出开用于并发回收时新对象的分配，并发回收时新对象地址在这两个指针上，G1默认这个地址上的对象时存活的</li>
<li>如果回收速度比不上内存分配速度，G1收集器被迫冻结用户线程执行。Full GC –STW</li>
</ul>
</li>
<li>可靠的停顿预测：衰减均值理论为基础，垃圾收集的时候，记录信息，衰减平均值。</li>
</ul>
<p>原始快照Snapshot：</p>
<p>G1收集器的步骤：</p>
<ol>
<li>初始标记 Initial Marking：GC Roots能够直接关联到的对象，修改TAMS的指针 <strong>STW</strong></li>
<li>并发标记Concurrent Marking：扫描整个堆的对象图，并发执行，扫描完成后，处理并发时SATB记录的变动对象。</li>
<li>最终标记 Final Marking：<strong>STW</strong>，处理并发标记阶段遗留的SATB记录</li>
<li>筛选回收Live Data Counting and Evacuation：更新Region的信息，排序Region的价值，组成回收集，把要回收的Region区域<strong>复制</strong>到空的Region，清理旧的Region–<strong>STW</strong>，移动对象，多个收集线程并行完成</li>
</ol>
<p>停顿时间-XX:MaxGCPauseMillis –过短，找到的满足条件的Region少，每次垃圾回收的量少，逐渐</p>
<p><em>目标：收集的速度跟得上对象分配的速度</em></p>
<p>G1相对CMS优点：可以指定最大停顿时间，整体标记整理，局部标记复制，垃圾收集能够提供规整的可用内存</p>
<p>总体 标记-整理，region之间，标记-复制，–不会产生内存碎片</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>垃圾回收的内（卡表）存占用大</li>
<li>程序运行的额外执行负载高：写后屏障维护卡表，STAB写前屏障跟踪并发指针变化。类似消息队列的结构，存储写前&#x2F;后屏障，异步处理。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/fkYang/CloudingPhoto/master/img/HotSpot%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8-G1%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="HotSpot垃圾收集器-G1收集器"></p>
<h1 id="低延迟垃圾收集器"><a href="#低延迟垃圾收集器" class="headerlink" title="低延迟垃圾收集器"></a>低延迟垃圾收集器</h1><p>衡量垃圾收集器的指标：内存占用（Footprint），吞吐量（Throughput），延迟（Latency）。</p>
<p>docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;technotes&#x2F;tools&#x2F;unix&#x2F;java.html</p>
<h2 id="Shenandoah收集器"><a href="#Shenandoah收集器" class="headerlink" title="Shenandoah收集器"></a>Shenandoah收集器</h2><h1 id="选择合适的收集器"><a href="#选择合适的收集器" class="headerlink" title="选择合适的收集器"></a>选择合适的收集器</h1><p>阅读和分析虚拟机与垃圾收集器的日志。</p>
<h1 id="调优方法"><a href="#调优方法" class="headerlink" title="调优方法"></a>调优方法</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol>
<li>吞吐量：用户代码时间&#x2F;（用户代码时间+垃圾回收时间）</li>
<li>响应时间：STW越短，响应时间越好</li>
</ol>
<p>换垃圾回收器，</p>
<h2 id="jvm常用命令行参数"><a href="#jvm常用命令行参数" class="headerlink" title="jvm常用命令行参数"></a>jvm常用命令行参数</h2><p>HotSpot参数：</p>
<blockquote>
<ol>
<li>标准：-开头，所有的HotSpot都支持</li>
<li>非标准：-X开头，特点支持</li>
<li>不稳定：-XX开通，下个版本可能没了</li>
</ol>
</blockquote>
<h2 id="CPU跑满"><a href="#CPU跑满" class="headerlink" title="CPU跑满"></a>CPU跑满</h2><h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><ol>
<li>内存泄漏 memory leak</li>
<li>内存溢出 OOM<ol>
<li>jmap看内存映像，找占内存的对象</li>
</ol>
</li>
</ol>
<h3 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h3><p>看线程</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM--类文件结构</title>
    <url>/2020/04/05/java/jvm/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><p>write once, run anywhere :代码编译的结果从<em>本地机器码</em>  转变为<em>字节码</em>，与操作系统和机器指令集无关，平台中立的格式作为程序编译后的结果</p>
<p>Java虚拟机，识别.class文件。</p>
<span id="more"></span>

<h2 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h2><p><strong>class文件</strong>：以<code>8个字节</code>为基础单位的<code>二进制流</code>。 每个字节都有其明确的含义，无分隔符。</p>
<blockquote>
<p>当数据需要多余八个字节的单位存储时（long，double），会按照高位在前分割成若干个八个字符存储。、</p>
<p><code>class文件的结构</code>： </p>
<ul>
<li><p>无符号数：基本的数据类型，u1,u2,u4,u8来描述1，2，4，8个字节的无符号数</p>
<ul>
<li>通常用于描述数字，索引引用，数量值或按照utf-8编码的字符串值</li>
</ul>
</li>
<li><p>表：多个无符号数或者其他的表作为数据项构成的<code>复合数据类型</code>。一整个class文件也可以看出一个表。</p>
<ul>
<li>命名，以_info结尾。</li>
</ul>
</li>
</ul>
<p>当需要描述同一类型，但是数量不定的多个数据的时候，会使用一个前置的容量计数器+若干个连续的数据项的形式。</p>
</blockquote>
<p><code>class类文件内容依次如下</code>：</p>
<h3 id="1-魔数与Class文件的版本"><a href="#1-魔数与Class文件的版本" class="headerlink" title="1 魔数与Class文件的版本"></a>1 魔数与Class文件的版本</h3><pre><code>     CA FE BA BE 00 00 00 39
</code></pre>
<p>前<em><strong>八个字节</strong></em>(第一个基本单位)： 魔数(4个字节) + 版本号(四个字节)。</p>
<ul>
<li><p>魔数：class文件的前四个字节</p>
<blockquote>
<p>作用：身份识别—确定这个文件是否是一个能够被虚拟机接受的Class文件。</p>
</blockquote>
</li>
<li><p>版本号：紧跟着魔数的四个字节。</p>
<blockquote>
<p>5,6个字节为次版本号(Minor Version)。第7，8个字节为主版本号(Major Version)。</p>
<blockquote>
<p>高版本的JDK能运行低版本的class文件，无法运行高版本的class文件。</p>
</blockquote>
</blockquote>
</li>
</ul>
<h3 id="2-常量池"><a href="#2-常量池" class="headerlink" title="2 常量池"></a>2 常量池</h3><pre><code>      00 28 
</code></pre>
<p>常量池：class文件的资源仓库，与其他项目关联最多的数据。</p>
<p>常量池入口在主次版本之后,<strong>u2类型</strong>的数据，代表着常量池容量计数值。</p>
<blockquote>
<p>常量池数量不固定。</p>
<blockquote>
<p>常量池标号从1开始，例如：0x12，仅有17个元素，下标，1-17.</p>
<p>常量池的标号0：用来表示不引用任何一个常量池的含义。</p>
<blockquote>
<p>其他集合类型都是从0开始的，比如接口索引，字段表等</p>
</blockquote>
</blockquote>
</blockquote>
<p><em><strong>存放内容</strong></em>：字面量 + 符号引用</p>
<blockquote>
<ul>
<li><p>字面量：文本字符串，被声明final的常量值等。</p>
</li>
<li><p>符号引用：编译原理方面的概念，</p>
<blockquote>
<p>包，类和接口的全限类名，字段&#x2F;方法的名称与描述符，方法句柄和方法类型，动态调用点与动态常量</p>
</blockquote>
</li>
</ul>
</blockquote>
<p>池中每一个常量都是一个表，截止JDK13，常量表中共有17中不同类型的常量。</p>
<blockquote>
<p>常量 ：tag（表明常量类别）+   （+ 长度，若常量变长String）+  内容(通常是指向utf-8类型的常量池索引)。</p>
</blockquote>
<blockquote>
<p>Class文件中的方法，字段等都是引用CONSTANT_Utf8_info型常量来描述名称，而CONSTANT_Utf8_info长度描述字符u2，最长65535，因此，方法&#x2F;类名最长64KB，否则无法编译。</p>
</blockquote>
<p>常量池中UTF8_info消息的<em><strong>I,V,<init> ,LineNumberTable，LocalVariableTable</strong></em>等常量。</p>
<blockquote>
<p>这些常量是编译器自动生成的，被后面的字段表(field_info),方法表(method_info),属性表(attribute_info)所引用，用来描述一些不方便用固定字节描述的内容，比如，方法的返回值，参数数量及类型的相关信息。</p>
</blockquote>
<h3 id="3-访问标识"><a href="#3-访问标识" class="headerlink" title="3 访问标识"></a>3 访问标识</h3><p>常量池结束之后，紧接着的<em><strong>两个字节</strong></em>是访问标识，用于识别类，接口的访问信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">普通的public ，java类，0x0021  = 0x0001（public）|0x0020（普通的类）</span><br></pre></td></tr></table></figure>

<h3 id="4-类-父类-接口索引集合"><a href="#4-类-父类-接口索引集合" class="headerlink" title="4 类&#x2F;父类&#x2F;接口索引集合"></a>4 类&#x2F;父类&#x2F;接口索引集合</h3><table>
<thead>
<tr>
<th>name</th>
<th>content</th>
</tr>
</thead>
<tbody><tr>
<td>类&#x2F;父类索引</td>
<td>u2类型，指向CONSTAN_Class_info的类描述符常量</td>
</tr>
<tr>
<td>接口索引</td>
<td>一组u2类型的数据</td>
</tr>
</tbody></table>
<p>class通过这三个索引确定类的继承关系。</p>
<p>接口索引集合：不定长数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">接口索引的第一项为u2类型的数据为接口计数器，表示索引表的容量，若无接口，则容量为0.  </span><br></pre></td></tr></table></figure>

<h3 id="5-字段表集合"><a href="#5-字段表集合" class="headerlink" title="5 字段表集合"></a>5 字段表集合</h3><p>字段表集合field_info：用来描述接口或类声明的变量。</p>
<blockquote>
<p>包括类级变量，以及实例级变量，但不包括方法内部声明的局部变量。</p>
</blockquote>
<table>
<thead>
<tr>
<th>name</th>
<th>content</th>
</tr>
</thead>
<tbody><tr>
<td>简单名称-name_index</td>
<td>无类型和参数修饰的 方法&#x2F;字段名称</td>
</tr>
<tr>
<td>描述符-descriptor_index</td>
<td>描述字段的数据类型，方法的参数列表（数量，类型，顺序）+返回值</td>
</tr>
<tr>
<td>全限定名-class_info中的name_index</td>
<td>把类全名中的.换成&#x2F;，例如：java&#x2F;long&#x2F;Object</td>
</tr>
</tbody></table>
<p>描述符描述变量：</p>
<pre><code>*	[[I:int 的二维数组
*	[[Ljava/lang/String:java.lang.String[ ][\   (L: 表示返回值是对象类型)
</code></pre>
<p>描述方法：先参数列表，后返回值的顺序，参数放在（）中</p>
<pre><code>*	()V :void name()
*	([CII[C)I : int name(char [] , int ,int ,char[] )
</code></pre>
<p>字段表集合中不会列出从父类&#x2F;接口中继承的字段，对于Class文件，只要描述符不完全相同，字段就是合法的-即使字段重名，且参数一样，只有返回值不一样。</p>
<blockquote>
<p>可能出现代码中不存在的字段，例如：在内部类中为了保持堆外部类的访问性，编译器自动添加指向外部类实例的字段</p>
</blockquote>
<h3 id="6-方法表集合"><a href="#6-方法表集合" class="headerlink" title="6 方法表集合"></a>6 方法表集合</h3><p>对方法的存储，与方法表几乎一样，只有访问标识与属性表集合中的可选项有区别。</p>
<pre><code>* 访问标识access_flags:少了volatile 与 transitent,多了synchronized,native,stricftp,abstract关键字
* 属性表集合attribute_info:
</code></pre>
<p>方法中的代码,经javac编译成字节码指令后,存放在<em><strong>方法属性表集合</strong></em>中一个名为Code的属性里面</p>
<h3 id="7-属性表集合"><a href="#7-属性表集合" class="headerlink" title="7 属性表集合"></a>7 属性表集合</h3><p>不要求属性表之间具有严格的顺序,只要属性名不重复.虚拟机在运行时,会忽略不认识的属性.</p>
<h4 id="code-属性-方法的代码存储区域"><a href="#code-属性-方法的代码存储区域" class="headerlink" title="code 属性:方法的代码存储区域"></a>code 属性:方法的代码存储区域</h4>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>leecode - 877鸡蛋掉落问题</title>
    <url>/2020/04/05/code/leecode/eggs877/</url>
    <content><![CDATA[<a href="https://leetcode-cn.com/problems/super-egg-drop" title="" target="">leecode链接</a>

<a href="https://leetcode-cn.com/problems/super-egg-drop/solution/ji-dan-diao-luo-by-leetcode" title="" target="">leecode官方题解链接</a>

<p><em><strong>以下内容为对官方题解的个人理解</strong></em></p>
<span id="more"></span>

<p>动态规划有两种</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[k][n] ==需要多少次操作</span><br><span class="line">	K个鸡蛋，n层楼</span><br><span class="line">具体在题解中很清晰了。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[t][k] == 最多能确定的楼层数，</span><br><span class="line">	K个鸡蛋，扔t次</span><br><span class="line">对于这种情况下的转移方程，一开始不能理解</span><br></pre></td></tr></table></figure>

<p>这种情况下的转移方程为：<br>$$<br>f(T,K)&#x3D;1+f(T−1,K−1)+f(T−1,K)<br>$$<br>第一中方法选择，针对扔的楼层是依次选择（或者二分找位置），选出最何时的数值</p>
<p>在现在这种情况下，每次选择都只有唯一的数值。</p>
<p>理解如下：</p>
<ol>
<li><p>在计算dp(t,k)的时候，事先已经确定了dp(t-1,k-1),dp(t-1,k)的数值。</p>
</li>
<li><p>在确定dp(t-1,k-1) &#x3D; a 数值后，选择仍鸡蛋的地方，这时候肯定不会选择小于等于a的楼层，</p>
<ol>
<li><p>选择楼层n&lt; a,</p>
<ul>
<li>碎了，在区间start - n中，能够确定位置，但由于 n &lt;a,可能最后会有鸡蛋&#x2F;步数还未到0就已经找到楼层位置，这是肯定不是最大楼层数</li>
<li>没碎，与 在a+ 1层仍，平白多了 a-n的判定区间。</li>
</ul>
</li>
<li><p>选择楼层 n &#x3D; a + 1；</p>
<ul>
<li>碎了，证明楼层在下面，这时候确定的楼层数：<ol>
<li>当前楼层 ：1</li>
<li>下面楼层： dp(t-1,k-1)</li>
<li>上面楼层数：x</li>
</ol>
</li>
</ul>
<ol>
<li>这个时候，由于鸡蛋已经碎裂，所以无论楼上有多少层，都可以找到位置，x为任意值</li>
<li>由于找最大，那x就去最大值，正无穷</li>
</ol>
<p>所以，在这种情况下，dp(t,k) &#x3D; 1 + dp(t-1,k-1) + 正无穷</p>
<ul>
<li>没碎，证明临界楼层在上面，这时候确定的楼层数：<ol>
<li>当前楼层：1</li>
<li>下面楼层： dp(t-1,k-1)</li>
<li>上面楼层，没碎，则能确定的最值为dp(t-1,k)。</li>
</ol>
</li>
</ul>
<p>所以，在这种情况下，dp(t,k) &#x3D; 1 + dp(t-1,k-1) + dp(t-1,k)。</p>
</li>
<li><p>选择楼层 n&gt; a+1</p>
<ol>
<li>若碎了，能够确定楼层在下面，但是由于 n &gt; dp(t-1,k-1),所以无法一定求出临界楼层位置。</li>
</ol>
</li>
</ol>
</li>
<li><p>综上所述，每次选择楼层都选择dp(t-1,k-1)+1 层楼扔，每次扔的楼层位置都是确定的。</p>
<p>dp(t,k) &#x3D; 1 + dp(t-1,k-1) + dp(t-1,k)</p>
</li>
</ol>
<p>最后对通过转移方程求解，dp[t,k] &gt;&#x3D; n, 其中k，n，固定，t是要求的数值。</p>
<blockquote>
<p>相当于求dp[1,k] , dp[2,k] … dp[t,k] 看看哪一个t的结果第一次大于等于n</p>
</blockquote>
<p>遍历的时候，外层t++，内层计算k。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">superEggDrop</span><span class="params">(<span class="type">int</span> K, <span class="type">int</span> N)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[K + <span class="number">2</span>][N + <span class="number">2</span>];</span><br><span class="line">		<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> ( m = <span class="number">1</span>; dp[K][m] &lt; N; m++) &#123;</span><br><span class="line">			  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= K; k++)</span><br><span class="line">			        dp[k][m] = dp[k][m - <span class="number">1</span>] + dp[k - <span class="number">1</span>][m - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">			  <span class="keyword">if</span>( dp[K][m] &gt;= N )</span><br><span class="line">				  <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> m;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>由于只用到了前一列的信息，把二维变成一维度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">superEggDrop2</span><span class="params">(<span class="type">int</span> K, <span class="type">int</span> N)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] dpNew = <span class="keyword">new</span> <span class="title class_">int</span>[K + <span class="number">2</span>];</span><br><span class="line">		<span class="type">int</span>[] dpOld = <span class="keyword">new</span> <span class="title class_">int</span>[K + <span class="number">2</span>];</span><br><span class="line">		<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> ( m = <span class="number">1</span>; ; m++) &#123;</span><br><span class="line">			  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= K; k++)</span><br><span class="line">			        dpNew[k] = dpOld[k] + dpOld[k - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">			  System.out.println(Arrays.toString(dpNew));</span><br><span class="line">			  System.out.println(Arrays.toString(dpOld));</span><br><span class="line">			  <span class="keyword">if</span>( dpNew[K] &gt;= N )</span><br><span class="line">				  <span class="keyword">break</span>;</span><br><span class="line">			  <span class="type">int</span>[] temp = dpNew;</span><br><span class="line">			  dpNew = dpOld;</span><br><span class="line">			  dpOld = temp;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> m;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>对于第二种，k个鸡蛋，t次扔的情况，一开始也是没搞清楚为什么相加就是最优解，明明是碎，不碎两种情况，但是转移方程不需要比较，只有一种情况。看了很多题解都没理解，最后看李永乐老师关于双蛋问题的讲解受到了启发才理解原因。</p>
</blockquote>
<a href="https://www.youtube.com/watch?v=mLV_vOet0ss" title="" target="">李永乐老师讲解双蛋问题(Youtube)</a>]]></content>
      <categories>
        <category>LeeCode</category>
      </categories>
  </entry>
  <entry>
    <title>tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
